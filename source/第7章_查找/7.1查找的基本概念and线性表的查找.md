树的高度（height）和节点个数（number of nodes）之间的关系可以用以下公式表示：

假设树的高度为 $ h $，节点个数为 $ n $，则有：

1. **对于满二叉树（Full Binary Tree）**：
   - 满二叉树的每一层都填满了节点。
   - 高度为 $ h $ 的满二叉树的节点个数 $ n $ 为：
     $
     n = 2^{h} - 1
     $
   - 反过来，如果知道节点个数 $ n $，可以求出高度 $ h $：
     $
     h = \log_2(n) - 1
     $

2. **对于完全二叉树（Complete Binary Tree）**：
   - 完全二叉树的最后一层可能没有填满，但所有层（除了最后一层）都填满了节点。
   - 高度为 $ h $ 的完全二叉树的节点个数 $ n $ 满足：
     $
     2^{h-1} \leq n < 2^{h}
     $
   - 反过来，如果知道节点个数 $ n $，可以求出高度 $ h $：
     $
     h = \lfloor \log_2(n) \rfloor + 1
     $

3. **对于一般的二叉树（Binary Tree）**：
   - 一般的二叉树没有特定的节点个数和高度关系，但可以有以下性质：
     - 高度为 $ h $ 的二叉树的节点个数 $ n $ 满足：
       $
       1 \leq n \leq 2^{h} - 1
       $
     - 反过来，如果知道节点个数 $ n $，可以求出最小高度 $ h $：按照完全二叉树

### 7.1 查找的基本概念

为了便于后面各节对各种查找算法的比较，首先介绍查找的概念和术语。

#### （1）查找表
查找表是由同一类型的数据元素（或记录）构成的集合。由于“集合”中的数据元素之间存在着完全松散的关系，因此查找表是一种非常灵便的数据结构，可以利用其他的数据结构来实现，比如本章将要介绍的线性表、树表及散列表等。

#### （2）关键字
关键字是数据元素（或记录）中某个数据项的值，用它可以标识一个数据元素（或记录）。若此关键字可以唯一地标识一个记录，则称此关键字为主关键字（对不同的记录，其主关键字均不同）。反之，称用以识别若干记录的关键字为次关键字。当数据元素只有一个数据项时，其关键字即该数据元素的值。

#### （3）查找
查找是指根据给定的某个值，在查找表中确定一个其关键字等于给定值的记录或数据元素。若表中存在这样的一个记录，则称查找成功，此时查找的结果可给出整个记录的信息，或者该记录在查找表中的位置；若表中不存在关键字等于给定值的记录，则称查找不成功，此时查找的结果可给出一个“空”记录或“空”指针。

#### （4）动态查找表和静态查找表
若在查找的同时对表格行修改操作（如插入和删除），则称相应的表为动态查找表，否则称之为静态查找表。换句话说，动态查找表的表结构本身是在查找过程中动态生成的，即在创建表时，对于给定值，若表中存在其关键字等于给定值的记录，则查找成功并返回；否则插入关键字等于给定值的记录。

#### （5）平均查找长度
为确定记录在查找表中的位置，需和给定值进行比较的关键字个数的期望值，称为查找算法在查找成功的平均查找长度（Average Search Length，ASL）。
对于含有 $ n $ 个记录的表，查找成功的平均查找长度为：
$ ASL = \sum_{i=1}^{n} P_i C_i $
其中，$ P_i $ 为查找表中第 $ i $ 个记录的概率，且 $ \sum_{i=1}^{n} P_i = 1 $，$ C_i $ 为找到表中其关键字与给定值相等的第 $ i $ 个记录时，和给定值已进行比较的关键字个数。显然，$ C_i $ 随查找过程的不同而不同。
由于查找算法的基本运算是关键字之间的比较操作，因此可用平均查找长度来衡量查找算法的性能。

### 7.2 线性表的查找

在查找表的组织方式中，线性表是最简单的一种。本节将介绍基于线性表的顺序查找、折半查找和分块查找。

#### 7.2.1 顺序查找

顺序查找（Sequential Search）的查找过程为：从表的一端开始，依次将记录的关键字和给定值进行比较，若某个记录的关键字和给定值相等，则查找成功；反之，若查找整个表后，仍未找到关键字和给定值相等的记录，则查找失败。

顺序查找方法既适用于线性表的顺序存储结构，又适用于线性表的链式存储结构。下面只介绍以顺序表作为存储结构时实现的顺序查找算法。

数据元素类型定义如下：
```c
typedef struct{
    KeyType key; // 关键字域
    InfoType otherinfo; // 其他域
} ElemType;
```
顺序表的定义同第2章：
```c
typedef struct{
    ElemType *R; // 存储空间基地址
    int length; // 当前长度
} SSTable;
```
在此定义下，顺序查找算法使与第2章的算法2.3一样。在此假设元素从 `ST.R[1]` 开始顺序向后存放，`ST.R[0]` 闲置不用，查找时从表的最后开始比较，如算法7.1所示。

**算法7.1 顺序查找**
```c
int Search_Seq(SSTable ST, KeyType key)
// 在顺序表ST中顺序查找其关键字等于key的数据元素。若找到，则函数值为该元素在表中的位置，否则为0
{
    for (i = ST.length; i >= 1; --i) // 顺序查找
        if (ST.R[i].key == key) return i;
    return 0;
}
```

算法7.1在查找过程中每步都要检测整个表是否查找完毕，即每步都要有循环变量是否满足条件 `i > 1` 的检测。改进这个程序，可以免去这个检测过程。

改进方法是查找之前先对 `ST.R[0]` 的关键字赋值 `key`，在此，`ST.R[0]` 起到了监视哨的作用，如算法7.2所示。

**算法7.2 设置监视哨的顺序查找**
```c
int Search_Seq(SSTable ST, KeyType key)
// 在顺序表ST中顺序查找其关键字等于key的数据元素。若找到，则函数值为该元素在表中的位置，否则为0
{
    ST.R[0].key = key; // “监视哨”
    for (i = ST.length; ST.R[i].key != key; --i); // 从后往前找
    return i;
}
```

**算法分析**

因此，算法7.2仅进行了程序设计技巧上的改进，即通过设置监视哨，免去查找过程中每一步都要检测整个表是否查找完毕。然而实践证明，这个改进能使顺序查找在 `ST.length ≥ 1000` 时，进行一次查找所需的平均时间几乎减少一半。当然，监视哨也可设在高下标处。

算法7.2和算法7.1的时间复杂度一样，在第2章已经进行分析，即：
$ ASL = \frac{1}{n} \sum_{i=1}^{n} i = \frac{n+1}{2} $

顺序查找的优点是：算法简单，对表结构无任何要求，既适用于顺序结构，也适用于链式结构，无论记录是否按关键字有序均可应用。其缺点是：平均查找长度较大，查找效率较低，所以当 $ n $ 很大时，不宜采用顺序查找。

### 7.2.2 折半查找

折半查找（Binary Search）也称二分查找，它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。在下面及后续的讨论中，均假设有序表是有序递增的。

折半查找的查找过程为：从表的中间记录开始，如果给定值和中间记录的关键字相等，则查找成功；如果给定值大于或者小于中间记录的关键字，则在表中大于或小于中间记录的那一半中查找，这样重复操作，直到查找成功，或者在某一步中查找区间为空，则代表查找失败。

折半查找每一次查找都使查找范围缩小一半，与顺序查找相比，很显然会提高查找效率。为了标记查找过程中每一次的查找区间，下面分别用 `low` 和 `high` 来表示当前查找区间的下界和上界，`mid` 为区间的中间位置。

**算法7.3 折半查找**
```c
int Search_Bin(SSTable ST, KeyType key)
// 在有序表ST中折半查找其关键字等于key的数据元素。若找到，则函数值为该元素在表中的位置，否则为0
{
    low = 1; high = ST.length; // 置查找区间初值
    while (low <= high) {
        mid = (low + high) / 2;
        if (key == ST.R[mid].key) return mid; // 找到待查元素
        else if (key < ST.R[mid].key) high = mid - 1; // 继续在前一子表进行查找
        else low = mid + 1; // 继续在后一子表进行查找
    }
    return 0; // 表中不存在待查元素
}
```

本算法很容易理解，唯一需要注意的是，循环执行的条件是 `low <= high`，而不是 `low < high`，因为 `low = high` 时，查找区间还有最后一个节点，还要进一步比较。

算法7.3很容易改写成递归程序，递归函数的参数除了 `ST` 和 `key` 之外，还需要加上 `low` 和 `high`，请读者自行实现折半查找的递归算法。

**例7.1** 已知如下包含11个数据元素的有序表（关键字即数据元素的值）：
$ (5, 16, 20, 27, 30, 36, 44, 55, 60, 67, 71) $
请给出查找关键字为27和65的数据元素的折半查找过程。

假设指针 `low` 和 `high` 分别指示待查元素所在范围的下界和上界，指针 `mid` 指示区间的中间位置，即 `mid = \left\lfloor \frac{low + high}{2} \right\rfloor`。在此例中，`low` 和 `high` 的初值分别为1和11，即 `[1, 11]` 为待查范围，`mid` 初值为6。

查找关键字 `key = 27` 的折半查找过程如图7.1（a）所示。

首先令给定值 `key = 27` 与中间位置的数据元素的关键字 `ST.R[mid].key` 相比较，因为 `36 > 27`，说明待查元素存在，必在区间 `[low, mid - 1]` 内，则令指针 `high` 指向第 `mid - 1` 个元素，`high = 5`，重新求得 `mid = \left\lfloor \frac{1 + 5}{2} \right\rfloor = 3`。

然后仍令 `key` 和 `ST.R[mid].key` 相比较，因为 `20 < 27`，说明待查元素存在，必在区间 `[mid + 1, high]` 内，则令指针 `low` 指向第 `mid + 1` 个元素，`low = 4`，求得 `mid` 的新值为4，比较 `key` 和 `ST.R[mid].key`，因为相等，则查找成功，返回所查元素在表中的序号，即指针 `mid` 的值4。

查找关键字 `key = 65` 的折半查找过程如图7.1（b）所示。

查找过程同上，只是在图7.1（b）中的最后一趟查找时，因为 `low > high`，查找区间不存在，则说明表中没有关键字等于65的元素，查找失败，返回0。

**算法分析**

折半查找过程可用二叉树来描述。树中每一节点对应其中一个记录，但节点值不是记录的关键字，而是记录在表中的位置序号。把当前查找区间的中间位置作为根，把左子表和右子表分列作为根的左子树和右子树，由此得到的二叉树称为折半查找的决策树。

例7.1中的有序表对应的决策树如图7.2所示。从决策树上可见，成功的折半查找恰好是走了一条从决策树的根到被查节点的路径，经历比较的关键字个数恰为该节点在树中的层次。例如，查找27的过程经过一条从根到节点的路径，需要比较3次，比较次数即节点4所在的层次。

图7.2中比较1次的只有一个根节点，比较2次的有两个节点，比较3次和4次的各有4个节点。假设每个记录的查找概率相同，根据此决策树可知，对长度为11的有序表进行折半查找的平均查找长度为：
$ ASL = \frac{1}{11} (1 + 2 \times 2 + 3 \times 4 + 4 \times 4) = 3 $

由此可见，折半查找法在查找成功时进行比较的关键字个数最多不超过树的深度。而决策树的形态只与表记录个数 $ n $ 相关，与关键字的取值无关，具有 $ n $ 个节点的决策树的深度为 $ \log_2 n + 1 $。所以，对于长度为 $ n $ 的有序表，折半查找法在查找成功时和给定值进行比较的关键字个数至多为 $ \log_2 n + 1 $。

如果在图7.2所示的决策树中所有节点的空指针域上加一个指向一个方形节点的指针，如图7.3所示，并且称这些方形节点为决策树的外部节点（与之相对，称那些圆形节点为内部节点），那么折半查找时查找失败的过程就是走了一条从根节点到外部节点的路径，和给定值进行比较的关键字个数等于该路径上的内部分节点个数。例如，查找65的过程中把一条从根到节点9~10的路径。因此，折半查找在查找不成功时和给定值进行比较的关键字个数最多也不超过 $ \log_2 n + 1 $。

借助于决策树，很容易求得折半查找的平均查找长度。为讨论方便起见，假定有序表的长度 $ n = 2^k - 1 $，则决策树是深度为 $ h = \log_2 (n + 1) $ 的满二叉树。树中层次为1的节点有1个，层次为2的节点有2个，依次类推，层次为 $ k $ 的节点有 $ 2^{k-1} $ 个。假设表中每个记录的查找概率相等 $ \left( P_i = \frac{1}{n} \right) $，则查找成功时折半查找的平均查找长度为：
$ ASL = \sum_{i=1}^{n} P_i C_i = \frac{1}{n} \sum_{j=1}^{k} j \cdot 2^{j-1} = \frac{n+1}{n} \log_2 (n+1) - 1 $

当 $ n $ 较大时，可有下列近似结果：
$ ASL \approx \log_2 (n+1) - 1 $

因此，折半查找的时间复杂度为 $ O(\log_2 n) $。可见，折半查找的效率比顺序查找的高，但折半查找只适用于有序表，且限于顺序存储结构。

折半查找的优点是：比较次数少，查找效率高。其缺点是：对表格要求高，只能用于顺序存储的有序表。采用折半查找前元素需要排序，而排序本身是一种费时的运算。同时为了保持顺序表的有序性，对有序表进行插入和删除时，平均比较和移动表中一半元素，这也是一种费时的运算。因此，折半查找不适用于数据元素经常变动的线性表。

### 7.2.3 分块查找

分块查找（Blocking Search）又称索引顺序查找，这是一种性能介于顺序查找和折半查找之间的查找方法。在此查找方法中，除表本身以外，尚需建立一个“索引表”。例如，图7.4所示为一个表及其索引表，表中含有18个记录，可分成3个子表 $(R_1, R_2, \cdots, R_6)$、$(R_7, R_8, \cdots, R_{12})$、$(R_{13}, R_{14}, \cdots, R_{18})$，对每个子表（或称块）建立一个索引项，其中包括两项内容：关键字项（其值为该子表内的最大关键字）和指针项（指示该子表的第一个记录在表中的位置）。索引表按关键字有序，则表有序或者分块有序。所谓“分块有序”指的是第二个子表中所有记录的关键字均大于第一个子表中的最大关键字，第三个子表中的所有关键字均大于第二个子表中的最大关键字，依次类推。

$\begin{array}{cccccccccccc}
\text{表} & 21 & 22 & 23 & 24 & 25 & 26 & 27 & 28 & 29 & 30 \\
\hline
\text{最大关键字} & 22 & 48 & 86 & 71 & 73 & 74 & 75 & 76 & 77 & 78 & 79 \\
\end{array}$

$\begin{array}{cccccccccccc}
\text{索引表} & 21 & 22 & 23 & 24 & 25 & 26 & 27 & 28 & 29 & 30 \\
\hline
\text{起始地址} & 1 & 7 & 13 & 6 & 5 & 8 & 9 & 10 & 11 & 12 & 13 \\
\end{array}$

因此，分块查找过程需分两步进行。先确定待查记录所在的块（子表），然后在其中顺序查找。假设给定值 $ key = 38 $，则先将 $ key $ 依次和索引表中各分块的最大关键字进行比较，因为 $ 22 < key < 48 $，则关键字为38的记录存在，必定在第二个子表中。由于同一索引项中的指针指示第二个子表中的第一个记录是表中第7个记录，则自第7个记录起进行顺序查找，直到 `ST.R[10].key = key` 为止。假如此子表中没有关键字等于 $ key $ 的记录（例如，$ key = 29 $ 时自第7个记录起至第12个记录的关键字和 $ key $ 都不等），则查找不成功。

由于由索引项组成的索引表按关键字有序，则确定块的查找可以用顺序查找，亦可用折半查找，而块中记录是在整排列的，则在块中只能用顺序查找。

由此，分块查找的算法为顺序查找和折半查找两种算法的简单合成。分块查找的平均查找长度为：
$ ASL_{x} = L_{x} + L_{y} $
其中，$ L_{x} $ 为查找索引表确定所在块的平均查找长度，$ L_{y} $ 为在块中查找元素的平均查找长度。

一般情况下，为进行分块查找，可以将长度为 $ n $ 的表均匀地分成 $ b $ 块，每块含有 $ s $ 个记录，即 $ b = \left\lceil \frac{n}{s} \right\rceil $；又假定表中每个记录的查找概率相等，则每块查找的概率为 $ \frac{1}{b} $，块中每个记录的查找概率为 $ \frac{1}{s} $。

若用顺序查找确定所在块，则分块查找的平均查找长度为：
$ ASL_{x} = L_{x} + L_{y} = \frac{1}{b} \sum_{j=1}^{b} j + \frac{1}{s} \sum_{i=1}^{s} i = \frac{b+1}{2} + \frac{s+1}{2} = \frac{1}{2} \left( \frac{n}{s} + s \right) + 1 $

可见，此时的平均查找长度不仅和表长 $ n $ 有关，而且和每一块中的记录个数 $ s $ 有关。在给定 $ n $ 的前提下，$ s $ 是可以选择的。容易证明，当取 $ s = \sqrt{n} $ 时，$ ASL_{x} $ 取最小值 $ \sqrt{n} + 1 $。结果表明，分块查找比顺序查找有了很大改进，但远不及折半查找。

若用折半查找确定所在块，则分块查找的平均查找长度为：
$ ASL_{x} \approx \log_2 \left( \frac{n}{s} + 1 \right) + \frac{s}{2} $

分块查找的优点是：在表中插入和删除数据元素时，只要找到该元素对应的块，就可以在该块内进行插入和删除运算。由于块内是无序的，故插入和删除比较容易，无须进行大量移动。如果线性表既经常动态变化，又需对其进行快速查找，则可采用分块查找。其缺点是：要增加一个索引表的存储空间并对初始索引表进行排序运算。
