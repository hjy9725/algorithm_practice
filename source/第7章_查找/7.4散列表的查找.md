### 7.4 散列表的查找

#### 7.4.1 散列表的基本概念

在前面的讨论中，我们探讨了基于线性表和树表结构的查找方法。这些方法都是以关键字的比较为基础的。在查找过程中，我们只考虑各元素关键字之间的相对大小，记录在存储结构中的位置与其关键字没有直接关系。因此，查找时间与表的长度有关，特别是当节点个数很多时，查找时需要大量地与无效节点的关键字进行比较，导致查找速度很慢。

如果能在元素的存储位置和其关键字之间建立某种直接关系，那么在进行查找时，就无需进行比较或只需进行很少的比较，按照这种关系直接由关键字找到相应的记录。这就是散列表查找法（Hash Search）的思想。散列表查找法通过对元素的关键字值进行某种运算，直接求出元素的地址，即使用关键字到地址的直接转换方法，而不需要反复比较。因此，散列表查找法又叫杂凑法或散列法。

下面给出散列法中常用的几个术语：

1. **散列函数和散列地址**：在记录的存储位置和其关键字 \( key \) 之间建立一个确定的对应关系 \( H \)，使 \( p = H(key) \)，称这个对应关系为散列函数，\( p \) 为散列地址。
2. **散列表**：一个有限连续的地址空间，用以存储散列函数计算得到相应散列地址的数据记录。通常散列表的存储空间是一个一维数组，散列地址是数组的下标。
3. **冲突和同义词**：对不同的关键字可能得到同一散列地址，即 \( key_1 \neq key_2 \)，而 \( H(key_1) = H(key_2) \)，这种现象称为冲突。具有相同函数值的关键字对该散列函数来说称作同义词，\( key_1 \) 和 \( key_2 \) 互为同义词。

例如，对C语言某些关键字集合建立一个散列表，关键字集合为：
\[ S_i = \{main, int, float, while, return, break, switch, case, do\} \]
设定一个长度为26的散列表应该足够，散列表可定义为：
\[ char HT[26][8]; \]
假设散列函数的值取为关键字 \( key \) 中第一个字母在字母表 \( \{a, b, \cdots, z\} \) 中的序号（序号范围为0~25），即：
\[ H(key) = key[0] - 'a' \]
其中，设 \( key \) 的类型是长度为8的字符数组，根据此散列函数构造的散列表如表7.1所示。

| 0  | 1  | 2  | 3  | 4  | 5  | …  | s  | …  | D  | …  | Dplal | …  | 22 | …  | 25 |
|----|----|----|----|----|----|----|----|----|----|----|-------|----|----|----|----|
| break | case | do | float | int | main | __ | return | switch | while |

假设关键字集合扩充为：
\[ S_i + \{short, default, double, static, for, struct\} \]

如果散列函数不变，新加入的7个关键字经过计算得到：
\[ H(short) = H(static) = H(struct) = 18 \]
\[ H(default) = H(double) = 3 \]
\[ H(for) = 5 \]

而18、3和5这几个位置均已存放相应的关键字，这就发生了冲突。其中，`switch`、`short`、`static` 和 `struct` 称为同义词；`do`、`default` 和 `double` 称为同义词；`float` 和 `for` 称为同义词。

集合 \( S \) 中的关键字仅有15个，仔细分析这15个关键字的特性，应该不难构造一个散列函数以避免冲突。但在实际应用中，理想化的、不产生冲突的散列函数极少存在，这是因为通常散列表中关键字的取值集合远远大于表空间的地址集。例如，高级语言的编译程序要对源程序中的标识符建立一张符号表进行管理，多数都采取散列表。在设定散列函数时，考虑的查找关键字集合应包含所有可能产生的关键字，不同的源程序中使用的标识符一般也不相同。如果此语言规定标识符为长度不超过8的、字母开头的由字母和数字组成的串，字母区分大小写，则标识符取值集合的大小为：
\[ 52 \times 62^7 \approx 1.09 \times 10^{14} \]

而一个源程序中出现的标识符是有限的，所以编译程序将散列表的长度设为1000足矣。于是，要将多达 \( 10^{14} \) 个可能的标识符映射到有限的地址上，难免产生冲突。通常，散列函数是一个多对一的映射，所以冲突是不可避免的，只能通过选择一个“好”的散列函数使得在一定程度上减少冲突。而一旦发生冲突，就必须采取相应措施及时予以解决。

综上所述，散列查找法主要研究以下两方面的问题：

1. 如何构造散列函数；
2. 如何处理冲突。

### 扩展讲解

#### 散列函数的设计

散列函数的设计是散列表查找法的核心。一个好的散列函数应该满足以下几个条件：

1. **均匀性**：散列函数应尽量均匀地将关键字映射到散列表的各个地址上，以减少冲突的发生。
2. **简单性**：散列函数应尽可能简单，以便快速计算。
3. **高效性**：散列函数应能在常数时间内完成计算，以保证查找效率。

常见的散列函数设计方法包括：

1. **除留余数法**：将关键字 \( key \) 除以某个数 \( m \) 后取余数，即 \( H(key) = key \% m \)。通常选择 \( m \) 为质数，以减少冲突。
2. **平方取中法**：将关键字平方后取中间几位作为散列地址。
3. **折叠法**：将关键字分割成位数相同的几部分，然后取这几部分的叠加和作为散列地址。

#### 冲突处理方法

即使设计了好的散列函数，冲突仍然是不可避免的。因此，需要有相应的冲突处理方法：

1. **开放地址法**：当发生冲突时，通过某种探测方法在散列表中寻找下一个空闲位置。常见的探测方法有：
   - **线性探测法**：从冲突位置开始，依次检查下一个位置，直到找到空闲位置。
   - **二次探测法**：从冲突位置开始，依次检查 \( 1^2, -1^2, 2^2, -2^2, \ldots \) 位置。
   - **双重散列法**：使用第二个散列函数计算探测步长。

2. **链地址法**：将所有同义词存储在同一个链表中，散列表中的每个位置存储一个链表的头指针。

3. **再散列法**：当散列表的装填因子达到一定阈值时，重新构造一个更大的散列表，并将所有元素重新散列到新表中。

### 选择题

1. **散列表查找法又叫什么？**
   - A. 线性查找法
   - B. 二分查找法
   - C. 杂凑法或散列法
   - D. 树查找法
   - **答案：C**
   - **解释**：散列表查找法通过对元素的关键字值进行某种运算，直接求出元素的地址，即使用关键字到地址的直接转换方法，而不需要反复比较。因此，散列表查找法又叫杂凑法或散列法。

2. **散列函数的作用是什么？**
   - A. 将关键字转换为存储地址
   - B. 比较关键字的大小
   - C. 排序关键字
   - D. 删除关键字
   - **答案：A**
   - **解释**：散列函数在记录的存储位置和其关键字之间建立一个确定的对应关系，使 \( p = H(key) \)，称这个对应关系为散列函数，\( p \) 为散列地址。

3. **以下哪种情况会导致冲突？**
   - A. \( key_1 = key_2 \)
   - B. \( H(key_1) \neq H(key_2) \)
   - C. \( key_1 \neq key_2 \) 且 \( H(key_1) = H(key_2) \)
   - D. \( key_1 = key_2 \) 且 \( H(key_1) \neq H(key_2) \)
   - **答案：C**
   - **解释**：对不同的关键字可能得到同一散列地址，即 \( key_1 \neq key_2 \)，而 \( H(key_1) = H(key_2) \)，这种现象称为冲突。

4. **散列表的存储空间通常是什么形式？**
   - A. 链表
   - B. 树
   - C. 一维数组
   - D. 二维数组
   - **答案：C**
   - **解释**：通常散列表的存储空间是一个一维数组，散列地址是数组的下标。

5. **以下哪种方法不是处理冲突的方法？**
   - A. 线性探测法
   - B. 二次探测法
   - C. 双重散列法
   - D. 二分查找法
   - **答案：D**
   - **解释**：二分查找法是一种基于比较的查找方法，不是处理冲突的方法。

6. **除留余数法中，通常选择 \( m \) 为质数的原因是什么？**
   - A. 减少冲突
   - B. 增加计算速度
   - C. 简化计算
   - D. 提高存储效率
   - **答案：A**
   - **解释**：选择 \( m \) 为质数可以减少冲突的发生，因为质数与其他数的公因数较少，使得关键字分布更均匀。

7. **平方取中法的主要思想是什么？**
   - A. 将关键字平方后取中间几位作为散列地址
   - B. 将关键字除以某个数后取余数
   - C. 将关键字分割成位数相同的几部分，然后取这几部分的叠加和
   - D. 使用第二个散列函数计算探测步长
   - **答案：A**
   - **解释**：平方取中法将关键字平方后取中间几位作为散列地址。

8. **链地址法的主要思想是什么？**
   - A. 将所有同义词存储在同一个链表中
   - B. 从冲突位置开始，依次检查下一个位置，直到找到空闲位置
   - C. 使用第二个散列函数计算探测步长
   - D. 当散列表的装填因子达到一定阈值时，重新构造一个更大的散列表
   - **答案：A**
   - **解释**：链地址法将所有同义词存储在同一个链表中，散列表中的每个位置存储一个链表的头指针。

9. **再散列法的主要思想是什么？**
   - A. 将所有同义词存储在同一个链表中
   - B. 从冲突位置开始，依次检查下一个位置，直到找到空闲位置
   - C. 使用第二个散列函数计算探测步长
   - D. 当散列表的装填因子达到一定阈值时，重新构造一个更大的散列表
   - **答案：D**
   - **解释**：再散列法当散列表的装填因子达到一定阈值时，重新构造一个更大的散列表，并将所有元素重新散列到新表中。

10. **以下哪种方法不是探测方法？**
    - A. 线性探测法
    - B. 二次探测法
    - C. 双重散列法
    - D. 二分查找法
    - **答案：D**
    - **解释**：二分查找法是一种基于比较的查找方法，不是探测方法。

11. **散列函数的设计应满足哪些条件？**
    - A. 均匀性、简单性、高效性
    - B. 均匀性、复杂性、高效性
    - C. 均匀性、简单性、低效性
    - D. 复杂性、简单性、高效性
    - **答案：A**
    - **解释**：一个好的散列函数应该满足均匀性、简单性和高效性。

12. **以下哪种方法不是散列函数的设计方法？**
    - A. 除留余数法
    - B. 平方取中法
    - C. 折叠法
    - D. 二分查找法
    - **答案：D**
    - **解释**：二分查找法是一种基于比较的查找方法，不是散列函数的设计方法。

13. **散列表中的冲突是指什么？**
    - A. 不同的关键字得到不同的散列地址
    - B. 相同的关键字得到不同的散列地址
    - C. 不同的关键字得到相同的散列地址
    - D. 相同的关键字得到相同的散列地址
    - **答案：C**
    - **解释**：对不同的关键字可能得到同一散列地址，即 \( key_1 \neq key_2 \)，而 \( H(key_1) = H(key_2) \)，这种现象称为冲突。

14. **以下哪种方法不是处理冲突的方法？**
    - A. 线性探测法
    - B. 二次探测法
    - C. 双重散列法
    - D. 二分查找法
    - **答案：D**
    - **解释**：二分查找法是一种基于比较的查找方法，不是处理冲突的方法。

15. **散列表的装填因子是指什么？**
    - A. 散列表中元素的个数
    - B. 散列表的长度
    - C. 散列表中元素的个数与散列表长度的比值
    - D. 散列表中空闲位置的个数
    - **答案：C**
    - **解释**：散列表的装填因子是指散列表中元素的个数与散列表长度的比值。

16. **以下哪种方法不是探测方法？**
    - A. 线性探测法
    - B. 二次探测法
    - C. 双重散列法
    - D. 二分查找法
    - **答案：D**
    - **解释**：二分查找法是一种基于比较的查找方法，不是探测方法。

17. **散列函数的设计应满足哪些条件？**
    - A. 均匀性、简单性、高效性
    - B. 均匀性、复杂性、高效性
    - C. 均匀性、简单性、低效性
    - D. 复杂性、简单性、高效性
    - **答案：A**
    - **解释**：一个好的散列函数应该满足均匀性、简单性和高效性。

18. **以下哪种方法不是散列函数的设计方法？**
    - A. 除留余数法
    - B. 平方取中法
    - C. 折叠法
    - D. 二分查找法
    - **答案：D**
    - **解释**：二分查找法是一种基于比较的查找方法，不是散列函数的设计方法。

19. **散列表中的冲突是指什么？**
    - A. 不同的关键字得到不同的散列地址
    - B. 相同的关键字得到不同的散列地址
    - C. 不同的关键字得到相同的散列地址
    - D. 相同的关键字得到相同的散列地址
    - **答案：C**
    - **解释**：对不同的关键字可能得到同一散列地址，即 \( key_1 \neq key_2 \)，而 \( H(key_1) = H(key_2) \)，这种现象称为冲突。

20. **以下哪种方法不是处理冲突的方法？**
    - A. 线性探测法
    - B. 二次探测法
    - C. 双重散列法
    - D. 二分查找法
    - **答案：D**
    - **解释**：二分查找法是一种基于比较的查找方法，不是处理冲突的方法。

### 7.4.2 散列函数的构造方法

构造散列函数的方法很多，一般来说，应根据具体问题选用不同的散列函数，通常要考虑以下因素：

1. 散列表的长度；
2. 关键字的长度；
3. 关键字的分布情况；
4. 计算散列函数所需的时间；
5. 记录的查找频率。

构造一个“好”的散列函数应遵循以下两条原则：

1. 函数计算要简单，每一关键字只能有一个散列地址与之对应；
2. 函数的值域需在表长的范围内，计算出的散列地址的分布应均匀，尽可能减少冲突。

下面介绍构造散列函数的几种常用方法。

#### 1. 数字分析法

如果事先知道关键字集合，且每个关键字的位数比散列表的地址码位数多，每个关键字由 \( n \) 位数组成，如 \( k_1 k_2 \ldots k_n \)，则可以从关键字中提取数字分布比较均匀的若干位作为散列地址。

例如，有80个记录，其关键字为8位十进制数。假设散列表的表长为100，则可取两位十进制数组成散列地址，选取的原则是分析这80个关键字，使得到的散列地址尽量避免产生冲突。假设这80个关键字中的一部分如下所列：

\[
\begin{array}{cccccccc}
8 & 1 & 3 & 4 & 6 & 5 & 3 & 2 \\
8 & 1 & 3 & 7 & 2 & 2 & 4 & 2 \\
8 & 1 & 3 & 8 & 7 & 4 & 2 & 2 \\
8 & 1 & 3 & 0 & 1 & 3 & 6 & 7 \\
8 & 1 & 3 & 2 & 2 & 8 & 1 & 7 \\
8 & 1 & 3 & 3 & 8 & 9 & 6 & 7 \\
8 & 1 & 3 & 5 & 4 & 1 & 5 & 7 \\
8 & 1 & 3 & 6 & 8 & 5 & 3 & 7 \\
8 & 1 & 4 & 1 & 9 & 3 & 5 & 5 \\
\end{array}
\]

从对关键字全体的分析中可以发现：第①、②位都是“8 1”，第③位只可能取3或4，第⑧位可能取2、5或7，因此这4位都不可取。由于中间的4位可看成近乎随机的，因此可取其中任意两位，或取其中两位与另外两位叠加求和后舍去进位作为散列地址。

数字分析法的适用情况：事先必须明确知道所有的关键字每一位上各种数字的分布情况。

在实际应用中，例如，同一出版社出版的所有图书，其ISBN的前几位都是相同的，因此，若数据表只包含同一出版社的图书，构造散列函数时可以利用数字分析法排除ISBN的前几位数字。

#### 2. 平方取中法

通常在选定散列函数时不一定能知道关键字的全部情况，取其中某几位也不一定合适，而一个数字平方后的中间几位数和数的每一位都相关，如果取关键字平方后的中间几位或其组合作为散列地址，则使随机分布的关键字得到的散列地址也是随机的，具体所取的位数由表长决定。平方取中法是一种较常用的构造散列函数的方法。

例如，为源程序中的标识符建立一个散列表，假设标识符为字母开头的字符串和数字组成的串。假设人为约定每个标识的内部编码规则如下：把字母在字母表中的位置序号作为该字母的内部编码，如A的内部编码为09，D的内部编码为04，A的内部编码为01。数字直接用其自身作为内部编码，如1的内部编码为01，2的内部编码为02。根据以上编码规则，可知“IDA1”的内部编码为09040101，同理可以得到“IDB2”“XID3”和“YID4”的内部编码。之后分别对内部编码进行平方运算，再取出第7位到第9位作为其相应标识符的散列地址，如表7.2所示。

| 标识符 | 内部编码 | 内部编码的平方 | 散列地址 |
|--------|----------|----------------|----------|
| IDA1   | 09040101 | 08172342609201 | 426      |
| IDB2   | 09040202 | 081725252200804 | 252      |
| XID3   | 24090403 | 580347516702409 | 516      |
| YID4   | 25090404 | 629528372883216 | 372      |

平方取中法的适用情况：不能事先了解关键字的所有情况，或难于直接从关键字中找到取值较分散的几位。

### 扩展讲解

#### 散列函数的构造方法

散列函数的构造方法有很多，选择合适的方法需要考虑多个因素，包括散列表的长度、关键字的长度、关键字的分布情况、计算散列函数所需的时间以及记录的查找频率。一个好的散列函数应满足以下两个原则：

1. **计算简单**：散列函数的计算应尽可能简单，每个关键字只能有一个散列地址与之对应。
2. **均匀分布**：散列函数的值域应在表长的范围内，计算出的散列地址应均匀分布，以减少冲突。

下面详细介绍几种常用的散列函数构造方法。

#### 1. 数字分析法

数字分析法适用于事先知道关键字集合的情况。如果每个关键字的位数比散列表的地址码位数多，可以从关键字中提取数字分布比较均匀的若干位作为散列地址。

**步骤**：
1. 分析关键字集合，找出数字分布比较均匀的若干位。
2. 提取这些位作为散列地址。

**示例**：
假设有80个记录，其关键字为8位十进制数。散列表的表长为100，则可取两位十进制数组成散列地址。通过分析关键字，发现某些位分布较均匀，可以提取这些位作为散列地址。

**适用情况**：
- 事先必须明确知道所有的关键字每一位上各种数字的分布情况。

#### 2. 平方取中法

平方取中法适用于不能事先了解关键字全部情况的情况。通过取关键字平方后的中间几位作为散列地址，可以使随机分布的关键字得到的散列地址也是随机的。

**步骤**：
1. 对关键字进行平方运算。
2. 取平方结果的中间几位作为散列地址。

**示例**：
假设标识符为字母开头的字符串和数字组成的串。根据内部编码规则，对内部编码进行平方运算，再取出第7位到第9位作为散列地址。

**适用情况**：
- 不能事先了解关键字的所有情况，或难于直接从关键字中找到取值较分散的几位。

### 选择题

1. **散列函数的设计应考虑哪些因素？**
   - A. 散列表的长度、关键字的长度、关键字的分布情况、计算散列函数所需的时间、记录的查找频率
   - B. 散列表的长度、关键字的长度、关键字的分布情况、计算散列函数所需的时间
   - C. 散列表的长度、关键字的长度、关键字的分布情况
   - D. 散列表的长度、关键字的长度
   - **答案：A**
   - **解释**：散列函数的设计应考虑散列表的长度、关键字的长度、关键字的分布情况、计算散列函数所需的时间以及记录的查找频率。

2. **一个好的散列函数应满足哪些原则？**
   - A. 计算简单、均匀分布
   - B. 计算复杂、均匀分布
   - C. 计算简单、不均匀分布
   - D. 计算复杂、不均匀分布
   - **答案：A**
   - **解释**：一个好的散列函数应满足计算简单和均匀分布的原则。

3. **数字分析法适用于什么情况？**
   - A. 事先知道关键字集合
   - B. 事先不知道关键字集合
   - C. 关键字位数少于散列表地址码位数
   - D. 关键字位数多于散列表地址码位数
   - **答案：A**
   - **解释**：数字分析法适用于事先知道关键字集合的情况。

4. **平方取中法的步骤是什么？**
   - A. 对关键字进行平方运算，取平方结果的中间几位作为散列地址
   - B. 对关键字进行平方运算，取平方结果的前几位作为散列地址
   - C. 对关键字进行平方运算，取平方结果的后几位作为散列地址
   - D. 对关键字进行平方运算，取平方结果的所有位作为散列地址
   - **答案：A**
   - **解释**：平方取中法的步骤是对关键字进行平方运算，取平方结果的中间几位作为散列地址。

5. **以下哪种方法不是散列函数的设计方法？**
   - A. 数字分析法
   - B. 平方取中法
   - C. 线性探测法
   - D. 折叠法
   - **答案：C**
   - **解释**：线性探测法是处理冲突的方法，不是散列函数的设计方法。

6. **散列表的长度对散列函数的设计有什么影响？**
   - A. 直接影响散列函数的值域
   - B. 不影响散列函数的值域
   - C. 直接影响关键字的分布情况
   - D. 不影响关键字的分布情况
   - **答案：A**
   - **解释**：散列表的长度直接影响散列函数的值域。

7. **关键字的长度对散列函数的设计有什么影响？**
   - A. 直接影响散列函数的计算复杂度
   - B. 不影响散列函数的计算复杂度
   - C. 直接影响散列函数的值域
   - D. 不影响散列函数的值域
   - **答案：A**
   - **解释**：关键字的长度直接影响散列函数的计算复杂度。

8. **关键字的分布情况对散列函数的设计有什么影响？**
   - A. 直接影响散列地址的均匀分布
   - B. 不影响散列地址的均匀分布
   - C. 直接影响散列函数的计算复杂度
   - D. 不影响散列函数的计算复杂度
   - **答案：A**
   - **解释**：关键字的分布情况直接影响散列地址的均匀分布。

9. **计算散列函数所需的时间对散列函数的设计有什么影响？**
   - A. 直接影响查找效率
   - B. 不影响查找效率
   - C. 直接影响散列地址的均匀分布
   - D. 不影响散列地址的均匀分布
   - **答案：A**
   - **解释**：计算散列函数所需的时间直接影响查找效率。

10. **记录的查找频率对散列函数的设计有什么影响？**
    - A. 直接影响散列函数的优化方向
    - B. 不影响散列函数的优化方向
    - C. 直接影响散列地址的均匀分布
    - D. 不影响散列地址的均匀分布
    - **答案：A**
    - **解释**：记录的查找频率直接影响散列函数的优化方向。

11. **数字分析法的步骤是什么？**
    - A. 分析关键字集合，提取数字分布比较均匀的若干位作为散列地址
    - B. 对关键字进行平方运算，取平方结果的中间几位作为散列地址
    - C. 对关键字进行平方运算，取平方结果的前几位作为散列地址
    - D. 对关键字进行平方运算，取平方结果的后几位作为散列地址
    - **答案：A**
    - **解释**：数字分析法的步骤是分析关键字集合，提取数字分布比较均匀的若干位作为散列地址。

12. **平方取中法的适用情况是什么？**
    - A. 不能事先了解关键字的所有情况，或难于直接从关键字中找到取值较分散的几位
    - B. 事先知道关键字集合
    - C. 关键字位数少于散列表地址码位数
    - D. 关键字位数多于散列表地址码位数
    - **答案：A**
    - **解释**：平方取中法的适用情况是不能事先了解关键字的所有情况，或难于直接从关键字中找到取值较分散的几位。

13. **以下哪种方法不是散列函数的设计方法？**
    - A. 数字分析法
    - B. 平方取中法
    - C. 双重散列法
    - D. 折叠法
    - **答案：C**
    - **解释**：双重散列法是处理冲突的方法，不是散列函数的设计方法。

14. **散列表的长度对散列函数的值域有什么影响？**
    - A. 直接影响
    - B. 不影响
    - C. 间接影响
    - D. 有时影响
    - **答案：A**
    - **解释**：散列表的长度直接影响散列函数的值域。

15. **关键字的长度对散列函数的计算复杂度有什么影响？**
    - A. 直接影响
    - B. 不影响
    - C. 间接影响
    - D. 有时影响
    - **答案：A**
    - **解释**：关键字的长度直接影响散列函数的计算复杂度。

16. **关键字的分布情况对散列地址的均匀分布有什么影响？**
    - A. 直接影响
    - B. 不影响
    - C. 间接影响
    - D. 有时影响
    - **答案：A**
    - **解释**：关键字的分布情况直接影响散列地址的均匀分布。

17. **计算散列函数所需的时间对查找效率有什么影响？**
    - A. 直接影响
    - B. 不影响
    - C. 间接影响
    - D. 有时影响
    - **答案：A**
    - **解释**：计算散列函数所需的时间直接影响查找效率。

18. **记录的查找频率对散列函数的优化方向有什么影响？**
    - A. 直接影响
    - B. 不影响
    - C. 间接影响
    - D. 有时影响
    - **答案：A**
    - **解释**：记录的查找频率直接影响散列函数的优化方向。

19. **数字分析法的适用情况是什么？**
    - A. 事先必须明确知道所有的关键字每一位上各种数字的分布情况
    - B. 不能事先了解关键字的所有情况
    - C. 关键字位数少于散列表地址码位数
    - D. 关键字位数多于散列表地址码位数
    - **答案：A**
    - **解释**：数字分析法的适用情况是事先必须明确知道所有的关键字每一位上各种数字的分布情况。

20. **平方取中法的步骤是什么？**
    - A. 对关键字进行平方运算，取平方结果的中间几位作为散列地址
    - B. 对关键字进行平方运算，取平方结果的前几位作为散列地址
    - C. 对关键字进行平方运算，取平方结果的后几位作为散列地址
    - D. 对关键字进行平方运算，取平方结果的所有位作为散列地址
    - **答案：A**
    - **解释**：平方取中法的步骤是对关键字进行平方运算，取平方结果的中间几位作为散列地址。

### 3. 折叠法

将关键字分割成位数相同的几部分（最后一部分的位数可以不同），然后取这几部分的叠加和（舍去进位）作为散列地址，这种方法称为折叠法。根据数位叠加的方式，可以把折叠法分为移位叠加和边界叠加两种。移位叠加是将分割后每一部分的最低位对齐，然后相加；边界叠加是将两个相邻的部分沿边界来回折叠，然后对齐相加。

例如，当散列表长为1000时，关键字 \( key = 45387765213 \)，从左到右每3位分为一组，可以得到4个部分：\( 453, 877, 652, 13 \)。分别采用移位叠加和边界叠加，求得散列地址为995和914，如图7.28所示。

折叠法的适用情况：适合于散列地址的位数较少，而关键字的位数较多，且难于直接从关键字中找到取值较分散的几位。

\[
\begin{array}{ccc}
 & 453 & 453 \\
\hline
857 & 778 \\
652 & 652 \\
13 & + & 31 \\
\end{array}
\]

\[
[1995] \quad [1]914
\]

\[
H(key) = 995 \quad H(key) = 914
\]

(a) 移位叠加 \quad (b) 边界叠加

图7.28 由折叠法求得散列地址

### 4. 除留余数法

假设散列表表长为 \( m \)，选择一个不大于 \( m \) 的数 \( p \)，用 \( p \) 去除关键字，除后所得余数为散列地址，即：

\[ H(key) = key\%p \]

这个方法的关键是选取适当的 \( p \)，一般情况下，可以选为小于表长的最大质数。例如，表长 \( m = 100 \)，可取 \( p = 97 \)。

除留余数法计算简单，适用范围非常广，是最常用的构造散列函数的方法。它不仅可以对关键字直接取模，也可在折叠、平方取中等运算之后取模，这样能够保证散列地址一定落在散列表的地址空间中。

### 7.4.3 处理冲突的方法

选择一个“好”的散列函数可以在一定程度上减少冲突，但在实际应用中，很难完全避免发生冲突，所以选择一个有效的处理冲突的方法是散列法的另一个关键。创建散列表和查找散列表都会遇到冲突，两种情况下处理冲突的方法应该一致。下面以创建散列表为例，来说明处理冲突的方法。

处理冲突的方法与散列表本身的组织形式有关。按组织形式的不同，处理冲突的方法通常分两大类：开放地址法和链地址法。

#### 1. 开放地址法

开放地址法的基本思想是：把记录存储在散列表数组中，当某一记录关键字 \( key \) 的初始散列地址 \( H_0 = H(key) \) 发生冲突时，以 \( H_0 \) 为基础，采取合适方法计算得到另一个地址 \( H_1 \)，如果 \( H_1 \) 仍然发生冲突，以 \( H_1 \) 为基础再求下一个地址 \( H_2 \)，若 \( H_2 \) 仍然冲突，再求得 \( H_3 \)。依次类推，直至 \( H_2 \) 不发生冲突为止，则 \( H_2 \) 对该记录在表中的散列地址。

这种方法在寻找“下一个”空的散列地址时，原来的数组空间对所有的元素都是开放的，所以称为开放地址法。通常把寻找“下一个”空位的过程称为探测，上述方法可用如下公式表示：

\[ H_i = (H(key) + id) \%m \quad i = 1, 2, \cdots, k \quad (k \leq m - 1) \]

其中，\( H(key) \)为散列函数，\( m \)为散列表表长，\( d_i \)为增量序列。根据d取值的不同，可以分为以下3种探测方法。

（1）线性探测法
\[ d_i = 1, 2, 3, \cdots, m - 1 \]
这种探测方法可以将散列表假想成一个循环表，发生冲突时，从冲突地址的下一单元顺序寻找空单元，如果到最后一个位置也没找到空单元，则回到表头开始继续查找，一旦找到一个空位，就把此元素放入此空位中。如果找不到空位，则说明散列表已满，需要进行溢出处理。

（2）二次探测法
\[ d_i = 1^2, -1^2, 2^2, -2^2, 3^2, \cdots, k^2, -k^2 (k \leq m/2) \]

（3）伪随机探测法
\[ d_i = \text{伪随机数序列} \]

例如，散列表的长度为11，散列函数\( H(key) = key\%11 \)，假设表中已填有关键字分别为60、17、29的记录，如图7.29（a）所示。现有第四个记录，其关键字为38，由散列函数得到散列地址为5，产生冲突。

若用线性探测法处理时，得到下一个地址6，仍冲突；再求下一个地址7，仍冲突；直到散列地址为8的位置为“空”，处理冲突的过程结束，38填入散列表中序号为8的位置，如图7.29（b）所示。

若用二次探测法，散列地址5冲突后，得到下一个地址6，仍冲突；再求得下一个地址4，无冲突，38填入序号为4的位置，如图7.29（c）所示。

若用伪随机探测法，假设产生的伪随机数为9，则计算下一个散列地址为(5+9)%11=3，所以38填入序号为3的位置，如图7.29（d）所示。

\[
\begin{array}{cccccccc}
0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 \\
\hline
& & & & & & & & & & \\
\end{array}
\]

(a) 插入前

\[
\begin{array}{cccccccc}
& & & & & & & & \\
60 & 17 & 29 & 38 & & & & & & \\
\end{array}
\]

(b) 线性探测法

\[
\begin{array}{cccccccc}
& & & & & & & & \\
38 & 60 & 17 & 29 & & & & & \\
\end{array}
\]

(c) 二次探测法

\[
\begin{array}{cccccccc}
& & & & & & & & \\
38 & 60 & 17 & 29 & & & & & \\
\end{array}
\]

(d) 伪随机探测法

图7.29 用开放地址法处理冲突时，关键字为38的记录插入前后的散列表

从上述线性探测法处理的过程中可以看到一个现象：当表中\(i, i+1, i+2\)位置上已填有记录时，下一个散列地址为\(i, i+1, i+2和i+3\)的记录都将填入\(i+3\)的位置，这种在处理冲突过程中发生的两个第一个散列地址不同的记录各向同于一个后继散列地址的现象称作“二次聚集”（或称作“堆积”），即在处理同义词的冲突过程中又添加了非同义词的冲突。

可以看出，上述3种处理方法各有优缺点。线性探测法的优点是：只要散列表未填满，总能找到一个不发生冲突的地址。缺点是：会产生“二次聚集”现象。而二次探测法和伪随机探测法的优点是：可以避免“二次聚集”现象。其缺点也很显然：不能保证一定找到不发生冲突的地址。

### 扩展并讲解知识点

#### 折叠法
折叠法是一种散列函数构造方法，适用于关键字位数较多且难以直接找到取值较分散的几位的情况。其基本思想是将关键字分割成位数相同的几部分（最后一部分的位数可以不同），然后取这几部分的叠加和（舍去进位）作为散列地址。折叠法分为两种：移位叠加和边界叠加。

- **移位叠加**：将分割后每一部分的最低位对齐，然后相加。
- **边界叠加**：将两个相邻的部分沿边界来回折叠，然后对齐相加。

例如，关键字 \( key = 45387765213 \)，从左到右每3位分为一组，得到4个部分：\( 453, 877, 652, 13 \)。分别采用移位叠加和边界叠加，求得散列地址为995和914。

#### 除留余数法
除留余数法是一种简单且常用的散列函数构造方法。其基本思想是选择一个不大于散列表表长 \( m \) 的数 \( p \)，用 \( p \) 去除关键字，除后所得余数为散列地址，即：

\[ H(key) = key\%p \]

关键在于选取适当的 \( p \)，通常选择小于表长的最大质数。例如，表长 \( m = 100 \)，可取 \( p = 97 \)。

#### 处理冲突的方法
处理冲突的方法主要分为两大类：开放地址法和链地址法。

##### 开放地址法
开放地址法的基本思想是当某一记录关键字 \( key \) 的初始散列地址 \( H_0 = H(key) \) 发生冲突时，以 \( H_0 \) 为基础，采取合适方法计算得到另一个地址 \( H_1 \)，如果 \( H_1 \) 仍然发生冲突，继续寻找下一个地址 \( H_2 \)，直至找到不发生冲突的地址。

- **线性探测法**：从冲突地址的下一单元顺序寻找空单元，如果到最后一个位置也没找到空单元，则回到表头开始继续查找。
- **二次探测法**：使用二次函数来寻找下一个地址。
- **伪随机探测法**：使用伪随机数序列来寻找下一个地址。

### 选择题

1. 折叠法的基本思想是什么？
   A. 将关键字分割成位数相同的几部分，然后取这几部分的叠加和（舍去进位）作为散列地址
   B. 将关键字直接取模
   C. 使用伪随机数序列
   D. 使用二次函数
   **答案：A**
   **解释：** 折叠法的基本思想是将关键字分割成位数相同的几部分，然后取这几部分的叠加和（舍去进位）作为散列地址。

2. 折叠法分为哪两种？
   A. 移位叠加和边界叠加
   B. 线性探测法和二次探测法
   C. 伪随机探测法和线性探测法
   D. 除留余数法和平方取中法
   **答案：A**
   **解释：** 折叠法分为移位叠加和边界叠加两种。

3. 除留余数法的关键是什么？
   A. 选择适当的 \( p \)
   B. 使用伪随机数序列
   C. 使用二次函数
   D. 将关键字分割成位数相同的几部分
   **答案：A**
   **解释：** 除留余数法的关键是选择适当的 \( p \)。

4. 开放地址法的基本思想是什么？
   A. 当某一记录关键字 \( key \) 的初始散列地址 \( H_0 = H(key) \) 发生冲突时，以 \( H_0 \) 为基础，采取合适方法计算得到另一个地址 \( H_1 \)
   B. 将关键字直接取模
   C. 使用伪随机数序列
   D. 使用二次函数
   **答案：A**
   **解释：** 开放地址法的基本思想是当某一记录关键字 \( key \) 的初始散列地址 \( H_0 = H(key) \) 发生冲突时，以 \( H_0 \) 为基础，采取合适方法计算得到另一个地址 \( H_1 \)。

5. 线性探测法的缺点是什么？
   A. 会产生“二次聚集”现象
   B. 不能保证一定找到不发生冲突的地址
   C. 计算复杂
   D. 需要大量内存
   **答案：A**
   **解释：** 线性探测法的缺点是会产生“二次聚集”现象。

6. 二次探测法的优点是什么？
   A. 可以避免“二次聚集”现象
   B. 计算简单
   C. 适用范围广
   D. 需要大量内存
   **答案：A**
   **解释：** 二次探测法的优点是可以避免“二次聚集”现象。

7. 伪随机探测法的缺点是什么？
   A. 不能保证一定找到不发生冲突的地址
   B. 会产生“二次聚集”现象
   C. 计算复杂
   D. 需要大量内存
   **答案：A**
   **解释：** 伪随机探测法的缺点是不能保证一定找到不发生冲突的地址。

8. 除留余数法适用于什么情况？
   A. 表长 \( m \) 较大
   B. 表长 \( m \) 较小
   C. 关键字位数较多
   D. 关键字位数较少
   **答案：A**
   **解释：** 除留余数法适用于表长 \( m \) 较大的情况。

9. 折叠法的适用情况是什么？
   A. 散列地址的位数较少，而关键字的位数较多
   B. 散列地址的位数较多，而关键字的位数较少
   C. 关键字位数较少
   D. 散列地址的位数较多
   **答案：A**
   **解释：** 折叠法的适用情况是散列地址的位数较少，而关键字的位数较多。

10. 线性探测法的优点是什么？
    A. 只要散列表未填满，总能找到一个不发生冲突的地址
    B. 可以避免“二次聚集”现象
    C. 计算简单
    D. 适用范围广
    **答案：A**
    **解释：** 线性探测法的优点是只要散列表未填满，总能找到一个不发生冲突的地址。

11. 二次探测法的缺点是什么？
    A. 不能保证一定找到不发生冲突的地址
    B. 会产生“二次聚集”现象
    C. 计算复杂
    D. 需要大量内存
    **答案：A**
    **解释：** 二次探测法的缺点是不能保证一定找到不发生冲突的地址。

12. 伪随机探测法的优点是什么？
    A. 可以避免“二次聚集”现象
    B. 计算简单
    C. 适用范围广
    D. 需要大量内存
    **答案：A**
    **解释：** 伪随机探测法的优点是可以避免“二次聚集”现象。

13. 除留余数法的关键是选择适当的什么？
    A. \( p \)
    B. 伪随机数序列
    C. 二次函数
    D. 散列地址
    **答案：A**
    **解释：** 除留余数法的关键是选择适当的 \( p \)。

14. 开放地址法中的“二次聚集”现象是什么？
    A. 在处理同义词的冲突过程中又添加了非同义词的冲突
    B. 计算复杂
    C. 需要大量内存
    D. 不能保证一定找到不发生冲突的地址
    **答案：A**
    **解释：** 开放地址法中的“二次聚集”现象是在处理同义词的冲突过程中又添加了非同义词的冲突。

15. 线性探测法的基本思想是什么？
    A. 从冲突地址的下一单元顺序寻找空单元
    B. 使用伪随机数序列
    C. 使用二次函数
    D. 将关键字分割成位数相同的几部分
    **答案：A**
    **解释：** 线性探测法的基本思想是从冲突地址的下一单元顺序寻找空单元。

16. 二次探测法的基本思想是什么？
    A. 使用二次函数来寻找下一个地址
    B. 使用伪随机数序列
    C. 将关键字分割成位数相同的几部分
    D. 将关键字直接取模
    **答案：A**
    **解释：** 二次探测法的基本思想是使用二次函数来寻找下一个地址。

17. 伪随机探测法的基本思想是什么？
    A. 使用伪随机数序列来寻找下一个地址
    B. 使用二次函数
    C. 将关键字分割成位数相同的几部分
    D. 将关键字直接取模
    **答案：A**
    **解释：** 伪随机探测法的基本思想是使用伪随机数序列来寻找下一个地址。

18. 除留余数法的计算简单吗？
    A. 是
    B. 否
    C. 有时简单，有时复杂
    D. 取决于 \( p \) 的选择
    **答案：A**
    **解释：** 除留余数法的计算是简单的。

19. 开放地址法中的“探测”是什么？
    A. 寻找“下一个”空的散列地址的过程
    B. 使用伪随机数序列
    C. 使用二次函数
    D. 将关键字分割成位数相同的几部分
    **答案：A**
    **解释：** 开放地址法中的“探测”是寻找“下一个”空的散列地址的过程。

20. 折叠法的优点是什么？
    A. 适用于散列地址的位数较少，而关键字的位数较多的情况
    B. 计算简单
    C. 适用范围广
    D. 需要大量内存
    **答案：A**
    **解释：** 折叠法的优点是适用于散列地址的位数较少，而关键字的位数较多的情况。