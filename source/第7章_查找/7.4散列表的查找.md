### 7.4 散列表的查找

#### 7.4.1 散列表的基本概念

在前面的讨论中，我们探讨了基于线性表和树表结构的查找方法。这些方法都是以关键字的比较为基础的。在查找过程中，我们只考虑各元素关键字之间的相对大小，记录在存储结构中的位置与其关键字没有直接关系。因此，查找时间与表的长度有关，特别是当节点个数很多时，查找时需要大量地与无效节点的关键字进行比较，导致查找速度很慢。

如果能在元素的存储位置和其关键字之间建立某种直接关系，那么在进行查找时，就无需进行比较或只需进行很少的比较，按照这种关系直接由关键字找到相应的记录。这就是散列表查找法（Hash Search）的思想。散列表查找法通过对元素的关键字值进行某种运算，直接求出元素的地址，即使用关键字到地址的直接转换方法，而不需要反复比较。因此，散列表查找法又叫杂凑法或散列法。

下面给出散列法中常用的几个术语：

1. **散列函数和散列地址**：在记录的存储位置和其关键字 \( key \) 之间建立一个确定的对应关系 \( H \)，使 \( p = H(key) \)，称这个对应关系为散列函数，\( p \) 为散列地址。
2. **散列表**：一个有限连续的地址空间，用以存储散列函数计算得到相应散列地址的数据记录。通常散列表的存储空间是一个一维数组，散列地址是数组的下标。
3. **冲突和同义词**：对不同的关键字可能得到同一散列地址，即 \( key_1 \neq key_2 \)，而 \( H(key_1) = H(key_2) \)，这种现象称为冲突。具有相同函数值的关键字对该散列函数来说称作同义词，\( key_1 \) 和 \( key_2 \) 互为同义词。

例如，对C语言某些关键字集合建立一个散列表，关键字集合为：
\[ S_i = \{main, int, float, while, return, break, switch, case, do\} \]
设定一个长度为26的散列表应该足够，散列表可定义为：
\[ char HT[26][8]; \]
假设散列函数的值取为关键字 \( key \) 中第一个字母在字母表 \( \{a, b, \cdots, z\} \) 中的序号（序号范围为0~25），即：
\[ H(key) = key[0] - 'a' \]
其中，设 \( key \) 的类型是长度为8的字符数组，根据此散列函数构造的散列表如表7.1所示。

| 0  | 1  | 2  | 3  | 4  | 5  | …  | s  | …  | D  | …  | Dplal | …  | 22 | …  | 25 |
|----|----|----|----|----|----|----|----|----|----|----|-------|----|----|----|----|
| break | case | do | float | int | main | __ | return | switch | while |

假设关键字集合扩充为：
\[ S_i + \{short, default, double, static, for, struct\} \]

如果散列函数不变，新加入的7个关键字经过计算得到：
\[ H(short) = H(static) = H(struct) = 18 \]
\[ H(default) = H(double) = 3 \]
\[ H(for) = 5 \]

而18、3和5这几个位置均已存放相应的关键字，这就发生了冲突。其中，`switch`、`short`、`static` 和 `struct` 称为同义词；`do`、`default` 和 `double` 称为同义词；`float` 和 `for` 称为同义词。

集合 \( S \) 中的关键字仅有15个，仔细分析这15个关键字的特性，应该不难构造一个散列函数以避免冲突。但在实际应用中，理想化的、不产生冲突的散列函数极少存在，这是因为通常散列表中关键字的取值集合远远大于表空间的地址集。例如，高级语言的编译程序要对源程序中的标识符建立一张符号表进行管理，多数都采取散列表。在设定散列函数时，考虑的查找关键字集合应包含所有可能产生的关键字，不同的源程序中使用的标识符一般也不相同。如果此语言规定标识符为长度不超过8的、字母开头的由字母和数字组成的串，字母区分大小写，则标识符取值集合的大小为：
\[ 52 \times 62^7 \approx 1.09 \times 10^{14} \]

而一个源程序中出现的标识符是有限的，所以编译程序将散列表的长度设为1000足矣。于是，要将多达 \( 10^{14} \) 个可能的标识符映射到有限的地址上，难免产生冲突。通常，散列函数是一个多对一的映射，所以冲突是不可避免的，只能通过选择一个“好”的散列函数使得在一定程度上减少冲突。而一旦发生冲突，就必须采取相应措施及时予以解决。

综上所述，散列查找法主要研究以下两方面的问题：

1. 如何构造散列函数；
2. 如何处理冲突。

