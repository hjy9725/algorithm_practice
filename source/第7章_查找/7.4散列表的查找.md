### 7.4 散列表的查找

#### 7.4.1 散列表的基本概念

在前面的讨论中，我们探讨了基于线性表和树表结构的查找方法。这些方法都是以关键字的比较为基础的。在查找过程中，我们只考虑各元素关键字之间的相对大小，记录在存储结构中的位置与其关键字没有直接关系。因此，查找时间与表的长度有关，特别是当节点个数很多时，查找时需要大量地与无效节点的关键字进行比较，导致查找速度很慢。

如果能在元素的存储位置和其关键字之间建立某种直接关系，那么在进行查找时，就无需进行比较或只需进行很少的比较，按照这种关系直接由关键字找到相应的记录。这就是散列表查找法（Hash Search）的思想。散列表查找法通过对元素的关键字值进行某种运算，直接求出元素的地址，即使用关键字到地址的直接转换方法，而不需要反复比较。因此，散列表查找法又叫杂凑法或散列法。

下面给出散列法中常用的几个术语：

1. **散列函数和散列地址**：在记录的存储位置和其关键字 \( key \) 之间建立一个确定的对应关系 \( H \)，使 \( p = H(key) \)，称这个对应关系为散列函数，\( p \) 为散列地址。
2. **散列表**：一个有限连续的地址空间，用以存储散列函数计算得到相应散列地址的数据记录。通常散列表的存储空间是一个一维数组，散列地址是数组的下标。
3. **冲突和同义词**：对不同的关键字可能得到同一散列地址，即 \( key_1 \neq key_2 \)，而 \( H(key_1) = H(key_2) \)，这种现象称为冲突。具有相同函数值的关键字对该散列函数来说称作同义词，\( key_1 \) 和 \( key_2 \) 互为同义词。

例如，对C语言某些关键字集合建立一个散列表，关键字集合为：
\[ S_i = \{main, int, float, while, return, break, switch, case, do\} \]
设定一个长度为26的散列表应该足够，散列表可定义为：
\[ char HT[26][8]; \]
假设散列函数的值取为关键字 \( key \) 中第一个字母在字母表 \( \{a, b, \cdots, z\} \) 中的序号（序号范围为0~25），即：
\[ H(key) = key[0] - 'a' \]
其中，设 \( key \) 的类型是长度为8的字符数组，根据此散列函数构造的散列表如表7.1所示。

| 0  | 1  | 2  | 3  | 4  | 5  | …  | s  | …  | D  | …  | Dplal | …  | 22 | …  | 25 |
|----|----|----|----|----|----|----|----|----|----|----|-------|----|----|----|----|
| break | case | do | float | int | main | __ | return | switch | while |

假设关键字集合扩充为：
\[ S_i + \{short, default, double, static, for, struct\} \]

如果散列函数不变，新加入的7个关键字经过计算得到：
\[ H(short) = H(static) = H(struct) = 18 \]
\[ H(default) = H(double) = 3 \]
\[ H(for) = 5 \]

而18、3和5这几个位置均已存放相应的关键字，这就发生了冲突。其中，`switch`、`short`、`static` 和 `struct` 称为同义词；`do`、`default` 和 `double` 称为同义词；`float` 和 `for` 称为同义词。

集合 \( S \) 中的关键字仅有15个，仔细分析这15个关键字的特性，应该不难构造一个散列函数以避免冲突。但在实际应用中，理想化的、不产生冲突的散列函数极少存在，这是因为通常散列表中关键字的取值集合远远大于表空间的地址集。例如，高级语言的编译程序要对源程序中的标识符建立一张符号表进行管理，多数都采取散列表。在设定散列函数时，考虑的查找关键字集合应包含所有可能产生的关键字，不同的源程序中使用的标识符一般也不相同。如果此语言规定标识符为长度不超过8的、字母开头的由字母和数字组成的串，字母区分大小写，则标识符取值集合的大小为：
\[ 52 \times 62^7 \approx 1.09 \times 10^{14} \]

而一个源程序中出现的标识符是有限的，所以编译程序将散列表的长度设为1000足矣。于是，要将多达 \( 10^{14} \) 个可能的标识符映射到有限的地址上，难免产生冲突。通常，散列函数是一个多对一的映射，所以冲突是不可避免的，只能通过选择一个“好”的散列函数使得在一定程度上减少冲突。而一旦发生冲突，就必须采取相应措施及时予以解决。

综上所述，散列查找法主要研究以下两方面的问题：

1. 如何构造散列函数；
2. 如何处理冲突。

### 扩展讲解

#### 散列函数的设计

散列函数的设计是散列表查找法的核心。一个好的散列函数应该满足以下几个条件：

1. **均匀性**：散列函数应尽量均匀地将关键字映射到散列表的各个地址上，以减少冲突的发生。
2. **简单性**：散列函数应尽可能简单，以便快速计算。
3. **高效性**：散列函数应能在常数时间内完成计算，以保证查找效率。

常见的散列函数设计方法包括：

1. **除留余数法**：将关键字 \( key \) 除以某个数 \( m \) 后取余数，即 \( H(key) = key \% m \)。通常选择 \( m \) 为质数，以减少冲突。
2. **平方取中法**：将关键字平方后取中间几位作为散列地址。
3. **折叠法**：将关键字分割成位数相同的几部分，然后取这几部分的叠加和作为散列地址。

#### 冲突处理方法

即使设计了好的散列函数，冲突仍然是不可避免的。因此，需要有相应的冲突处理方法：

1. **开放地址法**：当发生冲突时，通过某种探测方法在散列表中寻找下一个空闲位置。常见的探测方法有：
   - **线性探测法**：从冲突位置开始，依次检查下一个位置，直到找到空闲位置。
   - **二次探测法**：从冲突位置开始，依次检查 \( 1^2, -1^2, 2^2, -2^2, \ldots \) 位置。
   - **双重散列法**：使用第二个散列函数计算探测步长。

2. **链地址法**：将所有同义词存储在同一个链表中，散列表中的每个位置存储一个链表的头指针。

3. **再散列法**：当散列表的装填因子达到一定阈值时，重新构造一个更大的散列表，并将所有元素重新散列到新表中。

### 选择题

1. **散列表查找法又叫什么？**
   - A. 线性查找法
   - B. 二分查找法
   - C. 杂凑法或散列法
   - D. 树查找法
   - **答案：C**
   - **解释**：散列表查找法通过对元素的关键字值进行某种运算，直接求出元素的地址，即使用关键字到地址的直接转换方法，而不需要反复比较。因此，散列表查找法又叫杂凑法或散列法。

2. **散列函数的作用是什么？**
   - A. 将关键字转换为存储地址
   - B. 比较关键字的大小
   - C. 排序关键字
   - D. 删除关键字
   - **答案：A**
   - **解释**：散列函数在记录的存储位置和其关键字之间建立一个确定的对应关系，使 \( p = H(key) \)，称这个对应关系为散列函数，\( p \) 为散列地址。

3. **以下哪种情况会导致冲突？**
   - A. \( key_1 = key_2 \)
   - B. \( H(key_1) \neq H(key_2) \)
   - C. \( key_1 \neq key_2 \) 且 \( H(key_1) = H(key_2) \)
   - D. \( key_1 = key_2 \) 且 \( H(key_1) \neq H(key_2) \)
   - **答案：C**
   - **解释**：对不同的关键字可能得到同一散列地址，即 \( key_1 \neq key_2 \)，而 \( H(key_1) = H(key_2) \)，这种现象称为冲突。

4. **散列表的存储空间通常是什么形式？**
   - A. 链表
   - B. 树
   - C. 一维数组
   - D. 二维数组
   - **答案：C**
   - **解释**：通常散列表的存储空间是一个一维数组，散列地址是数组的下标。

5. **以下哪种方法不是处理冲突的方法？**
   - A. 线性探测法
   - B. 二次探测法
   - C. 双重散列法
   - D. 二分查找法
   - **答案：D**
   - **解释**：二分查找法是一种基于比较的查找方法，不是处理冲突的方法。

6. **除留余数法中，通常选择 \( m \) 为质数的原因是什么？**
   - A. 减少冲突
   - B. 增加计算速度
   - C. 简化计算
   - D. 提高存储效率
   - **答案：A**
   - **解释**：选择 \( m \) 为质数可以减少冲突的发生，因为质数与其他数的公因数较少，使得关键字分布更均匀。

7. **平方取中法的主要思想是什么？**
   - A. 将关键字平方后取中间几位作为散列地址
   - B. 将关键字除以某个数后取余数
   - C. 将关键字分割成位数相同的几部分，然后取这几部分的叠加和
   - D. 使用第二个散列函数计算探测步长
   - **答案：A**
   - **解释**：平方取中法将关键字平方后取中间几位作为散列地址。

8. **链地址法的主要思想是什么？**
   - A. 将所有同义词存储在同一个链表中
   - B. 从冲突位置开始，依次检查下一个位置，直到找到空闲位置
   - C. 使用第二个散列函数计算探测步长
   - D. 当散列表的装填因子达到一定阈值时，重新构造一个更大的散列表
   - **答案：A**
   - **解释**：链地址法将所有同义词存储在同一个链表中，散列表中的每个位置存储一个链表的头指针。

9. **再散列法的主要思想是什么？**
   - A. 将所有同义词存储在同一个链表中
   - B. 从冲突位置开始，依次检查下一个位置，直到找到空闲位置
   - C. 使用第二个散列函数计算探测步长
   - D. 当散列表的装填因子达到一定阈值时，重新构造一个更大的散列表
   - **答案：D**
   - **解释**：再散列法当散列表的装填因子达到一定阈值时，重新构造一个更大的散列表，并将所有元素重新散列到新表中。

10. **以下哪种方法不是探测方法？**
    - A. 线性探测法
    - B. 二次探测法
    - C. 双重散列法
    - D. 二分查找法
    - **答案：D**
    - **解释**：二分查找法是一种基于比较的查找方法，不是探测方法。

11. **散列函数的设计应满足哪些条件？**
    - A. 均匀性、简单性、高效性
    - B. 均匀性、复杂性、高效性
    - C. 均匀性、简单性、低效性
    - D. 复杂性、简单性、高效性
    - **答案：A**
    - **解释**：一个好的散列函数应该满足均匀性、简单性和高效性。

12. **以下哪种方法不是散列函数的设计方法？**
    - A. 除留余数法
    - B. 平方取中法
    - C. 折叠法
    - D. 二分查找法
    - **答案：D**
    - **解释**：二分查找法是一种基于比较的查找方法，不是散列函数的设计方法。

13. **散列表中的冲突是指什么？**
    - A. 不同的关键字得到不同的散列地址
    - B. 相同的关键字得到不同的散列地址
    - C. 不同的关键字得到相同的散列地址
    - D. 相同的关键字得到相同的散列地址
    - **答案：C**
    - **解释**：对不同的关键字可能得到同一散列地址，即 \( key_1 \neq key_2 \)，而 \( H(key_1) = H(key_2) \)，这种现象称为冲突。

14. **以下哪种方法不是处理冲突的方法？**
    - A. 线性探测法
    - B. 二次探测法
    - C. 双重散列法
    - D. 二分查找法
    - **答案：D**
    - **解释**：二分查找法是一种基于比较的查找方法，不是处理冲突的方法。

15. **散列表的装填因子是指什么？**
    - A. 散列表中元素的个数
    - B. 散列表的长度
    - C. 散列表中元素的个数与散列表长度的比值
    - D. 散列表中空闲位置的个数
    - **答案：C**
    - **解释**：散列表的装填因子是指散列表中元素的个数与散列表长度的比值。

16. **以下哪种方法不是探测方法？**
    - A. 线性探测法
    - B. 二次探测法
    - C. 双重散列法
    - D. 二分查找法
    - **答案：D**
    - **解释**：二分查找法是一种基于比较的查找方法，不是探测方法。

17. **散列函数的设计应满足哪些条件？**
    - A. 均匀性、简单性、高效性
    - B. 均匀性、复杂性、高效性
    - C. 均匀性、简单性、低效性
    - D. 复杂性、简单性、高效性
    - **答案：A**
    - **解释**：一个好的散列函数应该满足均匀性、简单性和高效性。

18. **以下哪种方法不是散列函数的设计方法？**
    - A. 除留余数法
    - B. 平方取中法
    - C. 折叠法
    - D. 二分查找法
    - **答案：D**
    - **解释**：二分查找法是一种基于比较的查找方法，不是散列函数的设计方法。

19. **散列表中的冲突是指什么？**
    - A. 不同的关键字得到不同的散列地址
    - B. 相同的关键字得到不同的散列地址
    - C. 不同的关键字得到相同的散列地址
    - D. 相同的关键字得到相同的散列地址
    - **答案：C**
    - **解释**：对不同的关键字可能得到同一散列地址，即 \( key_1 \neq key_2 \)，而 \( H(key_1) = H(key_2) \)，这种现象称为冲突。

20. **以下哪种方法不是处理冲突的方法？**
    - A. 线性探测法
    - B. 二次探测法
    - C. 双重散列法
    - D. 二分查找法
    - **答案：D**
    - **解释**：二分查找法是一种基于比较的查找方法，不是处理冲突的方法。

