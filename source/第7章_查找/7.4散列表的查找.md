### 7.4 散列表的查找

#### 7.4.1 散列表的基本概念

在前面的讨论中，我们探讨了基于线性表和树表结构的查找方法。这些方法都是以关键字的比较为基础的。在查找过程中，我们只考虑各元素关键字之间的相对大小，记录在存储结构中的位置与其关键字没有直接关系。因此，查找时间与表的长度有关，特别是当节点个数很多时，查找时需要大量地与无效节点的关键字进行比较，导致查找速度很慢。

如果能在元素的存储位置和其关键字之间建立某种直接关系，那么在进行查找时，就无需进行比较或只需进行很少的比较，按照这种关系直接由关键字找到相应的记录。这就是散列表查找法（Hash Search）的思想。散列表查找法通过对元素的关键字值进行某种运算，直接求出元素的地址，即使用关键字到地址的直接转换方法，而不需要反复比较。因此，散列表查找法又叫杂凑法或散列法。

下面给出散列法中常用的几个术语：

1. **散列函数和散列地址**：在记录的存储位置和其关键字 $ key $ 之间建立一个确定的对应关系 $ H $，使 $ p = H(key) $，称这个对应关系为散列函数，$ p $ 为散列地址。
2. **散列表**：一个有限连续的地址空间，用以存储散列函数计算得到相应散列地址的数据记录。通常散列表的存储空间是一个一维数组，散列地址是数组的下标。
3. **冲突和同义词**：对不同的关键字可能得到同一散列地址，即 $ key_1 \neq key_2 $，而 $ H(key_1) = H(key_2) $，这种现象称为冲突。具有相同函数值的关键字对该散列函数来说称作同义词，$ key_1 $ 和 $ key_2 $ 互为同义词。

例如，对C语言某些关键字集合建立一个散列表，关键字集合为：
$ S_i = \lbrace main, int, float, while, return, break, switch, case, do\rbrace $
设定一个长度为26的散列表应该足够，散列表可定义为：
$ char HT[26][8]; $
假设散列函数的值取为关键字 $ key $ 中第一个字母在字母表 $ \lbrace a, b, \cdots, z\rbrace $ 中的序号（序号范围为0~25），即：
$ H(key) = key[0] - 'a' $
其中，设 $ key $ 的类型是长度为8的字符数组，根据此散列函数构造的散列表如表7.1所示。

| 0  | 1  | 2  | 3  | 4  | 5  | …  | s  | …  | D  | …  | Dplal | …  | 22 | …  | 25 |
|----|----|----|----|----|----|----|----|----|----|----|-------|----|----|----|----|
| break | case | do | float | int | main | __ | return | switch | while |

假设关键字集合扩充为：
$ S_i + \lbrace short, default, double, static, for, struct\rbrace $

如果散列函数不变，新加入的7个关键字经过计算得到：
$ H(short) = H(static) = H(struct) = 18 $
$ H(default) = H(double) = 3 $
$ H(for) = 5 $

而18、3和5这几个位置均已存放相应的关键字，这就发生了冲突。其中，`switch`、`short`、`static` 和 `struct` 称为同义词；`do`、`default` 和 `double` 称为同义词；`float` 和 `for` 称为同义词。

集合 $ S $ 中的关键字仅有15个，仔细分析这15个关键字的特性，应该不难构造一个散列函数以避免冲突。但在实际应用中，理想化的、不产生冲突的散列函数极少存在，这是因为通常散列表中关键字的取值集合远远大于表空间的地址集。例如，高级语言的编译程序要对源程序中的标识符建立一张符号表进行管理，多数都采取散列表。在设定散列函数时，考虑的查找关键字集合应包含所有可能产生的关键字，不同的源程序中使用的标识符一般也不相同。如果此语言规定标识符为长度不超过8的、字母开头的由字母和数字组成的串，字母区分大小写，则标识符取值集合的大小为：
$ 52 \times 62^7 \approx 1.09 \times 10^{14} $

而一个源程序中出现的标识符是有限的，所以编译程序将散列表的长度设为1000足矣。于是，要将多达 $ 10^{14} $ 个可能的标识符映射到有限的地址上，难免产生冲突。通常，散列函数是一个多对一的映射，所以冲突是不可避免的，只能通过选择一个“好”的散列函数使得在一定程度上减少冲突。而一旦发生冲突，就必须采取相应措施及时予以解决。

综上所述，散列查找法主要研究以下两方面的问题：

1. 如何构造散列函数；
2. 如何处理冲突。

### 扩展讲解

#### 散列函数的设计

散列函数的设计是散列表查找法的核心。一个好的散列函数应该满足以下几个条件：

1. **均匀性**：散列函数应尽量均匀地将关键字映射到散列表的各个地址上，以减少冲突的发生。
2. **简单性**：散列函数应尽可能简单，以便快速计算。
3. **高效性**：散列函数应能在常数时间内完成计算，以保证查找效率。

常见的散列函数设计方法包括：

1. **除留余数法**：将关键字 $ key $ 除以某个数 $ m $ 后取余数，即 $ H(key) = key \% m $。通常选择 $ m $ 为质数，以减少冲突。
2. **平方取中法**：将关键字平方后取中间几位作为散列地址。
3. **折叠法**：将关键字分割成位数相同的几部分，然后取这几部分的叠加和作为散列地址。

#### 冲突处理方法

即使设计了好的散列函数，冲突仍然是不可避免的。因此，需要有相应的冲突处理方法：

1. **开放地址法**：当发生冲突时，通过某种探测方法在散列表中寻找下一个空闲位置。常见的探测方法有：
   - **线性探测法**：从冲突位置开始，依次检查下一个位置，直到找到空闲位置。
   - **二次探测法**：从冲突位置开始，依次检查 $ 1^2, -1^2, 2^2, -2^2, \ldots $ 位置。
   - **双重散列法**：使用第二个散列函数计算探测步长。

2. **链地址法**：将所有同义词存储在同一个链表中，散列表中的每个位置存储一个链表的头指针。

3. **再散列法**：当散列表的装填因子达到一定阈值时，重新构造一个更大的散列表，并将所有元素重新散列到新表中。

### 选择题

1. **散列表查找法又叫什么？**
   - A. 线性查找法
   - B. 二分查找法
   - C. 杂凑法或散列法
   - D. 树查找法
   - **答案：C**
   - **解释**：散列表查找法通过对元素的关键字值进行某种运算，直接求出元素的地址，即使用关键字到地址的直接转换方法，而不需要反复比较。因此，散列表查找法又叫杂凑法或散列法。

2. **散列函数的作用是什么？**
   - A. 将关键字转换为存储地址
   - B. 比较关键字的大小
   - C. 排序关键字
   - D. 删除关键字
   - **答案：A**
   - **解释**：散列函数在记录的存储位置和其关键字之间建立一个确定的对应关系，使 $ p = H(key) $，称这个对应关系为散列函数，$ p $ 为散列地址。

3. **以下哪种情况会导致冲突？**
   - A. $ key_1 = key_2 $
   - B. $ H(key_1) \neq H(key_2) $
   - C. $ key_1 \neq key_2 $ 且 $ H(key_1) = H(key_2) $
   - D. $ key_1 = key_2 $ 且 $ H(key_1) \neq H(key_2) $
   - **答案：C**
   - **解释**：对不同的关键字可能得到同一散列地址，即 $ key_1 \neq key_2 $，而 $ H(key_1) = H(key_2) $，这种现象称为冲突。

4. **散列表的存储空间通常是什么形式？**
   - A. 链表
   - B. 树
   - C. 一维数组
   - D. 二维数组
   - **答案：C**
   - **解释**：通常散列表的存储空间是一个一维数组，散列地址是数组的下标。

5. **以下哪种方法不是处理冲突的方法？**
   - A. 线性探测法
   - B. 二次探测法
   - C. 双重散列法
   - D. 二分查找法
   - **答案：D**
   - **解释**：二分查找法是一种基于比较的查找方法，不是处理冲突的方法。

6. **除留余数法中，通常选择 $ m $ 为质数的原因是什么？**
   - A. 减少冲突
   - B. 增加计算速度
   - C. 简化计算
   - D. 提高存储效率
   - **答案：A**
   - **解释**：选择 $ m $ 为质数可以减少冲突的发生，因为质数与其他数的公因数较少，使得关键字分布更均匀。

7. **平方取中法的主要思想是什么？**
   - A. 将关键字平方后取中间几位作为散列地址
   - B. 将关键字除以某个数后取余数
   - C. 将关键字分割成位数相同的几部分，然后取这几部分的叠加和
   - D. 使用第二个散列函数计算探测步长
   - **答案：A**
   - **解释**：平方取中法将关键字平方后取中间几位作为散列地址。

8. **链地址法的主要思想是什么？**
   - A. 将所有同义词存储在同一个链表中
   - B. 从冲突位置开始，依次检查下一个位置，直到找到空闲位置
   - C. 使用第二个散列函数计算探测步长
   - D. 当散列表的装填因子达到一定阈值时，重新构造一个更大的散列表
   - **答案：A**
   - **解释**：链地址法将所有同义词存储在同一个链表中，散列表中的每个位置存储一个链表的头指针。

9. **再散列法的主要思想是什么？**
   - A. 将所有同义词存储在同一个链表中
   - B. 从冲突位置开始，依次检查下一个位置，直到找到空闲位置
   - C. 使用第二个散列函数计算探测步长
   - D. 当散列表的装填因子达到一定阈值时，重新构造一个更大的散列表
   - **答案：D**
   - **解释**：再散列法当散列表的装填因子达到一定阈值时，重新构造一个更大的散列表，并将所有元素重新散列到新表中。

10. **以下哪种方法不是探测方法？**
    - A. 线性探测法
    - B. 二次探测法
    - C. 双重散列法
    - D. 二分查找法
    - **答案：D**
    - **解释**：二分查找法是一种基于比较的查找方法，不是探测方法。

11. **散列函数的设计应满足哪些条件？**
    - A. 均匀性、简单性、高效性
    - B. 均匀性、复杂性、高效性
    - C. 均匀性、简单性、低效性
    - D. 复杂性、简单性、高效性
    - **答案：A**
    - **解释**：一个好的散列函数应该满足均匀性、简单性和高效性。

12. **以下哪种方法不是散列函数的设计方法？**
    - A. 除留余数法
    - B. 平方取中法
    - C. 折叠法
    - D. 二分查找法
    - **答案：D**
    - **解释**：二分查找法是一种基于比较的查找方法，不是散列函数的设计方法。

13. **散列表中的冲突是指什么？**
    - A. 不同的关键字得到不同的散列地址
    - B. 相同的关键字得到不同的散列地址
    - C. 不同的关键字得到相同的散列地址
    - D. 相同的关键字得到相同的散列地址
    - **答案：C**
    - **解释**：对不同的关键字可能得到同一散列地址，即 $ key_1 \neq key_2 $，而 $ H(key_1) = H(key_2) $，这种现象称为冲突。

14. **以下哪种方法不是处理冲突的方法？**
    - A. 线性探测法
    - B. 二次探测法
    - C. 双重散列法
    - D. 二分查找法
    - **答案：D**
    - **解释**：二分查找法是一种基于比较的查找方法，不是处理冲突的方法。

15. **散列表的装填因子是指什么？**
    - A. 散列表中元素的个数
    - B. 散列表的长度
    - C. 散列表中元素的个数与散列表长度的比值
    - D. 散列表中空闲位置的个数
    - **答案：C**
    - **解释**：散列表的装填因子是指散列表中元素的个数与散列表长度的比值。

16. **以下哪种方法不是探测方法？**
    - A. 线性探测法
    - B. 二次探测法
    - C. 双重散列法
    - D. 二分查找法
    - **答案：D**
    - **解释**：二分查找法是一种基于比较的查找方法，不是探测方法。

17. **散列函数的设计应满足哪些条件？**
    - A. 均匀性、简单性、高效性
    - B. 均匀性、复杂性、高效性
    - C. 均匀性、简单性、低效性
    - D. 复杂性、简单性、高效性
    - **答案：A**
    - **解释**：一个好的散列函数应该满足均匀性、简单性和高效性。

18. **以下哪种方法不是散列函数的设计方法？**
    - A. 除留余数法
    - B. 平方取中法
    - C. 折叠法
    - D. 二分查找法
    - **答案：D**
    - **解释**：二分查找法是一种基于比较的查找方法，不是散列函数的设计方法。

19. **散列表中的冲突是指什么？**
    - A. 不同的关键字得到不同的散列地址
    - B. 相同的关键字得到不同的散列地址
    - C. 不同的关键字得到相同的散列地址
    - D. 相同的关键字得到相同的散列地址
    - **答案：C**
    - **解释**：对不同的关键字可能得到同一散列地址，即 $ key_1 \neq key_2 $，而 $ H(key_1) = H(key_2) $，这种现象称为冲突。

20. **以下哪种方法不是处理冲突的方法？**
    - A. 线性探测法
    - B. 二次探测法
    - C. 双重散列法
    - D. 二分查找法
    - **答案：D**
    - **解释**：二分查找法是一种基于比较的查找方法，不是处理冲突的方法。

### 7.4.2 散列函数的构造方法

构造散列函数的方法很多，一般来说，应根据具体问题选用不同的散列函数，通常要考虑以下因素：

1. 散列表的长度；
2. 关键字的长度；
3. 关键字的分布情况；
4. 计算散列函数所需的时间；
5. 记录的查找频率。

构造一个“好”的散列函数应遵循以下两条原则：

1. 函数计算要简单，每一关键字只能有一个散列地址与之对应；
2. 函数的值域需在表长的范围内，计算出的散列地址的分布应均匀，尽可能减少冲突。

下面介绍构造散列函数的几种常用方法。

#### 1. 数字分析法

如果事先知道关键字集合，且每个关键字的位数比散列表的地址码位数多，每个关键字由 $ n $ 位数组成，如 $ k_1 k_2 \ldots k_n $，则可以从关键字中提取数字分布比较均匀的若干位作为散列地址。

例如，有80个记录，其关键字为8位十进制数。假设散列表的表长为100，则可取两位十进制数组成散列地址，选取的原则是分析这80个关键字，使得到的散列地址尽量避免产生冲突。假设这80个关键字中的一部分如下所列：

$
\begin{array}{cccccccc}
8 & 1 & 3 & 4 & 6 & 5 & 3 & 2 \\
8 & 1 & 3 & 7 & 2 & 2 & 4 & 2 \\
8 & 1 & 3 & 8 & 7 & 4 & 2 & 2 \\
8 & 1 & 3 & 0 & 1 & 3 & 6 & 7 \\
8 & 1 & 3 & 2 & 2 & 8 & 1 & 7 \\
8 & 1 & 3 & 3 & 8 & 9 & 6 & 7 \\
8 & 1 & 3 & 5 & 4 & 1 & 5 & 7 \\
8 & 1 & 3 & 6 & 8 & 5 & 3 & 7 \\
8 & 1 & 4 & 1 & 9 & 3 & 5 & 5 \\
\end{array}
$

从对关键字全体的分析中可以发现：第①、②位都是“8 1”，第③位只可能取3或4，第⑧位可能取2、5或7，因此这4位都不可取。由于中间的4位可看成近乎随机的，因此可取其中任意两位，或取其中两位与另外两位叠加求和后舍去进位作为散列地址。

数字分析法的适用情况：事先必须明确知道所有的关键字每一位上各种数字的分布情况。

在实际应用中，例如，同一出版社出版的所有图书，其ISBN的前几位都是相同的，因此，若数据表只包含同一出版社的图书，构造散列函数时可以利用数字分析法排除ISBN的前几位数字。

#### 2. 平方取中法

通常在选定散列函数时不一定能知道关键字的全部情况，取其中某几位也不一定合适，而一个数字平方后的中间几位数和数的每一位都相关，如果取关键字平方后的中间几位或其组合作为散列地址，则使随机分布的关键字得到的散列地址也是随机的，具体所取的位数由表长决定。平方取中法是一种较常用的构造散列函数的方法。

例如，为源程序中的标识符建立一个散列表，假设标识符为字母开头的字符串和数字组成的串。假设人为约定每个标识的内部编码规则如下：把字母在字母表中的位置序号作为该字母的内部编码，如A的内部编码为09，D的内部编码为04，A的内部编码为01。数字直接用其自身作为内部编码，如1的内部编码为01，2的内部编码为02。根据以上编码规则，可知“IDA1”的内部编码为09040101，同理可以得到“IDB2”“XID3”和“YID4”的内部编码。之后分别对内部编码进行平方运算，再取出第7位到第9位作为其相应标识符的散列地址，如表7.2所示。

| 标识符 | 内部编码 | 内部编码的平方 | 散列地址 |
|--------|----------|----------------|----------|
| IDA1   | 09040101 | 08172342609201 | 426      |
| IDB2   | 09040202 | 081725252200804 | 252      |
| XID3   | 24090403 | 580347516702409 | 516      |
| YID4   | 25090404 | 629528372883216 | 372      |

平方取中法的适用情况：不能事先了解关键字的所有情况，或难于直接从关键字中找到取值较分散的几位。

### 扩展讲解

#### 散列函数的构造方法

散列函数的构造方法有很多，选择合适的方法需要考虑多个因素，包括散列表的长度、关键字的长度、关键字的分布情况、计算散列函数所需的时间以及记录的查找频率。一个好的散列函数应满足以下两个原则：

1. **计算简单**：散列函数的计算应尽可能简单，每个关键字只能有一个散列地址与之对应。
2. **均匀分布**：散列函数的值域应在表长的范围内，计算出的散列地址应均匀分布，以减少冲突。

下面详细介绍几种常用的散列函数构造方法。

#### 1. 数字分析法

数字分析法适用于事先知道关键字集合的情况。如果每个关键字的位数比散列表的地址码位数多，可以从关键字中提取数字分布比较均匀的若干位作为散列地址。

**步骤**：
1. 分析关键字集合，找出数字分布比较均匀的若干位。
2. 提取这些位作为散列地址。

**示例**：
假设有80个记录，其关键字为8位十进制数。散列表的表长为100，则可取两位十进制数组成散列地址。通过分析关键字，发现某些位分布较均匀，可以提取这些位作为散列地址。

**适用情况**：
- 事先必须明确知道所有的关键字每一位上各种数字的分布情况。

#### 2. 平方取中法

平方取中法适用于不能事先了解关键字全部情况的情况。通过取关键字平方后的中间几位作为散列地址，可以使随机分布的关键字得到的散列地址也是随机的。

**步骤**：
1. 对关键字进行平方运算。
2. 取平方结果的中间几位作为散列地址。

**示例**：
假设标识符为字母开头的字符串和数字组成的串。根据内部编码规则，对内部编码进行平方运算，再取出第7位到第9位作为散列地址。

**适用情况**：
- 不能事先了解关键字的所有情况，或难于直接从关键字中找到取值较分散的几位。

### 选择题

1. **散列函数的设计应考虑哪些因素？**
   - A. 散列表的长度、关键字的长度、关键字的分布情况、计算散列函数所需的时间、记录的查找频率
   - B. 散列表的长度、关键字的长度、关键字的分布情况、计算散列函数所需的时间
   - C. 散列表的长度、关键字的长度、关键字的分布情况
   - D. 散列表的长度、关键字的长度
   - **答案：A**
   - **解释**：散列函数的设计应考虑散列表的长度、关键字的长度、关键字的分布情况、计算散列函数所需的时间以及记录的查找频率。

2. **一个好的散列函数应满足哪些原则？**
   - A. 计算简单、均匀分布
   - B. 计算复杂、均匀分布
   - C. 计算简单、不均匀分布
   - D. 计算复杂、不均匀分布
   - **答案：A**
   - **解释**：一个好的散列函数应满足计算简单和均匀分布的原则。

3. **数字分析法适用于什么情况？**
   - A. 事先知道关键字集合
   - B. 事先不知道关键字集合
   - C. 关键字位数少于散列表地址码位数
   - D. 关键字位数多于散列表地址码位数
   - **答案：A**
   - **解释**：数字分析法适用于事先知道关键字集合的情况。

4. **平方取中法的步骤是什么？**
   - A. 对关键字进行平方运算，取平方结果的中间几位作为散列地址
   - B. 对关键字进行平方运算，取平方结果的前几位作为散列地址
   - C. 对关键字进行平方运算，取平方结果的后几位作为散列地址
   - D. 对关键字进行平方运算，取平方结果的所有位作为散列地址
   - **答案：A**
   - **解释**：平方取中法的步骤是对关键字进行平方运算，取平方结果的中间几位作为散列地址。

5. **以下哪种方法不是散列函数的设计方法？**
   - A. 数字分析法
   - B. 平方取中法
   - C. 线性探测法
   - D. 折叠法
   - **答案：C**
   - **解释**：线性探测法是处理冲突的方法，不是散列函数的设计方法。

6. **散列表的长度对散列函数的设计有什么影响？**
   - A. 直接影响散列函数的值域
   - B. 不影响散列函数的值域
   - C. 直接影响关键字的分布情况
   - D. 不影响关键字的分布情况
   - **答案：A**
   - **解释**：散列表的长度直接影响散列函数的值域。

7. **关键字的长度对散列函数的设计有什么影响？**
   - A. 直接影响散列函数的计算复杂度
   - B. 不影响散列函数的计算复杂度
   - C. 直接影响散列函数的值域
   - D. 不影响散列函数的值域
   - **答案：A**
   - **解释**：关键字的长度直接影响散列函数的计算复杂度。

8. **关键字的分布情况对散列函数的设计有什么影响？**
   - A. 直接影响散列地址的均匀分布
   - B. 不影响散列地址的均匀分布
   - C. 直接影响散列函数的计算复杂度
   - D. 不影响散列函数的计算复杂度
   - **答案：A**
   - **解释**：关键字的分布情况直接影响散列地址的均匀分布。

9. **计算散列函数所需的时间对散列函数的设计有什么影响？**
   - A. 直接影响查找效率
   - B. 不影响查找效率
   - C. 直接影响散列地址的均匀分布
   - D. 不影响散列地址的均匀分布
   - **答案：A**
   - **解释**：计算散列函数所需的时间直接影响查找效率。

10. **记录的查找频率对散列函数的设计有什么影响？**
    - A. 直接影响散列函数的优化方向
    - B. 不影响散列函数的优化方向
    - C. 直接影响散列地址的均匀分布
    - D. 不影响散列地址的均匀分布
    - **答案：A**
    - **解释**：记录的查找频率直接影响散列函数的优化方向。

11. **数字分析法的步骤是什么？**
    - A. 分析关键字集合，提取数字分布比较均匀的若干位作为散列地址
    - B. 对关键字进行平方运算，取平方结果的中间几位作为散列地址
    - C. 对关键字进行平方运算，取平方结果的前几位作为散列地址
    - D. 对关键字进行平方运算，取平方结果的后几位作为散列地址
    - **答案：A**
    - **解释**：数字分析法的步骤是分析关键字集合，提取数字分布比较均匀的若干位作为散列地址。

12. **平方取中法的适用情况是什么？**
    - A. 不能事先了解关键字的所有情况，或难于直接从关键字中找到取值较分散的几位
    - B. 事先知道关键字集合
    - C. 关键字位数少于散列表地址码位数
    - D. 关键字位数多于散列表地址码位数
    - **答案：A**
    - **解释**：平方取中法的适用情况是不能事先了解关键字的所有情况，或难于直接从关键字中找到取值较分散的几位。

13. **以下哪种方法不是散列函数的设计方法？**
    - A. 数字分析法
    - B. 平方取中法
    - C. 双重散列法
    - D. 折叠法
    - **答案：C**
    - **解释**：双重散列法是处理冲突的方法，不是散列函数的设计方法。

14. **散列表的长度对散列函数的值域有什么影响？**
    - A. 直接影响
    - B. 不影响
    - C. 间接影响
    - D. 有时影响
    - **答案：A**
    - **解释**：散列表的长度直接影响散列函数的值域。

15. **关键字的长度对散列函数的计算复杂度有什么影响？**
    - A. 直接影响
    - B. 不影响
    - C. 间接影响
    - D. 有时影响
    - **答案：A**
    - **解释**：关键字的长度直接影响散列函数的计算复杂度。

16. **关键字的分布情况对散列地址的均匀分布有什么影响？**
    - A. 直接影响
    - B. 不影响
    - C. 间接影响
    - D. 有时影响
    - **答案：A**
    - **解释**：关键字的分布情况直接影响散列地址的均匀分布。

17. **计算散列函数所需的时间对查找效率有什么影响？**
    - A. 直接影响
    - B. 不影响
    - C. 间接影响
    - D. 有时影响
    - **答案：A**
    - **解释**：计算散列函数所需的时间直接影响查找效率。

18. **记录的查找频率对散列函数的优化方向有什么影响？**
    - A. 直接影响
    - B. 不影响
    - C. 间接影响
    - D. 有时影响
    - **答案：A**
    - **解释**：记录的查找频率直接影响散列函数的优化方向。

19. **数字分析法的适用情况是什么？**
    - A. 事先必须明确知道所有的关键字每一位上各种数字的分布情况
    - B. 不能事先了解关键字的所有情况
    - C. 关键字位数少于散列表地址码位数
    - D. 关键字位数多于散列表地址码位数
    - **答案：A**
    - **解释**：数字分析法的适用情况是事先必须明确知道所有的关键字每一位上各种数字的分布情况。

20. **平方取中法的步骤是什么？**
    - A. 对关键字进行平方运算，取平方结果的中间几位作为散列地址
    - B. 对关键字进行平方运算，取平方结果的前几位作为散列地址
    - C. 对关键字进行平方运算，取平方结果的后几位作为散列地址
    - D. 对关键字进行平方运算，取平方结果的所有位作为散列地址
    - **答案：A**
    - **解释**：平方取中法的步骤是对关键字进行平方运算，取平方结果的中间几位作为散列地址。

### 3. 折叠法

将关键字分割成位数相同的几部分（最后一部分的位数可以不同），然后取这几部分的叠加和（舍去进位）作为散列地址，这种方法称为折叠法。根据数位叠加的方式，可以把折叠法分为移位叠加和边界叠加两种。移位叠加是将分割后每一部分的最低位对齐，然后相加；边界叠加是将两个相邻的部分沿边界来回折叠，然后对齐相加。

例如，当散列表长为1000时，关键字 $ key = 45387765213 $，从左到右每3位分为一组，可以得到4个部分：$ 453, 877, 652, 13 $。分别采用移位叠加和边界叠加，求得散列地址为995和914，如图7.28所示。

折叠法的适用情况：适合于散列地址的位数较少，而关键字的位数较多，且难于直接从关键字中找到取值较分散的几位。

$
\begin{array}{ccc}
 & 453 & 453 \\
\hline
857 & 778 \\
652 & 652 \\
13 & + & 31 \\
\end{array}
$

$
[1995] \quad [1]914
$

$
H(key) = 995 \quad H(key) = 914
$

(a) 移位叠加 \quad (b) 边界叠加

图7.28 由折叠法求得散列地址

### 4. 除留余数法

假设散列表表长为 $ m $，选择一个不大于 $ m $ 的数 $ p $，用 $ p $ 去除关键字，除后所得余数为散列地址，即：

$ H(key) = key\%p $

这个方法的关键是选取适当的 $ p $，一般情况下，可以选为小于表长的最大质数。例如，表长 $ m = 100 $，可取 $ p = 97 $。

除留余数法计算简单，适用范围非常广，是最常用的构造散列函数的方法。它不仅可以对关键字直接取模，也可在折叠、平方取中等运算之后取模，这样能够保证散列地址一定落在散列表的地址空间中。

### 7.4.3 处理冲突的方法

选择一个“好”的散列函数可以在一定程度上减少冲突，但在实际应用中，很难完全避免发生冲突，所以选择一个有效的处理冲突的方法是散列法的另一个关键。创建散列表和查找散列表都会遇到冲突，两种情况下处理冲突的方法应该一致。下面以创建散列表为例，来说明处理冲突的方法。

处理冲突的方法与散列表本身的组织形式有关。按组织形式的不同，处理冲突的方法通常分两大类：开放地址法和链地址法。

#### 1. 开放地址法

开放地址法的基本思想是：把记录存储在散列表数组中，当某一记录关键字 $ key $ 的初始散列地址 $ H_0 = H(key) $ 发生冲突时，以 $ H_0 $ 为基础，采取合适方法计算得到另一个地址 $ H_1 $，如果 $ H_1 $ 仍然发生冲突，以 $ H_1 $ 为基础再求下一个地址 $ H_2 $，若 $ H_2 $ 仍然冲突，再求得 $ H_3 $。依次类推，直至 $ H_2 $ 不发生冲突为止，则 $ H_2 $ 对该记录在表中的散列地址。

这种方法在寻找“下一个”空的散列地址时，原来的数组空间对所有的元素都是开放的，所以称为开放地址法。通常把寻找“下一个”空位的过程称为探测，上述方法可用如下公式表示：

$ H_i = (H(key) + id) \%m \quad i = 1, 2, \cdots, k \quad (k \leq m - 1) $

其中，$ H(key) $为散列函数，$ m $为散列表表长，$ d_i $为增量序列。根据d取值的不同，可以分为以下3种探测方法。

（1）线性探测法
$ d_i = 1, 2, 3, \cdots, m - 1 $
这种探测方法可以将散列表假想成一个循环表，发生冲突时，从冲突地址的下一单元顺序寻找空单元，如果到最后一个位置也没找到空单元，则回到表头开始继续查找，一旦找到一个空位，就把此元素放入此空位中。如果找不到空位，则说明散列表已满，需要进行溢出处理。

（2）二次探测法
$ d_i = 1^2, -1^2, 2^2, -2^2, 3^2, \cdots, k^2, -k^2 (k \leq m/2) $

（3）伪随机探测法
$ d_i = \text{伪随机数序列} $

例如，散列表的长度为11，散列函数$ H(key) = key\%11 $，假设表中已填有关键字分别为60、17、29的记录，如图7.29（a）所示。现有第四个记录，其关键字为38，由散列函数得到散列地址为5，产生冲突。

若用线性探测法处理时，得到下一个地址6，仍冲突；再求下一个地址7，仍冲突；直到散列地址为8的位置为“空”，处理冲突的过程结束，38填入散列表中序号为8的位置，如图7.29（b）所示。

若用二次探测法，散列地址5冲突后，得到下一个地址6，仍冲突；再求得下一个地址4，无冲突，38填入序号为4的位置，如图7.29（c）所示。

若用伪随机探测法，假设产生的伪随机数为9，则计算下一个散列地址为(5+9)%11=3，所以38填入序号为3的位置，如图7.29（d）所示。

$
\begin{array}{cccccccc}
0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 \\
\hline
& & & & & & & & & & \\
\end{array}
$

(a) 插入前

$
\begin{array}{cccccccc}
& & & & & & & & \\
60 & 17 & 29 & 38 & & & & & & \\
\end{array}
$

(b) 线性探测法

$
\begin{array}{cccccccc}
& & & & & & & & \\
38 & 60 & 17 & 29 & & & & & \\
\end{array}
$

(c) 二次探测法

$
\begin{array}{cccccccc}
& & & & & & & & \\
38 & 60 & 17 & 29 & & & & & \\
\end{array}
$

(d) 伪随机探测法

图7.29 用开放地址法处理冲突时，关键字为38的记录插入前后的散列表

从上述线性探测法处理的过程中可以看到一个现象：当表中$i, i+1, i+2$位置上已填有记录时，下一个散列地址为$i, i+1, i+2和i+3$的记录都将填入$i+3$的位置，这种在处理冲突过程中发生的两个第一个散列地址不同的记录各向同于一个后继散列地址的现象称作“二次聚集”（或称作“堆积”），即在处理同义词的冲突过程中又添加了非同义词的冲突。

可以看出，上述3种处理方法各有优缺点。线性探测法的优点是：只要散列表未填满，总能找到一个不发生冲突的地址。缺点是：会产生“二次聚集”现象。而二次探测法和伪随机探测法的优点是：可以避免“二次聚集”现象。其缺点也很显然：不能保证一定找到不发生冲突的地址。

### 扩展并讲解知识点

#### 折叠法
折叠法是一种散列函数构造方法，适用于关键字位数较多且难以直接找到取值较分散的几位的情况。其基本思想是将关键字分割成位数相同的几部分（最后一部分的位数可以不同），然后取这几部分的叠加和（舍去进位）作为散列地址。折叠法分为两种：移位叠加和边界叠加。

- **移位叠加**：将分割后每一部分的最低位对齐，然后相加。
- **边界叠加**：将两个相邻的部分沿边界来回折叠，然后对齐相加。

例如，关键字 $ key = 45387765213 $，从左到右每3位分为一组，得到4个部分：$ 453, 877, 652, 13 $。分别采用移位叠加和边界叠加，求得散列地址为995和914。

#### 除留余数法
除留余数法是一种简单且常用的散列函数构造方法。其基本思想是选择一个不大于散列表表长 $ m $ 的数 $ p $，用 $ p $ 去除关键字，除后所得余数为散列地址，即：

$ H(key) = key\%p $

关键在于选取适当的 $ p $，通常选择小于表长的最大质数。例如，表长 $ m = 100 $，可取 $ p = 97 $。

#### 处理冲突的方法
处理冲突的方法主要分为两大类：开放地址法和链地址法。

##### 开放地址法
开放地址法的基本思想是当某一记录关键字 $ key $ 的初始散列地址 $ H_0 = H(key) $ 发生冲突时，以 $ H_0 $ 为基础，采取合适方法计算得到另一个地址 $ H_1 $，如果 $ H_1 $ 仍然发生冲突，继续寻找下一个地址 $ H_2 $，直至找到不发生冲突的地址。

- **线性探测法**：从冲突地址的下一单元顺序寻找空单元，如果到最后一个位置也没找到空单元，则回到表头开始继续查找。
- **二次探测法**：使用二次函数来寻找下一个地址。
- **伪随机探测法**：使用伪随机数序列来寻找下一个地址。

### 选择题

1. 折叠法的基本思想是什么？
   A. 将关键字分割成位数相同的几部分，然后取这几部分的叠加和（舍去进位）作为散列地址
   B. 将关键字直接取模
   C. 使用伪随机数序列
   D. 使用二次函数
   **答案：A**
   **解释：** 折叠法的基本思想是将关键字分割成位数相同的几部分，然后取这几部分的叠加和（舍去进位）作为散列地址。

2. 折叠法分为哪两种？
   A. 移位叠加和边界叠加
   B. 线性探测法和二次探测法
   C. 伪随机探测法和线性探测法
   D. 除留余数法和平方取中法
   **答案：A**
   **解释：** 折叠法分为移位叠加和边界叠加两种。

3. 除留余数法的关键是什么？
   A. 选择适当的 $ p $
   B. 使用伪随机数序列
   C. 使用二次函数
   D. 将关键字分割成位数相同的几部分
   **答案：A**
   **解释：** 除留余数法的关键是选择适当的 $ p $。

4. 开放地址法的基本思想是什么？
   A. 当某一记录关键字 $ key $ 的初始散列地址 $ H_0 = H(key) $ 发生冲突时，以 $ H_0 $ 为基础，采取合适方法计算得到另一个地址 $ H_1 $
   B. 将关键字直接取模
   C. 使用伪随机数序列
   D. 使用二次函数
   **答案：A**
   **解释：** 开放地址法的基本思想是当某一记录关键字 $ key $ 的初始散列地址 $ H_0 = H(key) $ 发生冲突时，以 $ H_0 $ 为基础，采取合适方法计算得到另一个地址 $ H_1 $。

5. 线性探测法的缺点是什么？
   A. 会产生“二次聚集”现象
   B. 不能保证一定找到不发生冲突的地址
   C. 计算复杂
   D. 需要大量内存
   **答案：A**
   **解释：** 线性探测法的缺点是会产生“二次聚集”现象。

6. 二次探测法的优点是什么？
   A. 可以避免“二次聚集”现象
   B. 计算简单
   C. 适用范围广
   D. 需要大量内存
   **答案：A**
   **解释：** 二次探测法的优点是可以避免“二次聚集”现象。

7. 伪随机探测法的缺点是什么？
   A. 不能保证一定找到不发生冲突的地址
   B. 会产生“二次聚集”现象
   C. 计算复杂
   D. 需要大量内存
   **答案：A**
   **解释：** 伪随机探测法的缺点是不能保证一定找到不发生冲突的地址。

8. 除留余数法适用于什么情况？
   A. 表长 $ m $ 较大
   B. 表长 $ m $ 较小
   C. 关键字位数较多
   D. 关键字位数较少
   **答案：A**
   **解释：** 除留余数法适用于表长 $ m $ 较大的情况。

9. 折叠法的适用情况是什么？
   A. 散列地址的位数较少，而关键字的位数较多
   B. 散列地址的位数较多，而关键字的位数较少
   C. 关键字位数较少
   D. 散列地址的位数较多
   **答案：A**
   **解释：** 折叠法的适用情况是散列地址的位数较少，而关键字的位数较多。

10. 线性探测法的优点是什么？
    A. 只要散列表未填满，总能找到一个不发生冲突的地址
    B. 可以避免“二次聚集”现象
    C. 计算简单
    D. 适用范围广
    **答案：A**
    **解释：** 线性探测法的优点是只要散列表未填满，总能找到一个不发生冲突的地址。

11. 二次探测法的缺点是什么？
    A. 不能保证一定找到不发生冲突的地址
    B. 会产生“二次聚集”现象
    C. 计算复杂
    D. 需要大量内存
    **答案：A**
    **解释：** 二次探测法的缺点是不能保证一定找到不发生冲突的地址。

12. 伪随机探测法的优点是什么？
    A. 可以避免“二次聚集”现象
    B. 计算简单
    C. 适用范围广
    D. 需要大量内存
    **答案：A**
    **解释：** 伪随机探测法的优点是可以避免“二次聚集”现象。

13. 除留余数法的关键是选择适当的什么？
    A. $ p $
    B. 伪随机数序列
    C. 二次函数
    D. 散列地址
    **答案：A**
    **解释：** 除留余数法的关键是选择适当的 $ p $。

14. 开放地址法中的“二次聚集”现象是什么？
    A. 在处理同义词的冲突过程中又添加了非同义词的冲突
    B. 计算复杂
    C. 需要大量内存
    D. 不能保证一定找到不发生冲突的地址
    **答案：A**
    **解释：** 开放地址法中的“二次聚集”现象是在处理同义词的冲突过程中又添加了非同义词的冲突。

15. 线性探测法的基本思想是什么？
    A. 从冲突地址的下一单元顺序寻找空单元
    B. 使用伪随机数序列
    C. 使用二次函数
    D. 将关键字分割成位数相同的几部分
    **答案：A**
    **解释：** 线性探测法的基本思想是从冲突地址的下一单元顺序寻找空单元。

16. 二次探测法的基本思想是什么？
    A. 使用二次函数来寻找下一个地址
    B. 使用伪随机数序列
    C. 将关键字分割成位数相同的几部分
    D. 将关键字直接取模
    **答案：A**
    **解释：** 二次探测法的基本思想是使用二次函数来寻找下一个地址。

17. 伪随机探测法的基本思想是什么？
    A. 使用伪随机数序列来寻找下一个地址
    B. 使用二次函数
    C. 将关键字分割成位数相同的几部分
    D. 将关键字直接取模
    **答案：A**
    **解释：** 伪随机探测法的基本思想是使用伪随机数序列来寻找下一个地址。

18. 除留余数法的计算简单吗？
    A. 是
    B. 否
    C. 有时简单，有时复杂
    D. 取决于 $ p $ 的选择
    **答案：A**
    **解释：** 除留余数法的计算是简单的。

19. 开放地址法中的“探测”是什么？
    A. 寻找“下一个”空的散列地址的过程
    B. 使用伪随机数序列
    C. 使用二次函数
    D. 将关键字分割成位数相同的几部分
    **答案：A**
    **解释：** 开放地址法中的“探测”是寻找“下一个”空的散列地址的过程。

20. 折叠法的优点是什么？
    A. 适用于散列地址的位数较少，而关键字的位数较多的情况
    B. 计算简单
    C. 适用范围广
    D. 需要大量内存
    **答案：A**
    **解释：** 折叠法的优点是适用于散列地址的位数较少，而关键字的位数较多的情况。

### 2 链地址法

链地址法的基本思想是：把具有相同散列地址的记录放在同一个单链表中，称之为同义词链表。有 \(m\) 个散列地址就有 \(m\) 个单链表，同时用数组 \(HT[0\cdots m-1]\) 存放各个链表的头指针，凡是散列地址为 \(i\) 的记录都以节点方式插入以 \(HT[i]\) 为头节点的单链表。

**【例7.2】** 已知一组关键字为 (19, 14, 23, 1, 68, 20, 84, 27, 55, 11, 10, 79)，设散列函数 \(H(key)=key \mod 13\) ，用链地址法处理冲突，试构造这组关键字的散列表。

由散列函数 \(H(key)=key \mod 13\) 得知散列地址的值域为 \(0 \sim 12\) ，故整个散列表由13个单链表组成，用数组 \(HT[0..12]\) 存放各个链表的头指针。如散列地址均为1的同义词14、1、27、79构成一个单链表，链表的头指针保存在 \(HT[1]\) 中，同理，可以构造其他几个单链表，整个散列表的结构如图7.30所示。

### 7.4.4 散列表的查找

在散列表上进行查找的过程和创建散列表的过程基本一致。算法7.10描述了开放地址法（线性探测法）处理冲突的散列表的查找过程。

#### 开放地址法散列表的存储表示

```c
#define m 20 // 散列表的表长
typedef struct{
    KeyType key; // 关键字项
    InfoType otherinfo; // 其他数据项
}HashTable[m];
```

#### 算法7.10 散列表的查找

**【算法步骤】**

1. 给定待查找的关键字 \(key\)，根据创建表时设定的散列函数计算 \(H_0 = H(key)\)。
2. 若单元 \(H_0\) 为空，则所查元素不存在。
3. 若单元 \(H_0\) 中元素的关键字为 \(key\)，则查找成功。
4. 否则重复下述解决冲突的过程：
   - 按处理冲突的方法，计算下一个散列地址 \(H_i\)；
   - 若单元 \(H_i\) 为空，则所查元素不存在；
   - 若单元 \(H_i\) 中元素的关键字为 \(key\)，则查找成功。

**【算法描述】**

```c
#define NULLKEY 0 // 单元为空的标记
int SearchHash(HashTable HT, KeyType key) {
    int H0 = H(key); // 根据散列函数 H(key) 计算散列地址
    if (HT[H0].key == NULLKEY) return -1; // 若单元 H0 为空，则所查元素不存在
    else if (HT[H0].key == key) return H0; // 若单元 H0 中元素的关键字为 key，则查找成功
    else {
        for (int i = 1; i < m; ++i) {
            int Hi = (H0 + i) % m; // 按照线性探测法计算下一个散列地址 Hi
            if (HT[Hi].key == NULLKEY) return -1; // 若单元 Hi 为空，则所查元素不存在
            else if (HT[Hi].key == key) return Hi; // 若单元 Hi 中元素的关键字为 key，则查找成功
        } // for
        return -1;
    } // else
}
```

**【算法分析】**

从散列表的查找过程可见：

1. 虽然散列表在关键字与记录的存储位置之间建立了直接映像，但由于“冲突”的产生，使得散列表的查找过程仍然是一个给定值和关键字进行比较的过程。因此，仍需以平均查找长度作为散列表查找效率的量度；
2. 查找过程中需和给定值进行比较的关键字的个数取决于3个因素，即散列函数、处理冲突的方法和散列表的装填因子。

散列表的装填因子 \(\alpha\) 定义为：

\[
\alpha = \frac{\text{表中填入的记录数}}{\text{散列表的长度}}
\]

\(\alpha\) 表示散列表的装填程度。直观地看，\(\alpha\) 越小，发生冲突的可能性就越小；反之，\(\alpha\) 越大，表中已填入的记录越多，再填记录时，发生冲突的可能性就越大，则查找时，给定值需与之进行比较的关键字的个数也就越多。

3. 散列函数的“好坏”首先影响出现冲突的频繁程度。但一般情况下认为：凡是“均匀”的散列函数，对同一组随机性的关键字，产生冲突的可能性相同。假如所设定的散列函数是“均匀”的，则影响平均查找长度的因素只有两个——处理冲突的方法和装填因子 \(\alpha\)。

### 扩展讲解

#### 链地址法

链地址法是一种处理散列表冲突的常用方法。其基本思想是将具有相同散列地址的记录存储在同一个单链表中，称为同义词链表。具体来说，假设散列表有 \(m\) 个散列地址，那么就会有 \(m\) 个单链表，每个链表的头指针存储在一个数组 \(HT[0\cdots m-1]\) 中。对于散列地址为 \(i\) 的记录，都会以节点的方式插入到以 \(HT[i]\) 为头节点的单链表中。

**示例**

考虑一组关键字 (19, 14, 23, 1, 68, 20, 84, 27, 55, 11, 10, 79)，使用散列函数 \(H(key) = key \mod 13\)。由于散列函数的值域为 \(0 \sim 12\)，因此散列表由13个单链表组成，数组 \(HT[0..12]\) 用于存储各个链表的头指针。例如，散列地址为1的同义词14、1、27、79会构成一个单链表，链表的头指针存储在 \(HT[1]\) 中。

#### 散列表的查找

散列表的查找过程与创建过程类似。首先，根据散列函数计算出待查找关键字的散列地址 \(H_0\)。如果该地址对应的单元为空，则查找失败；如果单元中的关键字与待查找关键字匹配，则查找成功。如果发生冲突，则按照处理冲突的方法（如线性探测法）计算下一个散列地址，直到找到匹配的关键字或确定查找失败。

**算法步骤**

1. 计算散列地址 \(H_0 = H(key)\)。
2. 检查 \(H_0\) 是否为空，若为空则查找失败。
3. 检查 \(H_0\) 中的关键字是否与 \(key\) 匹配，若匹配则查找成功。
4. 若发生冲突，按处理冲突的方法计算下一个散列地址 \(H_i\)，重复步骤2和3。

**算法描述**

```c
#define NULLKEY 0 // 单元为空的标记
int SearchHash(HashTable HT, KeyType key) {
    int H0 = H(key); // 计算散列地址
    if (HT[H0].key == NULLKEY) return -1; // 若单元为空，查找失败
    else if (HT[H0].key == key) return H0; // 若关键字匹配，查找成功
    else {
        for (int i = 1; i < m; ++i) {
            int Hi = (H0 + i) % m; // 线性探测法计算下一个散列地址
            if (HT[Hi].key == NULLKEY) return -1; // 若单元为空，查找失败
            else if (HT[Hi].key == key) return Hi; // 若关键字匹配，查找成功
        }
        return -1; // 查找失败
    }
}
```

**算法分析**

1. 散列表的查找过程仍然涉及关键字的比较，因此平均查找长度是衡量查找效率的指标。
2. 查找效率受散列函数、处理冲突的方法和装填因子 \(\alpha\) 的影响。
3. 装填因子 \(\alpha\) 表示散列表的装填程度，\(\alpha\) 越小，冲突可能性越小；\(\alpha\) 越大，冲突可能性越大。

### 选择题

1. **链地址法的基本思想是什么？**
   - A. 将所有记录存储在一个数组中
   - B. 将具有相同散列地址的记录存储在同一个单链表中
   - C. 使用二叉树存储记录
   - D. 使用哈希函数直接映射记录
   - **答案：B**
   - **解释：** 链地址法的基本思想是将具有相同散列地址的记录存储在同一个单链表中。

2. **在链地址法中，如何处理冲突？**
   - A. 使用线性探测法
   - B. 将冲突的记录存储在同一个单链表中
   - C. 使用二次探测法
   - D. 使用双重哈希法
   - **答案：B**
   - **解释：** 在链地址法中，冲突的记录会被存储在同一个单链表中。

3. **散列表的装填因子 \(\alpha\) 定义为？**
   - A. \(\alpha = \frac{\text{散列表的长度}}{\text{表中填入的记录数}}\)
   - B. \(\alpha = \frac{\text{表中填入的记录数}}{\text{散列表的长度}}\)
   - C. \(\alpha = \frac{\text{散列表的冲突数}}{\text{散列表的长度}}\)
   - D. \(\alpha = \frac{\text{散列表的查找次数}}{\text{散列表的长度}}\)
   - **答案：B**
   - **解释：** 装填因子 \(\alpha\) 定义为表中填入的记录数除以散列表的长度。

4. **散列表的查找效率主要取决于哪些因素？**
   - A. 散列函数、处理冲突的方法和装填因子
   - B. 散列函数、记录数和查找次数
   - C. 处理冲突的方法、记录数和查找次数
   - D. 散列函数、记录数和散列表的长度
   - **答案：A**
   - **解释：** 散列表的查找效率主要取决于散列函数、处理冲突的方法和装填因子。

5. **在散列表中，如果单元 \(H_0\) 为空，表示什么？**
   - A. 查找成功
   - B. 查找失败
   - C. 需要继续查找
   - D. 需要重新计算散列地址
   - **答案：B**
   - **解释：** 如果单元 \(H_0\) 为空，表示查找失败。

6. **在散列表中，如果单元 \(H_0\) 中的关键字与待查找关键字匹配，表示什么？**
   - A. 查找成功
   - B. 查找失败
   - C. 需要继续查找
   - D. 需要重新计算散列地址
   - **答案：A**
   - **解释：** 如果单元 \(H_0\) 中的关键字与待查找关键字匹配，表示查找成功。

7. **在散列表中，处理冲突的方法有哪些？**
   - A. 链地址法、线性探测法、二次探测法
   - B. 链地址法、双重哈希法、线性探测法
   - C. 链地址法、二次探测法、双重哈希法
   - D. 链地址法、线性探测法、双重哈希法
   - **答案：D**
   - **解释：** 处理冲突的方法包括链地址法、线性探测法和双重哈希法。

8. **在散列表中，装填因子 \(\alpha\) 越大，表示什么？**
   - A. 冲突可能性越小
   - B. 冲突可能性越大
   - C. 查找效率越高
   - D. 查找效率越低
   - **答案：B**
   - **解释：** 装填因子 \(\alpha\) 越大，表示表中已填入的记录越多，冲突可能性越大。

9. **在散列表中，装填因子 \(\alpha\) 越小，表示什么？**
   - A. 冲突可能性越小
   - B. 冲突可能性越大
   - C. 查找效率越高
   - D. 查找效率越低
   - **答案：A**
   - **解释：** 装填因子 \(\alpha\) 越小，表示表中已填入的记录越少，冲突可能性越小。

10. **在散列表中，散列函数的“好坏”主要影响什么？**
    - A. 查找效率
    - B. 冲突的频繁程度
    - C. 装填因子
    - D. 散列表的长度
    - **答案：B**
    - **解释：** 散列函数的“好坏”主要影响冲突的频繁程度。

11. **在散列表中，如果散列函数是“均匀”的，影响平均查找长度的因素有哪些？**
    - A. 处理冲突的方法和装填因子
    - B. 散列函数和装填因子
    - C. 处理冲突的方法和散列函数
    - D. 散列函数、处理冲突的方法和装填因子
    - **答案：A**
    - **解释：** 如果散列函数是“均匀”的，影响平均查找长度的因素只有处理冲突的方法和装填因子。

12. **在散列表中，线性探测法是如何计算下一个散列地址的？**
    - A. \(H_i = (H_0 + i^2) \% m\)
    - B. \(H_i = (H_0 + i) \% m\)
    - C. \(H_i = (H_0 + 2i) \% m\)
    - D. \(H_i = (H_0 + i/2) \% m\)
    - **答案：B**
    - **解释：** 线性探测法通过 \(H_i = (H_0 + i) \% m\) 计算下一个散列地址。

13. **在散列表中，二次探测法是如何计算下一个散列地址的？**
    - A. \(H_i = (H_0 + i^2) \% m\)
    - B. \(H_i = (H_0 + i) \% m\)
    - C. \(H_i = (H_0 + 2i) \% m\)
    - D. \(H_i = (H_0 + i/2) \% m\)
    - **答案：A**
    - **解释：** 二次探测法通过 \(H_i = (H_0 + i^2) \% m\) 计算下一个散列地址。

14. **在散列表中，双重哈希法是如何计算下一个散列地址的？**
    - A. \(H_i = (H_0 + i \cdot H'(key)) \% m\)
    - B. \(H_i = (H_0 + i) \% m\)
    - C. \(H_i = (H_0 + i^2) \% m\)
    - D. \(H_i = (H_0 + i/2) \% m\)
    - **答案：A**
    - **解释：** 双重哈希法通过 \(H_i = (H_0 + i \cdot H'(key)) \% m\) 计算下一个散列地址。

15. **在散列表中，如果使用链地址法，查找过程中需要遍历哪些数据结构？**
    - A. 数组
    - B. 单链表
    - C. 二叉树
    - D. 哈希表
    - **答案：B**
    - **解释：** 在链地址法中，查找过程中需要遍历单链表。

16. **在散列表中，如果使用开放地址法，查找过程中需要遍历哪些数据结构？**
    - A. 数组
    - B. 单链表
    - C. 二叉树
    - D. 哈希表
    - **答案：A**
    - **解释：** 在开放地址法中，查找过程中需要遍历数组。

17. **在散列表中，如果使用链地址法，如何确定查找失败？**
    - A. 遍历完所有单链表
    - B. 遍历完一个单链表
    - C. 遍历完数组
    - D. 遍历完二叉树
    - **答案：B**
    - **解释：** 在链地址法中，查找失败的条件是遍历完一个单链表且未找到匹配的关键字。

18. **在散列表中，如果使用开放地址法，如何确定查找失败？**
    - A. 遍历完所有数组单元
    - B. 遍历完一个数组单元
    - C. 遍历完所有单链表
    - D. 遍历完二叉树
    - **答案：A**
    - **解释：** 在开放地址法中，查找失败的条件是遍历完所有数组单元且未找到匹配的关键字。

19. **在散列表中，如果使用链地址法，如何确定查找成功？**
    - A. 找到匹配的关键字
    - B. 遍历完所有单链表
    - C. 遍历完一个单链表
    - D. 遍历完数组
    - **答案：A**
    - **解释：** 在链地址法中，查找成功的条件是找到匹配的关键字。

20. **在散列表中，如果使用开放地址法，如何确定查找成功？**
    - A. 找到匹配的关键字
    - B. 遍历完所有数组单元
    - C. 遍历完一个数组单元
    - D. 遍历完所有单链表
    - **答案：A**
    - **解释：** 在开放地址法中，查找成功的条件是找到匹配的关键字。

以下是将图片内容转换为MathJax格式的结果：

### 例7.3

对于例7.2中的关键字(19, 14, 23, 1, 68, 20, 84, 27, 55, 11, 10, 79)，仍设散列函数为\(H(key) = key \mod 13\)，用线性探测法处理冲突。设表长为16，试构造这组关键字的散列表，并计算查找成功和查找失败时的平均查找长度。

依次计算各个关键字的散列地址，如果没有冲突，将关键字直接存放在相应的散列地址所对应的单元中；否则，用线性探测法处理冲突，直到找到相应的存储单元。

如对于前3个关键字进行计算，\(H(19) = 6\)，\(H(14) = 1\)，\(H(23) = 10\)，所得散列地址均没有冲突，直接填入所在单元。

而对于第四个关键字，\(H(1) = 1\)，发生冲突，根据线性探测法，求得下一个地址\((1 + 1) \mod 16 = 2\)，没有冲突，所以填入序号为2的单元。

同理，可依次填入其他关键字。对于最后一个关键字79，\(H(79) = 1\)，发生冲突，用线性探测法处理冲突，后面的地址2～8均有冲突，最终79填入9号单元。

最终构造结果如表7.4所示，表中最后一行的数字表示放置该关键字时所进行的关键字比较次数。

表7.4 用线性探测法处理冲突时的散列表

\[
\begin{array}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
\hline
\text{散列地址} & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 & 14 & 15 \\
\hline
\text{关键字} & 14 & 1 & 68 & 27 & 55 & 19 & 20 & 84 & 79 & 23 & 11 & 10 & & & & \\
\hline
\text{比较次数} & 1 & 2 & 1 & 4 & 3 & 1 & 1 & 3 & 9 & 1 & 1 & 3 & & & & \\
\hline
\end{array}
\]

要查找一个关键字\(key\)，根据算法7.10，首先用散列函数计算\(H_0 = H(key)\)，然后进行比较，比较的次数和创建散列表时放置此关键字的比较次数是相同的。

例如，查找19时，计算散列函数\(H(19) = 6\)，\(HT[6].key\)非空且值为19，查找成功，关键字比较次数为1次。

同样，当查找关键字14、68、20、23、11时，均只需比较1次即查找成功。

当查找关键字1时，计算散列函数\(H(1) = 1\)，\(HT[1].key\)非空且值为14≠1，用线性探测法处理冲突，计算下一个地址为\((1 + 1) \mod 16 = 2\)，\(HT[2].key\)非空且值为1，查找成功，关键字比较次数为2。

当查找关键字55、84、10时，需比较3次；当查找27时，需比较4次；而查找79时，需要比较9次才能查找成功。

在记录的查找概率相等的前提下，这组关键字采用线性探测法处理散列表冲突时，查找成功时的平均查找长度为：

\[
ASL_{\text{suc}} = \frac{1}{12} \times (1 \times 6 + 2 + 3 \times 3 + 4 + 9) = 2.5
\]

查找失败时有两种情况：

（1）单元为空；

（2）按处理冲突的方法探测一遍后仍未找到。假设散列函数的取值个数为\(r\)，则0~\(r-1\)相当于\(r\)个查找失败的入口，从每个入口进入后，直到确定查找失败为止，其关键字的比较次数就是与该入口对应的查找失败的查找长度。

在例7.3中，散列函数的取值个数为13，即总共有13个查找失败的入口（0~12），对每个入口依次进行计算。

假设待查找的关键字不在表中，若计算散列函数\(H(key) = 0\)，\(HT[0].key\)为空，比较1次即确定查找失败。若 \(H(key) = 1\) ， \(HT[1].key\) 非空，则依次向后比较，直到 \(HT[13].key\) 为空，总共比较13次才能确定查找失败。类似地，对 \(H(key) = 2,\,3,\cdots,\,12\) 进行分析，可得查找失败的平均查找长度为：

\[
ASL_{\text{unsuc}} = \frac{1}{13} \times (1 + 13 + 12 + 11 + 10 + 9 + 8 + 7 + 6 + 5 + 4 + 3 + 2) = 7
\]

在例 7.2 中，采用链地址法处理冲突时，对于图 7.30 中所示的每个单链表中的第 \(i\) 个节点的关键字（如 14、68、19、20、23、11），查找成功时只需比较 \(i\) 次；而对于第 2 个节点的关键字（如 1、55、84、10），查找成功时需比较 2 次；第 3 个节点的关键字 27 需比较 3 次；第 4 个节点的关键字 79 则需比较 4 次才能查找成功。这时，查找成功时的平均查找长度为：

\[
ASL_{\text{suc}} = \frac{1}{12} \times \big{(}1 \times 6 + 2 \times 4 + 3 + 4\big{)} = 1.75
\]

采用链地址法处理冲突时，待查的关键字不在表中，若计算散列函数 \(H(key) = 0\) ， \(HT[0]\) 的指针域为空，比较 1 次即确定查找失败。若 \(H(key) = 1\) ， \(HT[1]\) 所指的单链表包括 4 个节点，所以需要比较 5 次才能确定失败。类似地，对 \(H(key) = 2,\,3,\cdots,\,12\) 进行分析，可得查找失败的平均查找长度为：

\[
ASL_{\text{unsuc}} = \frac{1}{13} \times (1 + 5 + 1 + 3 + 1 + 1 + 3 + 2 + 1 + 1 + 3 + 2 + 1) \approx 1.92
\]

容易看出，线性探测法在处理冲突的过程中易产生记录的二次聚集，使得散列地址不相同的记录又产生新的冲突；而链地址法处理冲突不会发生类似情况，因为散列地址不同的记录在不同的链表中，所以链地址法的平均查找长度小于开放地址法的。另外，由于链地址法的节点空间是动态申请的，无须事先确定表的容量，因此更适用于表长不确定的情况。同时，链地址法易于实现插入和删除操作。

通过上面的示例，可以看出，在查找概率相等的前提下，直接计算查找成功的平均查找长度可以采用以下公式：

\[
ASL_{\text{suc}} = \frac{1}{n} \sum_{i=1}^{n} C_i \tag{7-7}
\]

其中，\( n \)为散列表中记录的个数，\( C_i \)为成功查找第\( i \)个记录所需的比较次数。

而直接计算查找失败的平均查找长度可以采用以下公式：

\[
ASL_{\text{unsuc}} = \frac{1}{r} \sum_{i=1}^{r} C_i \tag{7-8}
\]

其中，\( r \)为散列函数取值的个数，\( C_i \)为散列函数取值为时查找失败的比较次数。

### 7.5 小结

查找是数据处理中经常使用的一种操作。本章主要介绍了对查找表的查找，查找表实际上仅仅是一个集合，为了提高查找效率，将查找表组织成不同的数据结构，主要包括3种不同结构的查找表：线性表、树表和散列表。

（1）线性表的查找。基于线性表的查找方法主要包括顺序查找、折半查找和分块查找，3者之间的比较详见表7.5。

表7.5 顺序查找、折半查找和分块查找的比较

\[
\begin{array}{|c|c|c|c|}
\hline
\text{比较项目} & \text{顺序查找} & \text{查找方法} & \text{分块查找} \\
\hline
\text{查找时间复杂度} & O(n) & O(\log n) & \text{与确定所在块的查找方法有关} \\
\hline
\text{特点} & \text{算法简单，对表结构无任何要求，但查找效率较低} & \text{对表结构要求较高，查找效率较高} & \text{对表结构有一定要求，查找效率介于折半查找和顺序查找之间} \\
\hline
\text{适用情况} & \text{任何结构的线性表，不经常进行插入和删除} & \text{有序的顺序表，不经常进行插入和删除} & \text{共同有序、块内无序的顺序表，经常进行插入和删除} \\
\hline
\end{array}
\]

（2）树表的查找。树表的结构主要包括二叉排序树、平衡二叉树、B-树和B+树。
① 二叉排序树的查找过程与折半查找的过程类似，二者之间的比较见表7.6。

表7.6 折半查找和二叉排序树查找的比较

\[
\begin{array}{|c|c|c|c|}
\hline
\text{比较项目} & \text{折半查找} & \text{查找方法} & \text{二叉排序树的查找} \\
\hline
\text{查找时间复杂度} & O(\log n) & O(\log n) & \\
\hline
\text{特点} & \text{数据结构采用有序的顺序表，进行插入和删除操作需移动大量元素} & \text{数据结构采用树的二叉链表表示，进行插入和删除操作无需移动元素，只需修改指针} & \\
\hline
\text{适用情况} & \text{不经常进行插入和删除的静态查找表} & \text{经常进行插入和删除的动态查找表} & \\
\hline
\end{array}
\]

② 二叉排序树在形态均匀时性能最好，而当其形态为单支树时其查找性能则退化为与顺序查找的性能相同，因此，二叉排序树最好是平衡二叉树。平衡二叉树的平衡调整方法就是确保二叉排序树在任何情况下的深度均为\(O(\log n)\)，平衡调整方法分为4种：LL型、RR型、LR型和RL型。
③ B-树是一种平衡的多叉查找树，是一种在外存文件系统中常用的动态索引技术。在B-树上进行查找的过程和在二叉排序树上进行查找的过程类似，是一个顺指针查找节点和查找节点内的关键字交叉进行的过程。为了确保B-树的定义，在B-树中插入一个关键字，可能产生节点的“分裂”；而删除一个关键字，可能产生节点的“合并”。

④ B+ 树是一种B-树的变形，更适合做文件系统的索引。在B+树上进行随机查找、插入和删除的过程基本上与在B-树上进行类似，但具体实现细节又有所区别。

（3）散列表的查找。散列表也属线性结构，但它的查找和线性表的查找有着本质的区别。它不是以关键字比较为基础进行查找的，而是通过散列函数把记录的关键字和它在表中的位置建立起对应关系，并在存储记录发生冲突时采用专门的处理冲突的方法。这种方式构造的散列表，不仅平均查找长度和记录总数无关，而且可以通过调节装填因子，把平均查找长度控制在所需的范围内。

散列查找法主要研究两方面的问题：如何构造散列函数，以及如何处理冲突。

① 构造散列函数的方法很多，除留余数法是最常用的构造散列函数的方法。它不仅可以对关键字直接取模，也可在折叠、平方取中等运算之后取模。

② 处理冲突的方法通常分为两大类，即开放地址法和链地址法，二者之间的差别类似于顺序表和单链表的差别，二者的比较详见表7.7。

表7.7 开放地址法和链地址法的比较

\[
\begin{array}{|c|c|c|c|}
\hline
\text{比较项目} & & \text{处理方法} & \\
\hline
 & & \text{开放地址法} & \text{链地址法} \\
\hline
\text{空间} & & \text{无指针域，存储效率较高} & \text{附加指针域，存储效率较低} \\
\hline
\text{时间} & \text{查找} & \text{有二次聚集现象，查找效率较低} & \text{无二次聚集现象，查找效率较高} \\
\hline
 & \text{插入、删除} & \text{不易实现} & \text{易于实现} \\
\hline
\text{适用情况} & & \text{表的大小固定，适于表长无变化的情况} & \text{节点动态生成，适于表长经常变化的情况} \\
\hline
\end{array}
\]

学习完本章后，读者应掌握顺序查找、折半查找和分块查找的方法，掌握描述折半查找过程的决策树的构造方法；掌握二叉排序树的构造和查找方法，平衡二叉树的4种平衡调整方法；理解B-和B+ 树的特点、基本操作和二者的区别；熟练掌握散列表的构造方法；明确各种不同查找方法之间的区别和各自的适用情况，能够按定义计算各种查找方法在等概率情况下查找成功的平均查找长度。

### 扩展与讲解

#### 散列函数与冲突处理

散列函数是将关键字映射到散列表中的特定位置的函数。常见的散列函数包括除留余数法、折叠法、平方取中等。在本例中，使用的散列函数是除留余数法，即 \( H(key) = key \mod 13 \)。

冲突是指两个不同的关键字通过散列函数计算得到相同的散列地址。处理冲突的方法主要有两种：开放地址法和链地址法。

- **开放地址法**：当发生冲突时，通过一定的探测序列（如线性探测、二次探测、双重散列等）寻找下一个可用的地址。线性探测法是其中最简单的一种，即当发生冲突时，顺序地检查下一个地址，直到找到一个空闲的位置。

- **链地址法**：每个散列地址对应一个链表，所有散列到同一地址的关键字都存储在该链表中。这种方法不会产生二次聚集现象，且易于实现插入和删除操作。

#### 平均查找长度（ASL）

平均查找长度是衡量散列表查找效率的一个重要指标，分为查找成功时的平均查找长度（\( ASL_{\text{suc}} \)）和查找失败时的平均查找长度（\( ASL_{\text{unsuc}} \)）。

- **查找成功时的平均查找长度**：在查找概率相等的前提下，查找成功时所需的平均比较次数。公式为：
  \[
  ASL_{\text{suc}} = \frac{1}{n} \sum_{i=1}^{n} C_i
  \]
  其中，\( n \)为散列表中记录的个数，\( C_i \)为成功查找第\( i \)个记录所需的比较次数。

- **查找失败时的平均查找长度**：在查找概率相等的前提下，查找失败时所需的平均比较次数。公式为：
  \[
  ASL_{\text{unsuc}} = \frac{1}{r} \sum_{i=1}^{r} C_i
  \]
  其中，\( r \)为散列函数取值的个数，\( C_i \)为散列函数取值为\( i \)时查找失败的比较次数。

#### 线性探测法与链地址法的比较

- **线性探测法**：
  - **优点**：实现简单，不需要额外的存储空间。
  - **缺点**：容易产生二次聚集现象，导致查找效率下降。
  - **适用情况**：表的大小固定，适用于表长无变化的情况。

- **链地址法**：
  - **优点**：无二次聚集现象，查找效率较高，易于实现插入和删除操作。
  - **缺点**：需要额外的指针域，存储效率较低。
  - **适用情况**：节点动态生成，适用于表长经常变化的情况。

### 选择题

1. **在散列表中，散列函数的作用是什么？**
   - A. 将关键字映射到表中的特定位置
   - B. 处理冲突
   - C. 计算平均查找长度
   - D. 确定表的大小
   - **答案**：A
   - **解释**：散列函数的主要作用是将关键字映射到表中的特定位置。

2. **线性探测法处理冲突时，如果发生冲突，下一步应该怎么做？**
   - A. 重新计算散列函数
   - B. 顺序检查下一个地址
   - C. 使用链表存储冲突的关键字
   - D. 增加表的大小
   - **答案**：B
   - **解释**：线性探测法处理冲突时，顺序检查下一个地址，直到找到一个空闲的位置。

3. **在查找成功时，平均查找长度（ASL）的计算公式是什么？**
   - A. \( ASL_{\text{suc}} = \frac{1}{n} \sum_{i=1}^{n} C_i \)
   - B. \( ASL_{\text{unsuc}} = \frac{1}{r} \sum_{i=1}^{r} C_i \)
   - C. \( ASL_{\text{suc}} = \frac{1}{r} \sum_{i=1}^{r} C_i \)
   - D. \( ASL_{\text{unsuc}} = \frac{1}{n} \sum_{i=1}^{n} C_i \)
   - **答案**：A
   - **解释**：查找成功时的平均查找长度公式为 \( ASL_{\text{suc}} = \frac{1}{n} \sum_{i=1}^{n} C_i \)。

4. **在查找失败时，平均查找长度（ASL）的计算公式是什么？**
   - A. \( ASL_{\text{suc}} = \frac{1}{n} \sum_{i=1}^{n} C_i \)
   - B. \( ASL_{\text{unsuc}} = \frac{1}{r} \sum_{i=1}^{r} C_i \)
   - C. \( ASL_{\text{suc}} = \frac{1}{r} \sum_{i=1}^{r} C_i \)
   - D. \( ASL_{\text{unsuc}} = \frac{1}{n} \sum_{i=1}^{n} C_i \)
   - **答案**：B
   - **解释**：查找失败时的平均查找长度公式为 \( ASL_{\text{unsuc}} = \frac{1}{r} \sum_{i=1}^{r} C_i \)。

5. **线性探测法在处理冲突时，容易产生什么现象？**
   - A. 二次聚集现象
   - B. 链表过长
   - C. 散列函数失效
   - D. 表大小不足
   - **答案**：A
   - **解释**：线性探测法在处理冲突时，容易产生二次聚集现象，导致查找效率下降。

6. **链地址法在处理冲突时，不会产生什么现象？**
   - A. 二次聚集现象
   - B. 链表过长
   - C. 散列函数失效
   - D. 表大小不足
   - **答案**：A
   - **解释**：链地址法在处理冲突时，不会产生二次聚集现象，因为每个散列地址对应一个链表。

7. **在链地址法中，查找成功时的平均查找长度与什么有关？**
   - A. 链表的长度
   - B. 散列函数的选择
   - C. 表的大小
   - D. 冲突的处理方法
   - **答案**：A
   - **解释**：在链地址法中，查找成功时的平均查找长度与链表的长度有关。

8. **在开放地址法中，查找失败时的平均查找长度与什么有关？**
   - A. 散列函数的取值个数
   - B. 表的大小
   - C. 冲突的处理方法
   - D. 链表的长度
   - **答案**：A
   - **解释**：在开放地址法中，查找失败时的平均查找长度与散列函数的取值个数有关。

9. **在散列表中，装填因子是什么？**
   - A. 表中记录的个数与表的大小的比值
   - B. 散列函数的取值个数
   - C. 冲突的处理方法
   - D. 查找成功时的平均查找长度
   - **答案**：A
   - **解释**：装填因子是表中记录的个数与表的大小的比值。

10. **在散列表中，如何通过调节装填因子来控制平均查找长度？**
    - A. 增加表的大小
    - B. 减少表的大小
    - C. 选择不同的散列函数
    - D. 使用链地址法
    - **答案**：A
    - **解释**：通过增加表的大小，可以降低装填因子，从而控制平均查找长度。

11. **在散列表中，除留余数法是一种常见的散列函数，它的公式是什么？**
    - A. \( H(key) = key \mod m \)
    - B. \( H(key) = key \times m \)
    - C. \( H(key) = key + m \)
    - D. \( H(key) = key / m \)
    - **答案**：A
    - **解释**：除留余数法的公式是 \( H(key) = key \mod m \)。

12. **在散列表中，线性探测法的探测序列是什么？**
    - A. 1, 2, 3, ...
    - B. 1, 4, 9, ...
    - C. 1, 3, 5, ...
    - D. 1, 2, 4, ...
    - **答案**：A
    - **解释**：线性探测法的探测序列是 1, 2, 3, ...。

13. **在散列表中，链地址法的优点是什么？**
    - A. 无二次聚集现象
    - B. 存储效率高
    - C. 表的大小固定
    - D. 查找效率低
    - **答案**：A
    - **解释**：链地址法的优点是无二次聚集现象，查找效率较高。

14. **在散列表中，开放地址法的缺点是什么？**
    - A. 有二次聚集现象
    - B. 存储效率低
    - C. 表的大小不固定
    - D. 查找效率高
    - **答案**：A
    - **解释**：开放地址法的缺点是有二次聚集现象，查找效率较低。

15. **在散列表中，查找成功时的平均查找长度与什么有关？**
    - A. 表中记录的个数
    - B. 散列函数的取值个数
    - C. 冲突的处理方法
    - D. 链表的长度
    - **答案**：A
    - **解释**：查找成功时的平均查找长度与表中记录的个数有关。

16. **在散列表中，查找失败时的平均查找长度与什么有关？**
    - A. 散列函数的取值个数
    - B. 表的大小
    - C. 冲突的处理方法
    - D. 链表的长度
    - **答案**：A
    - **解释**：查找失败时的平均查找长度与散列函数的取值个数有关。

17. **在散列表中，如何计算查找成功时的平均查找长度？**
    - A. \( ASL_{\text{suc}} = \frac{1}{n} \sum_{i=1}^{n} C_i \)
    - B. \( ASL_{\text{unsuc}} = \frac{1}{r} \sum_{i=1}^{r} C_i \)
    - C. \( ASL_{\text{suc}} = \frac{1}{r} \sum_{i=1}^{r} C_i \)
    - D. \( ASL_{\text{unsuc}} = \frac{1}{n} \sum_{i=1}^{n} C_i \)
    - **答案**：A
    - **解释**：查找成功时的平均查找长度公式为 \( ASL_{\text{suc}} = \frac{1}{n} \sum_{i=1}^{n} C_i \)。

18. **在散列表中，如何计算查找失败时的平均查找长度？**
    - A. \( ASL_{\text{suc}} = \frac{1}{n} \sum_{i=1}^{n} C_i \)
    - B. \( ASL_{\text{unsuc}} = \frac{1}{r} \sum_{i=1}^{r} C_i \)
    - C. \( ASL_{\text{suc}} = \frac{1}{r} \sum_{i=1}^{r} C_i \)
    - D. \( ASL_{\text{unsuc}} = \frac{1}{n} \sum_{i=1}^{n} C_i \)
    - **答案**：B
    - **解释**：查找失败时的平均查找长度公式为 \( ASL_{\text{unsuc}} = \frac{1}{r} \sum_{i=1}^{r} C_i \)。

19. **在散列表中，链地址法的适用情况是什么？**
    - A. 表的大小固定
    - B. 节点动态生成
    - C. 表长无变化
    - D. 查找效率低
    - **答案**：B
    - **解释**：链地址法适用于节点动态生成的情况，即表长经常变化。

20. **在散列表中，开放地址法的适用情况是什么？**
    - A. 表的大小固定
    - B. 节点动态生成
    - C. 表长无变化
    - D. 查找效率高
    - **答案**：A
    - **解释**：开放地址法适用于表的大小固定的情况，即表长无变化。

