### 二叉排序树

二叉排序树是递归定义的。由定义可以得出二叉排序树的一个重要性质：中序遍历一棵二叉树时可以得到一个节点值递增的有序序列。

例如，图7.5所示为两棵二叉排序树。

若中序遍历图7.5（a），则可得到一个按数值大小排序的递增序列：
\[ 3, 12, 24, 37, 45, 53, 61, 78, 90, 100 \]

若中序遍历图7.5（b），则可得到一个按字符大小排序的递增序列：
\[ CAO, CHEN, DING, DU, LIMA, WANG, XIA, ZHAO \]

在下面讨论二叉排序树的操作中，使用二叉链表作为存储结构。因为二叉排序树的操作要根据节点的关键字域来进行，所以下面给出了每个节点的数据域的类型定义（包括关键字项和其他数据项）。

```cpp
//- - - - 二叉排序树的二叉链表存储表示- - - -
typedef struct {
    KeyType key; //关键字项
    InfoType otherinfo; //其他数据项
} ElemType; //每个节点的数据域的类型

typedef struct BSTNode {
    ElemType data; //每个节点的数据域包括关键字项和其他数据项
    struct BSTNode *lchild, *rchild; //左右孩子指针
} BSTNode, *BSTree;
```

### 二叉排序树的查找

因为二叉排序树可以看成一个有序表，所以在二叉排序树上进行查找和折半查找类似，也是一个逐步缩小查找范围的过程。

**算法7.4 二叉排序树的递归查找**

【算法步骤】

1. 若二叉排序树为空，则查找失败，返回空指针。
2. 若二叉排序树非空，将给定值key与根节点的关键字T->data.key进行比较：
   - 若key等于T->data.key，则查找成功，返回根节点地址；
   - 若key小于T->data.key，则递归查找左子树；
   - 若key大于T->data.key，则递归查找右子树。

【算法描述】

```cpp
BSTree SearchBST(BSTree T, KeyType key)
//在根指针T所指二叉排序树中递归地查找某关键字等于key的数据元素
//若查找成功，则返回指向该数据元素节点的指针，否则返回空指针
{
    if ((!T) || key == T->data.key) return T; //查找结束
    else if (key < T->data.key) return SearchBST(T->lchild, key); //在左子树中继续查找
    else return SearchBST(T->rchild, key); //在右子树中继续查找
}
```

例如，在图7.5（a）所示的二叉排序树中查找关键字等于100的记录（树中节点内的数均为记录的关键字）。首先以key = 100和根节点的关键字进行比较，因为key > 45，则查找以45为根的右子树，此时右子树不空，且key > 53，则继续查找以节点100为根的右子树，由于key和53的右子树根的关键字100相等，因此查找成功，返回指向节点100的指针值。又如在图7.5（a）中查找关键字等于40的记录，和上述过程类似，在给定值key与关键字45、12及37相继比较之后，继续查找以节点37为根的右子树，此时右子树为空，则说明该树中没有待查记录，故查找不成功，返回指针值为NULL。

【算法分析】

从上述的两个查找例子（key = 100和key = 40）可见，在二叉排序树上查找其关键字等于给定值的节点的过程，恰是走了一条从根节点到该节点的路径的过程，和给定值比较的关键字个数等于路径长度加1（或节点所在层次数）。因此，和折半查找类似，与给定值比较的关键字个数不超过树的深度。然而，折半查找长度为n的顺序表的决策树是唯一的，而含有n个节点的二叉排序树却不唯一。图7.6中的两棵二叉排序树中节点的值都相同，但创建这两棵树的序列不同，分别是(45, 24, 53, 12, 37, 93)和(12, 24, 37, 45, 53, 93)。图7.6（a）中树的深度为3，而图7.6（b）中树的深度为6。再从平均查找长度来看，假设6个记录的查找概率相等，为1/6，则图7.6（a）中树的平均查找长度为

\[ ASL_{00} = \frac{1}{6}[1 + 2 + 2 + 3 + 3 + 3] = 14/6 \]

而图7.6（b）中树的平均查找长度为

\[ ASL_{00} = \frac{1}{6}[1 + 2 + 3 + 4 + 5 + 6] = 21/6 \]

因此，含有n个节点的二叉排序树的平均查找长度和树的形态有关。当先后插入的关键字有序时，构成的二叉排序树变为单支树。树的深度为n，其平均查找长度为 \(\frac{n+1}{2}\)（和顺序查找相同），这是最差的情况。显然，最好的情况是，二叉排序树的形态和折半查找的决策树的形态相似，其平均查找长度和log_{n}成正比。若考虑把n个节点按各种可能的次序插入二叉排序树中，则有n！棵二叉排序树（其中有的形态相同）。可以证明，综合所有可能的情况，就平均而言，二叉排序树的平均查找长度仍然和log_{n}是同数量级的。

可见，二叉排序树上的查找和折半查找相差不大。但就维护表的有序性而言，二叉排序树更加有效，因为无须移动记录，只需修改指针即可完成对节点的插入和删除操作。因此，对于需要经常进行插入、删除和查找运算的表，采用二叉排序树比较好。

### 二叉排序树的插入

二叉排序树的插入操作是以查找为基础的。要将一个关键字为key的节点*S插入二叉排序树中，则需要从根节点向下查找，当树中不存在关键字等于key的节点时才进行插入。新插入的节点一定是一个新添加的叶子节点，并且是查找不成功时查找路径上访问的最后一个节点的左孩子或右孩子节点。

**算法7.5 二叉排序树的插入**

【算法步骤】

1. 若二叉排序树为空，则将待插入节点*S作为根节点插入空树。
2. 若二叉排序树非空，则将key与根节点的关键字T->data.key进行比较：
   - 若key小于T->data.key，则将*S插入左子树；
   - 若key大于T->data.key，则将*S插入右子树。

【算法描述】

```cpp
void InsertBST(BSTree &T, ElemType e)
//当二叉排序树 T 中不存在关键字等于 e.key 的数据元素时，则插入该元素
{
    if (!T) { //找到插入位置，递归结束
        S = new BSTNode; //生成新节点 *S
        S->data = e; //新节点 *S 的数据域置为 e
        S->lchild = S->rchild = NULL; //新节点 *S 作为叶子节点
        T = S; //把新节点 *S 链接到已找到的插入位置
    } else if (e.key < T->data.key)
        InsertBST(T->lchild, e); //将 *S 插入左子树
    else if (e.key > T->data.key)
        InsertBST(T->rchild, e); //将 *S 插入右子树
}
```

例如，在图7.5（a）所示的二叉排序树上插入关键字为55的节点，由于插入前二叉排序树非空，因此，将55和根节点45进行比较，因55 > 45，则应将55插入45的右子树；又和45的右子树的根53比较，因55 > 53，则应将55插入53的右子树；依次类推，直至最后55 < 61，且61的左子树为空，将55作为61的左孩子插入树中。结果如图7.7所示。

【算法分析】
二叉排序树插入的基本过程是查找，所以时间复杂度同查找一样，是O(log_n)。

### 二叉排序树的创建

二叉排序树的创建是从空的二叉排序树开始的，每输入一个节点，经过查找操作，将新节点插入当前二叉排序树的合适位置。

**算法7.6 二叉排序树的创建**

【算法步骤】

1. 将二叉排序树T初始化为空树。
2. 读入一个关键字为key的节点。
3. 如果读入的关键字key不是输入结束标志，则循环执行以下操作：
   - 将此节点插入二叉排序树T中；
   - 读入一个关键字为key的节点。

【算法描述】

```cpp
void CreatBST(BSTree &T)
//依次读入关键字为key的节点，将相应节点插入二叉排序树T中
{
    T = NULL; //将二叉排序树T初始化为空树
    cin >> e;
    while (e.key != ENDFLAG) { //ENDFLAG为自定义常量，作为输入结束标志
        InsertBST(T, e); //将此节点插入二叉排序树T中
        cin >> e;
    }
}
```

【算法分析】
假设有n个节点，则需要n次插入操作，而插入一个节点的算法时间复杂度为\(O(\log n)\)，所以创建二叉排序树算法的时间复杂度为\(O(n\log n)\)。

例如，设关键字的输入序列为45, 24, 53, 45, 12, 24, 90，按上述算法生成二叉排序树的过程如图7.8所示。

\[\begin{array}{cccc}
\text{(a) 空树} & \text{(b) 插入45} & \text{(c) 插入24} & \text{(d) 插入53} \\
\end{array}\]

\[\begin{array}{cccc}
\text{(e) 插入12} & \text{(f) 插入90} \\
\end{array}\]

图7.8 生成二叉排序树的过程

容易看出，一个无序序列可以通过构造一棵二叉排序树而变成一个有序序列，构造树的过程即对无序序列进行排序的过程。不仅如此，从上面的插入过程还可以看到，每次插入的新节点都是二叉排序树上新的叶子节点，则在进行插入操作时，不必移动其他节点，仅需改动某个节点的指针，使其指向空节点变为指向非空节点即可。这就相当于在一个有序序列上插入一个记录而不需要移动其他记录。

### 二叉排序树的删除

被删除的节点可能是二叉排序树中的任何节点，删除节点后，要根据其位置不同修改其双亲节点及相关节点的指针，以保持二叉排序树的特性。

**算法7.7 二叉排序树的删除**

【算法步骤】

首先从二叉排序树的根节点开始查找关键字为key的待删节点，如果树中不存在此节点，则不做任何操作；否则，假设被删节点为*p（指向节点的指针为p），其双亲节点为*f（指向节点的指针为f），P和P分别表示其左子树和右子树[见图7.9（a）]。

不失一般性，可设*p是*f的左孩子（右孩子情况类似）。下面分3种情况进行讨论。

（1）若*p节点为叶子节点，即P和P均为空树。由于删去叶子节点不破坏整棵树的结构，因此只需修改其双亲节点的指针即可：

\[ f->lchild = NULL; \]

（2）若*p节点只有左子树P或者只有右子树P，此时只要令P或P直接成为其双亲节点的左子树即可：

\[ f->lchild = p->lchild; \quad (或f->lchild = p->rchild;) \]

（3）若*p节点的左子树和右子树均不空。从图7.9（b）可知，在删去*p节点之前，中序遍历该二叉树得到的序列为\(C_1, C_2, ..., Q_0, S, P_1, P_2, F, ...\)，在删去*p之后，为保持其他元素之间的相对位置不变，可以有两种处理方法：

① 令*p的左子树为*f的左子树，而*p的右子树为*s的右子树，如图7.9（c）所示。

\[ f->lchild = p->lchild; \quad s->rchild = p->rchild; \]

② 令*p的直接前驱（或直接后继）替代*p，然后再从二叉排序树中删去它的直接前驱（或直接后继）。如图7.9（d）所示，当以直接前驱*s替代*p时，由于*s只有左子树S₁，因此在删去*s之后，只要令S₁为*s的双亲*q的右子树即可。

(a) 删除*p的子树

(b) 删除*p之前

(c) 删除*p之后，以P₁作为*s的右子树的情形

(d) 删除*p之后，以*s替代*p的情形

图7.9 在二叉排序树中删除*p

显然，前一种处理方法可能增加树的深度，而后一种方法是以被删节点左子树中关键字最大的节点替代被删节点，然后从左子树中删除这个节点。此节点一定没有右子树（否则它就不是左子树中关键字最大的节点），这样不会增加树的高度，所以常采用这种处理方案。下面的算法描述即采用这种方案。

【算法描述】

```cpp
void DeleteBST(BSTree &T, KeyType key)
//从二叉排序树T中删除关键字等于key的节点
{
    p = T; f = NULL; //初始化
    //下面的while循环从根开始查找关键字等于key的节点*p
    while (p) {
        if (p->data.key == key) break; //找到关键字等于key的节点*p，结束循环
        f = p; //*f为*p的双亲节点
        if (p->data.key > key) p = p->lchild; //在*p的左子树中继续查找
        else p = p->rchild; //在*p的右子树中继续查找
    } //while
    if (!p) return; //找不到被删节点则返回
    /*---考虑到3种情况实现p所指子树内部的处理：*p左右子树均不空、无右子树、无左子树----*/
    q = p;
    if ((p->lchild) && (p->rchild)) { //被删节点*p左右子树均不空
        s = p->lchild;
        while (s->rchild) { //在*p的左子树中继续查找其前驱节点，即最右下节点
            q = s; s = s->rchild; //向右到尽头
        }
        p->data = s->data; //s指向被删节点的“前驱”
        if (q != p) q->rchild = s->lchild; //重接*q的右子树
        else q->lchild = s->lchild; //重接*q的左子树
        delete s;
        return;
    } else if (!p->rchild) { //被删节点*p无右子树，只需重接其左子树
        p = p->lchild;
    } else if (!p->lchild) { //被删节点*p无左子树，只需重接其右子树
        p = p->rchild;
    } //else if
    /*---将p所指的子树挂接到其双亲节点*f相应的位置---*/
    if (!f) T = p; //被删节点为根节点
    else if (q == f->lchild) f->lchild = p; //挂接到*f的左子树位置
    else f->rchild = p; //挂接到*f的右子树位置
    delete q;
}
```

【算法分析】
同二叉排序树插入一样，二叉排序树删除的基本过程也是查找，所以时间复杂度仍是O(log_n)。

根据算法7.7，图7.10给出了二叉排序树删除的3种情况。

缺右子树用左孩子填补       缺左子树用右孩子填补         在左子树上找中序

Lb       Lb     最后一个节点填补
©       @
©   Qa @   DP 4   5
65 @6o68
68% @&
a @
Ca) 被删节点缺右子树       Cb) 被删节点缺左子树       Co) 被删节点左、右子树都存在

图7.10 二叉排序树的删除

### 平衡二叉树

1. 平衡二叉树的定义
二叉排序树查找算法的性能取决于二叉树的结构，而二叉排序树的形状则取决于其数据集。如果数据有序排列，则二叉排序树是线性的，查找的时间复杂度为 \(O(n)\)；反之，如果二叉排序树的结构合理，则查找速度较快，查找的时间复杂度为 \(O(\log n)\)。事实上，树的高度越小，查找速度越快。因此，希望二叉树的高度尽可能小。本节将讨论一种特殊类型的二叉排序树，称为平衡二叉树（Balanced Binary Tree或Height-Balanced Tree），因由苏联数学家阿德尔森-维尔斯基（Adelson-Velskii）和兰迪斯（Landis）提出，所以又称AVL树。
平衡二叉树或者是空树，或者是具有如下特征的二叉排序树：
（1）左子树和右子树的深度之差的绝对值不超过1；
（2）左子树和右子树也是平衡二叉树。
若将二叉树上节点的平衡因子（Balance Factor，BF）定义为该节点左子树和右子树的深度之差，则平衡二叉树上所有节点的平衡因子只可能是-1、0和1。只要二叉树上有一个节点的平衡因子的绝对值大于1，则该二叉树就是不平衡的。图7.11（a）所示为两棵平衡二叉树，而图7.11（b）所示为两棵不平衡的二叉树，节点中的值为该节点的平衡因子。

（a）平衡二叉树

图7.11 平衡与不平衡的二叉树及节点的平衡因子

因为AVL树上任何节点的左右子树的深度之差都不超过1，则可以证明它的深度和log_{n}是同数量级的（其中n为节点个数）。由此，其查找的时间复杂度是O(log_{n})。

2. 平衡二叉树的平衡调整方法

如何创建一棵平衡二叉树呢？插入节点时，首先按照二叉排序树处理，若插入节点后破坏了平衡二叉树的特性，需对平衡二叉树进行调整。调整方法是：找到离插入节点最近且平衡因子绝对值超过1的祖先节点，以该节点为根的子树称为最小不平衡子树，可将重新平衡的范围局限于这棵子树。

先看一个具体例子（见图7.12）。假设表中关键字序列为(13, 24, 37, 90, 53)。

\[\begin{array}{cccc}
 & 13 & 21 & 22 \\
(a) \text{空树} & (b) \text{插入13} & (c) \text{插入24} & (d) \text{插入37} \\
\end{array}\]

\[\begin{array}{cccc}
 & 12 & 23 & 25 \\
(e) \text{向左逆时针旋转平衡} & (f) \text{相继插入90和53} \\
\end{array}\]

\[\begin{array}{cccc}
 & 11 & 14 & 16 \\
(g) \text{第一次向右顺时针旋转} & (h) \text{第二次向左逆时针旋转平衡} \\
\end{array}\]

图7.12 平衡树的生成过程

(1) 空树和只有1个节点13的树显然都是平衡的二叉树。在插入24之后树仍是平衡的，只是根节点的平衡因子由0变为-1，如图7.12（a）～（e）所示。
(2) 在继续插入37之后，由于节点13的平衡因子由-1变成-2，因此出现了不平衡的现象。

此时好比一根扁担出现一头重、一头轻的现象，若能将扁担的支撑点由13或至24，扁担的两头就平衡了。由此，可以对树做一个向左逆时针“旋转”的操作，令节点24为根，而节点13为它的左子树，此时，节点13和节点24的平衡因子都为0，而且仍保持二叉排序树的特性，如图7.12（d）～（e）所示。

（3）在继续插入节点90和节点53之后，节点37的平衡因子由-1变成-2，排序树中出现了新的不平衡现象，需进行调整。但此时由于节点53插在节点90的左子树上，因此不能如上进行简单调整。离插入节点最近的最小不平衡子树是以节点37为根的子树。这时，必须以节点53作为根节点，而使节点37成为它的左子树的根，使节点90成为它的右子树的根。这好比对树做了两次旋转操作，先向右顺时针旋转，后向左逆时针旋转[见图7.12（f）～（h）]，使二叉排序树的不平衡转化为平衡。

一般情况下，假设最小不平衡子树的根节点为A，则失去平衡后进行调整的规律可归纳为下列4种情况。

（1）LL型：由于在A左子树根节点的左子树上插入节点，A的平衡因子由1增至2，致使以A为根的子树失去平衡，因此需进行一次向右的顺时针旋转操作，如图7.13所示。

图7.13 LL型调整操作示意

图7.14所示为两个LL型调整的示例。

(a) 插入前B₁、B₂、A₁均为空树

(b) 插入前B₃、B₄、A₄均为非空树

图7.14 LL型调整示例

（2）RR型：由于在A的右子树根节点的右子树上插入节点，A的平衡因子由-1变为-2，致使以A为根节点的子树失去平衡，因此需进行一次向左的逆时针旋转操作，如图7.15所示。

插人节点

图7.15 RR型调整操作示意

第7章 查找

(a) MARITAL. Buy Bolus            (b ) 插入前A,、B,、B均为非空树
A716 RRB
(3) LRM: 由于在A的左子树根节点的右子树上插入节点，A的平衡因子由1增至2，致使
以A为根节点的子树失去平衡，因此需进行两次旋转操作。第一次对B及其右子树进行道时针
旋转，C转上去成为B的根，这时变成了LL型，所以第二次进行LL型的顺时针旋转即可恢复平
衡。如果C原来有左子树，则调整C的左子树为B的右子树，如图7.17所示。

 7.17 LR型调整操作示意

LR型旋转前后A、B、C这3个节点平衡因子的变化分为3种情况，图7.18所示为3种LR型调整的示例。

\[\begin{array}{cccccc}
 & 1 & 2 & 0 & 1 & 2 \\
 & 31 & 31 & 28 & 9 & 11 \\
 & 25 & 25 & 21 & 10 & 15 \\
\end{array}\]

(a) LR (0) 型

(b) LR (L) 型

(c) LR (R) 型

图7.18 LR型调整示例

（4）RL型：由于在A的右子树根节点的左子树上插入节点，A的平衡因子由-1变为-2，致

（4）RL型：由于在A的右子树根节点的左子树上插入节点，A的平衡因子由-1变为-2，致使以A为根节点的子树失去平衡，因此旋转方法和LR型的旋转方法相“对称”，也需进行两次旋转，先顺时针向右旋转，再逆时针向左旋转，如图7.19所示。

图7.19 RL型调整操作示意

同LR型旋转类似，RL型旋转前后A、B、C这3个节点的平衡因子的变化也分为3种情况，图7.20所示为3种RL型调整的示例。

上述4种情况中，（1）和（2）对称，（3）和（4）对称。旋转操作的正确性容易由“保持二叉排序树的特性：中序遍历所得关键字序列自小至大有序”证明。同时，无论哪一种情况，在经过平衡旋转处理之后，以B或C为根的新子树为平衡二叉树，而且它们的深度和插入之前以A为根的子树相同。因此，当平衡的二叉排序树因插入节点而失去平衡时，仅需对最小不平衡子树进行平衡旋转处理即可。因为经过旋转处理之后子树的深度和插入之前的相同，因而不影响插入路径上所有祖先节点的平衡度。

3. 平衡二叉搜索树的插入

在平衡二叉搜索树（Balanced Binary Search Tree，BBST）上插入一个新的数据元素的递归算法可描述如下。

①若BBST为空树，则插入一个数据元素为e的新节点作为BBST的根节点，树的深度增1。

②若e的关键字和BBST的根节点的关键字相等，则不进行插入。

③若e的关键字小于BBST的根节点的关键字，而且在BBST的左子树中不存在和e有相同关

键字的节点，则将e插入在BBST的左子树上，并且当插入之后的左子树深度增加（+1）时，分

别就下列不同情况处理：

·BBST的根节点的平衡因子为-1（右子树的深度大于左子树的深度）：将根节点的平衡

因子更改为0，BBST的深度不变；

·BBST的根节点的平衡因子为0（左、右子树的深度相等）：将根节点的平衡因子更改

为1，BBST的深度增1；

·BBST的根节点的平衡因子为1（左子树的深度大于右子树的深度）：若BBST的左子树

根节点的平衡因子为1，则需进行单向右旋平衡处理，并且在右旋处理之后，将根节点和其右子

树根节点的平衡因子更改为0，树的深度不变；

·若BBST的左子树根节点的平衡因子为-1，则需进行先向左、后向右的双向旋转平衡处

理，并且在旋转处理之后修改根节点和其左、右子树根节点的平衡因子，树的深度不变。

④若e的关键字大于BBST的根节点的关键字，而且在BBST的右子树中不存在和e有相同关

键字的节点，则将e插入在BBST的右子树上，并且当插入之后的右子树深度增加（+1）时，分

别就不同情况处理。其处理操作和③中所述相对称，读者可自行补充。

### B-树

前面介绍的查找方法均适用于存储在计算机内存中较小的文件，统称为内查找法。若文

件很大且存放于外存进行查找时，这些查找方法就不适用了。内查找法都以节点为单位进行查

我，这样需要反复地进行内、外存的交换，是很费时的。1970年，鲁道夫·拜尔（R.Bayer）和
E·麦克雷特（E.Mcereight）提出了一种适用于外查找的平衡多叉树——B-树，磁盘管理系统
中的目录管理，以及数据库系统中的索引组织多数都采用B-树这种数据结构。

1. B-树的定义

一棵m阶的B-树，或为空树，或为满足下列特性的m叉树：
（1）树中每个节点至多有m棵子树；
（2）若根节点不是叶子节点，则至少有两棵子树；
（3）除根之外的所有非终端节点至少有m/2棵子树；
（4）所有的叶子节点都出现在同一层次上，并且不带信息，通常称为失败节点（失败节点
并不存在，指向这些节点的指针为空。引入失败节点是为了便于分析B-树的查找性能）；
（5）所有的非终端节点最多有m－1个关键字，节点的结构如图7.21所示。

\[\begin{array}{cccccccc}
n & p_n & k_1 & p_1 & k_2 & p_2 & \cdots & k_m & p_n \\
\end{array}\]

图7.21 B-树的节点结构

其中，\( K(i=1, \cdots, n) \) 为关键字，且 \( K<K_{n+1}(i=1, \cdots, n-1) \); \( P(i=0, \cdots, n) \) 为指向子树根节点的指针，
且指针 \( P_n \) 所指子树中所有节点的关键字均小于 \( K(i=1, \cdots, n) \)。P_i 所指子树中所有节点的关键字均
大于 \( K_{n+1} \)，而 \( m(1-1\leq n\leq m-1) \) 为关键字的个数（或 \( n+1 \) 为子树个数）。
从上述定义可以看出，对任一关键字 \( K_i \) 而言，\( P_n \) 相当于指向其“左子树”，P_i 相当于指向
其“右子树”。
B-树具有平衡、有序、多路的特点，图7.22所示为一棵m阶的B-树，能很好地说明其特点。

图7.22 一棵4阶的B-树

（1）所有叶子节点均在同一层次，这体现出其平衡的特点。
（2）树中每个节点中的关键字都是有序的，且关键字“左子树”中的关键字均小于K，
而其“右子树”中的关键字均大于K，这体现出其有序的特点。
（3）除叶子节点外，有的节点中有一个关键字、两棵子树，有的节点中有两个关键字、3
棵子树，这种4阶的B-树最多有3个关键字、4棵子树，这体现出其多路的特点。
在具体实现时，为记录其双亲节点，B-树节点的存储结构通常增加一个parent指针，指向
其双亲节点，存储结构示意如图7.23所示。

| parent | n | K₁ | K₂ | ... | Kₙ | P₀ | P₂ | ... | Pₙ |
|---|---|---|---|---|---|---|---|---|---|

图7.23 B-树节点的存储结构示意

2. B-树的查找

由B-树的定义可知，在B-树上进行查找的过程和二叉排序树查找的过程类似。
例如，在图7.22所示的B-树上查找关键字47的过程中：首先从根开始，根据根节点指针t找到“a”节点，因“a”节点只有一个关键字，且47>35。若查找的记录存在，则必在指针P_所指的子树内，顺指针找到“e”节点，该节点有两个关键字（43和78），而43<47<78。若查找的记录存在，则必在指针P_所指的子树中。同样，顺指针找到“g”节点，在该节点中顺序查找，找到关键字47，由此，查找成功。

查找不成功的过程也类似。例如，在同一棵树中查找23。从根开始，因为23<35，则顺该节点指针P_找到“b”节点，又因为“b”节点只有一个关键字18，且23>18，所以顺节点中第二个指针P_找到“e”节点。同理，因为23<27，则顺指针往下找，此时因指针所指为叶子节点，说明此棵B-树中不存在关键字23，查找以失败而告终。

由此可见，在B-树上进行查找的过程是一个顺指针查找节点，和查找节点的关键字交叉进行的过程。

由于B-树主要用于文件的索引，因此它的查找涉及外存的存取，在此略去外存的读写，只做示意性的描述。假设节点类型定义如下：

```cpp
#define m 3    // B-树的阶，暂设为3
typedef struct BTNode {
    int keynum;    // 节点中关键字的个数，即节点的大小
    struct BTNode *parent;    // 指向双字节点
    KeyType K[m+1];    // 关键字向量，0号单元未用
    struct BTNode *ptr[m+1];    // 子树指针向量
    Record *recptr[m+1];    // 记录指针向量，0号单元未用
} BTNode, *BTree;

typedef struct {
    BTNode *pt;    // 指向找到的节点
    int i;    // 1~m，在节点中的关键字序号
    int tag;    // 1表示查找成功，0表示查找失败
} Result;    // B-树的查找结果类型
```

**算法7.8 B-树的查找**

【算法步骤】

将给定值key与根节点的各个关键字K，K，，K（1≤≤m-1）进行比

较，由于该关键字序列是有序的，因此查找时可采用顺序查找，也可采用折半

查找。查找时：

①若key=K，（1≤≤j），则查找成功；

B-树的查找

②若key<K，则顺着指针P所指向的子树继续向下查找；

③若K<key<K，（1≤≤j-1），则顺着指针P所指向的子树继续向下查找；

④若key>K，则顺着指针P所指向的子树继续向下查找。

如果在自上而下的查找过程中，找到了值为key的关键字，则查找成功；如果直到叶子节点

也未找到值为key的关键字，则查找失败。

【算法描述】

```cpp
Result SearchBTree(BTree T, KeyType key)
//在m阶B-树T上查找关键字key，返回结果（pt, i, tag)
//若查找成功，则特征值tag=1，指针pt所指节点中第i个关键字等于key
//否则特征值tag=0，等于key的关键字应插入在指针pt所指节点中第i个和第i+1个关键字之间
{
    p = T; q = NULL; found = FALSE; i = 0;
    while (p && !found) {
        i = Search(p, key);
        //在p->K[1..keynum]中查找i，使得p->K[i]<=key<p->K[i+1]
        if (i > 0 && p->K[i] == key) found = TRUE;    //找到待查关键字
        else { q = p; p = p->ptr[i]; }
    }
    if (found) return {p, i, 1};    //查找成功
    else return {q, i, 0};    //查找不成功，返回key的插入位置信息
}
```

【算法分析】
从算法7.8可见，在B-树上进行查找包含两种基本操作：①在B-树中找节点；②在节点中找关键字。由于B-树通常存储在磁盘上，则前一查找操作是在磁盘上进行的（在算法7.8中没有体现），而后一查找操作是在内存中进行的，即在磁盘上找到指针所指节点后，先将节点中的信息读入内存，然后利用顺序查找或折半查找查询等于key的关键字。显然，在磁盘上进行一次查找比在内存中进行一次查找花费的时间多出很多，因此，在磁盘上进行查找的次数，即待查关键字所在节点在B-树上的层次数，是决定B-树查找效率的首要因素。
现考虑最坏的情况，即待查节点在B-树的最高下面一层。也就是说，含N个关键字的m阶B-树的最大深度是多少？
先看一棵3阶的B-树。按B-树上的定义，3阶的B-树上所有非终端节点至多有两个关键字，至少有一个关键字（子树个数为2或3，故又称2-3树）。因此，当关键字个数小于等于2

先看一棵3阶的B-树。按B-树上的定义，3阶的B-树上所有非终端节点至多有两个关键字，至少有一个关键字（子树个数为2或3，故又称2-3树）。因此，当关键字个数小于等于2时，树的深度为2（叶子节点层次为2）；当关键字个数小于等于6时，树的深度不超过3。反之，若B-树的深度为4，则关键字的个数必须大于等于7[见图7.24（g）]，此时，每个节点都含有可能的关键字的最小数目。

\[\begin{array}{cccc}
 & N=0 &  & N=1 \\
(a) & (b) & (c) & (d) \\
\end{array}\]

\[\begin{array}{cccc}
 & N=2 &  & N=5 \\
(c) & (d) & (e) & (f) \\
\end{array}\]

图7.24 不同关键字数目的B-树

一般情况的分析可类似于第二叉树进行，先讨论深度为\( h+1 \)的\( m \)阶B-树所具有的最少节

点数。

根据B-树的定义，第一层至少有1个节点；第二层至少有2个节点；由于除根之外的每个非终端节点至少有\(m/2\)棵子树，则第三层至少有\(2(m/2)\)个节点；依次类推，第\(n+1\)层至少有\(2(m/2)^{k-1}\)个节点。而\(n+1\)层的节点为叶子节点。若\(m\)阶B-树中具有N个关键字，则叶子节点数即查找不成功的节点数为\(N+1\)，由此有：

\[N+1\geq 2\times (m/2)^{k-1}\]

反之：

\[h\leq \log_{m/2}\left(\frac{N+1}{2}\right)+1\]

这就是说，在含有N个关键字的B-树上进行查找时，从根节点到关键字所在节点的路径上涉及的节点数不超过\(\log_{m/2}\left(\frac{N+1}{2}\right)+1\)。

3. B-树的插入

B-树是动态查找树，因此其是从空树起，在查找的过程中通过逐个插入关键字而得到。但由于B-树中除根之外的所有非终端节点中的关键字个数必须大于等于\([m/2]-1\)，因此，每次插入一个关键字不是在树中添加一个叶子节点，而是首先在根底层的某个非终端节点中添加一个关键字。若该节点的关键字个数不超过\(m-1\)，则插入完成，否则表明节点已满，需要进行节点的“分裂”，将此节点在同一层分成两个节点。一般情况下，节点分裂方法是：以中间关键字为界把节点一分为二，并把中间关键字向上插入双亲节点上，若双亲节点已满，则采用同样的方法继续分裂。最坏的情况下，一直分裂到树根节点，这时B-树高度增加1。

例如，图7.25（a）所示为3阶的B-树（图中略去节点，即叶子节点），假设需依次插入关键字30、26、85和7。首先通过查找确定应插入的位置。由根*a起进行查找，确定30应插入在*d节点中，由于*d中关键字数目不超过2（即m=1），因此第一个关键字插入完成。插入30后的B-树如图7.25（b）所示。同样，通过查找确定关键字26应插入在*d节点中。由于*d中关键字数目超过2，此时需将*d分裂成两个节点，关键字26及其前、后两个指针仍保留在*d节点中，而关键字37及其前、后两个指针存储到新产生的节点*d中。同时，将关键字30和指示节点*d的指针插入到其双亲节点中。由于*b节点中的关键字数目没有超过2，则插入完成。插入26后的B-树如图7.25（c）和图7.25（d）所示。类似地，在*g中插入85之后需分裂成两个节点，如图7.25（e）和图7.25（f）所示。而当70继而插入双亲节点时，由于*e中关键字数目超过2，则分裂为节点*e和*e'，如图7.25（g）所示。最后在插入关键字7时，*e、*h和*a相继分裂，并生成一个新的根节点*m，如图7.25（h）～（j）所示。

\[\begin{array}{cc}
 &  \\
(a) \text{—} \text{根} > \text{3树} & (b) \text{—} \text{根} > \text{3树} \\
\end{array}\]

图7.25 在B-树中进行插入（省略叶子节点）

**算法7.9 B-树的插入**

【算法步骤】

① 在B-树中查找给定关键字的记录，若查找成功，则插入操作失败，否则将新记录作为空指针ap插入查找失败的叶子节点的上一层节点（由q指向）。

② 若插入新记录和空指针后，q指向的节点的关键字个数未超过m-1，则插入操作成功，否则转入步骤③。

③ 以该节点的第\( m/2 \)个关键字\( K_{m/2} \)为拆分点，将该节点分成3个部分：\( K_{m/2} \)左边部分、\( K_{m/2} \)、\( K_{m/2} \)右边部分。\( K_{m/2} \)左边部分仍然保留在原节点中；\( K_{m/2} \)右边部分存放在一个新创建的节点（由q指向）中；关键字为\( K_{m/2} \)的记录和指针ap插入的双亲节点。因q的双亲节点增加一个新的记录，所以必须对q的双亲节点重复②和③的操作，依次类推，直至由q指向的节点是根节点，转入步骤④。

④ 由于根节点无双亲，则其分裂产生的两个节点的指针ap和q，以及关键字为\( K_{m/2} \)的记录构成一个新的根节点。此时，B-树的高度增加1。

下面算法描述中的q和q是由查找函数SearchBTree返回的信息而得。

【算法描述】

```cpp
Status InsertBTree(BTree &T, KeyType key, BTree q, int i)
//在m阶B-树T上节点*q的K[i]与K[i+1]之间插入关键字key
//若引起节点过大，则沿双亲链进行必要的节点分裂调整，使T仍是m阶B-树
{
    x = key; ap = NULL; finished = FALSE;
    //x表示新插入的关键字，ap为一个空指针
    while (q && !finished) {
        if (q->keynum < m) finished = TRUE; //插入完成
        else {
            insert(q, i, x, ap);
            //将x和ap分别插入q->key[i+1]和q->ptr[i+1]
            //分裂节点
            i = (m + 1) / 2;
            x = q->K[i];
            split(q, i, ap);
            q = q->parent;
        }
    }
    if (!finished) NewRoot(T, q, x, ap); //生成含信息（T, x, ap）的新的根节点*r，原T和ap为子树指针
    return OK;
}
```

4. B-树的删除

m阶B-树的删除操作，是指在B-树的某个节点中删除指定的关键字及其邻近的一个指针，

删除后应该进行调整使该树仍然满足B-树的定义，也就是要保证每个节点的关键字数目区间为
\[ [m/2] - 1, m \]。删除记录后，节点的关键字个数如果小于\[ m/2] - 1 \]，则要进行“合并”节点的
操作。除了删除记录，还要删除该记录邻近的指针。若该节点为最下层的非终端节点，由于其
指针均为空，删除后不会影响其他节点，可直接删除；若该节点不是最下层的非终端节点，其
邻近的指针则指向一棵子树，不可直接删除。此时可做如下处理：将要删除记录用共有（左）
边邻近指针指向的子树中关键字最小（大）的记录（该记录必定在最下层的非终端节点中）替
换。采取这种方法进行处理，无论要删除的记录所在的节点是否为最下层的非终端节点，都可
归结为在最下层的非终端节点中删除记录的情况。
例如，在图7.25（a）所示的B-树上删去45，可以用"节点中的50替代45，然后在"节点中
删去50。因此，下面可以只讨论删除最下层非终端节点中的关键字的情形。有以下3种可能。
（1）被删关键字所在节点中的关键字数目不小于\[ m/2 \]，则只需从该节点中删去关键字和
相应指针，树的其他部分不变。例如，从图7.25（a）所示B-树中删去关键字12，删除后的B-
树如图7.26（a）所示。
（2）被删关键字所在节点中的关键字数目等于\[ m/2] - 1 \]，而与该节点相邻的右兄弟（或左
兄弟）节点中的关键字数目大于\[ m/2] - 1 \]，则需将其兄弟节点中的最小（或最大）关键字上移
至双亲节点中，而将双亲节点中小于（或大于）且紧靠该上移关键字的关键字下移至被删关键
字所在节点中。例如，从图7.26（a）中删去50，需将其右兄弟节点中的61上移至"节点中，而
将"节点中的53移至"，从而使"和"中关键字数目均不小于\[ m/2] - 1 \]，而双亲节点中的关键字
数目不变，如图7.26（b）所示。
（3）被删关键字所在节点和相邻的兄弟节点中的关键字数目均等于\[ m/2] - 1 \]。假设该节
点有右兄弟，且其右兄弟节点地址由双亲节点中的指针P所指，则在删去关键字之后，它所在

节点中剩余的关键字和指针，加上双亲节点中的关键字K，一起合并到所指的兄弟节点中（若没有右兄弟，则合并至左兄弟节点中）。例如，从图7.26（b）所示B-树中删去53，则应删去“f”节点，并将“f”的剩余信息（指针“空”）和双亲“e”节点中的6i一起合并到右兄弟节点“g”中，删除后的树如图7.26（c）所示。如果因此使双亲节点中关键字数目小于\[m/2\] - 1，则依次类推做相应处理。例如，在图7.26（c）的B-树中删去关键字37之后，双亲节点“b”中剩余信息（指针c）应和其双亲节点“a”中关键字45一起合并至右兄弟节点“e”中，删除后的B-树如图7.26（d）所示。

\[\begin{array}{cc}
 &  \\
(a) & (b) \\
\end{array}\]

在B-树中删除节点的算法在此不详述，读者可根据上述讨论自行写出此算法。

### 7.3.4 B+ 树

B+ 树是一种B-树的变形树，更适合用于文件索引系统。严格来讲，它已不是第5章中定义的树了。

#### 1. B+ 树和 B- 树的差异

一棵m阶的B+树和m阶的B-树的差异在于：
（1）有n棵子树的节点中含有n个关键字；
（2）所有的叶子节点中包含了全部关键字的信息，以及指向含这些关键字记录的指针，且叶子节点本身依关键字的大小自小而大顺序链接；
（3）所有的非终端节点可以看成索引部分，节点中仅含有其子树（根节点）中的最大（或最小）关键字。
例如，图7.27所示为一棵3阶的B+树，通常在B+树上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点。因此，可以对B+树进行两种查找运算：一种是从最小关键字起顺序查找；另一种是从根节点开始，进行随机查找。

\[
\begin{array}{cc}
 &  \\
\text{root} & \text{root} \\
\end{array}
\]

\[
\begin{array}{cc}
 &  \\
\text{sqt} & \text{sqt} \\
\end{array}
\]

\[
\begin{array}{cc}
 &  \\
\text{图7.27 一棵3阶的B+树} & \text{图7.27 一棵3阶的B+树} \\
\end{array}
\]

### 2. B+ 树的查找、插入和删除

在B+树上进行随机查找、插入和删除的过程基本上与B-树类似。

（1）查找：若非终端节点上的关键字等于给定值，并不终止，而是继续向下直到叶子节点。因此，在B+树中，不管查找成功与否，每次查找都走一条从根到叶子节点的路径。B+树查找的分析类似于B-树。

B+树不仅能够有效地查找单个关键字，而且更适合查找某个范围内的所有关键字。例如，在B+树上找出值在[a,b]内的所有关键字。处理方法如下：通过一次查找找出关键字a，不管它是否存在，都可以到达可能出现的叶子节点，然后在叶子节点中查找值等于a或大于a的那些关键字，对于所找到的每个关键字都有一个指针指向相应的记录，这些记录的关键字在所需要的范围。如果在当前节点中没有发现大于b的关键字，就可以使用当前叶子节点的最后一个指针找到下一个叶子节点，并继续进行同样的处理，直至在某个叶子节点中找到大于b的关键字，才停止查找。

（2）插入：仅在叶子节点上进行插入，当节点中的关键字个数大于m时要分裂成两个节点，它们所含关键字的个数分别为\[ \frac{m+1}{2} \]和\[ \frac{m+1}{2} \]；并且，它们的双亲节点中应同时包含这两个节点中的最大关键字。

（3）删除：B+树的删除也仅在叶子节点进行，当叶子节点中最大关键字被删除时，其在非终端节点中的值可以作为一个“分界关键字”存在。当因删除而使节点中关键字的个数少于\[ m/2 \]时，其和兄弟节点的合并过程亦和B-树类似。