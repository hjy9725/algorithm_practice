### 7.3 树表的查找

前面介绍的3种查找方法都是用线性表作为查找表的组织形式，其中折半查找效率较高。但由于折半查找要求表中记录按关键字有序排列，且不能用链表作为存储结构，因此，当表的插入或删除操作频繁时，为维护表的有序性，需要移动表中很多记录。这种由移动记录引起的额外时间开销，就会抵消折半查找的优点。所以，线性表的查找更适用于静态查找表；若要对动态查找表进行高效率的查找，可采用几种特殊的二叉树作为查找表的组织形式，在此将它们统称为树表。本节将介绍在这些树表上进行查找和修改操作的方法。

#### 7.3.1 二叉排序树

二叉排序树（Binary Sort Tree）又称二叉查找树，它是一种对排序和查找都很有用的特殊二叉树。

1. **二叉排序树的定义**

二叉排序树或者是一棵空树，或者是具有下列性质的二叉树。
（1）若它的左子树不空，则左子树上所有节点的值均小于它的根节点的值；
（2）若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值；
（3）它的左、右子树也分别为二叉排序树。

### 二叉排序树

二叉排序树是递归定义的。由定义可以得出二叉排序树的一个重要性质：中序遍历一棵二叉树时可以得到一个节点值递增的有序序列。

例如，图7.5所示为两棵二叉排序树。

若中序遍历图7.5（a），则可得到一个按数值大小排序的递增序列：
\[ 3, 12, 24, 37, 45, 53, 61, 78, 90, 100 \]

若中序遍历图7.5（b），则可得到一个按字符大小排序的递增序列：
\[ CAO, CHEN, DING, DU, LIMA, WANG, XIA, ZHAO \]

在下面讨论二叉排序树的操作中，使用二叉链表作为存储结构。因为二叉排序树的操作要根据节点的关键字域来进行，所以下面给出了每个节点的数据域的类型定义（包括关键字项和其他数据项）。

```cpp
// 二叉排序树的二叉链表存储表示
typedef struct {
    KeyType key; // 关键字项
    InfoType otherinfo; // 其他数据项
} ElemType; // 每个节点的数据域的类型

typedef struct BSTNode {
    ElemType data; // 每个节点的数据域包括关键字项和其他数据项
    struct BSTNode *lchild, *rchild; // 左右孩子指针
} BSTNode, *BSTree;
```

### 二叉排序树的查找

因为二叉排序树可以看成一个有序表，所以在二叉排序树上进行查找和折半查找类似，也是一个逐步缩小查找范围的过程。

算法7.4 二叉排序树的递归查找

【算法步骤】
1. 若二叉排序树为空，则查找失败，返回空指针。
2. 若二叉排序树非空，将给定值key与根节点的关键字T->data.key进行比较：
   - 若key等于T->data.key，则查找成功，返回根节点地址；
   - 若key小于T->data.key，则递归查找左子树；
   - 若key大于T->data.key，则递归查找右子树。

【算法描述】
```cpp
BSTree SearchBST(BSTree T, KeyType key)
// 在根指针T所指二叉排序树中递归地查找某关键字等于key的数据元素
// 若查找成功，则返回指向该数据元素节点的指针，否则返回空指针
{
    if ((!T) || key == T->data.key) return T; // 查找结束
    else if (key < T->data.key) return SearchBST(T->lchild, key); // 在左子树中继续查找
    else return SearchBST(T->rchild, key); // 在右子树中继续查找
}
```

### 二叉排序树的插入

二叉排序树的插入操作是以查找为基础的。要将一个关键字为key的节点*S插入二叉排序树中，则需要从根节点向下查找，当树中不存在关键字等于key的节点时才进行插入。新插入的节点一定是一个新添加的叶子节点，并且是查找不成功时查找路径上访问的最后一个节点的左孩子或右孩子节点。

算法7.5 二叉排序树的插入

【算法步骤】
1. 若二叉排序树为空，则将待插入节点*S作为根节点插入空树。
2. 若二叉排序树非空，则将key与根节点的关键字T->data.key进行比较：
   - 若key小于T->data.key，则将*S插入左子树；
   - 若key大于T->data.key，则将*S插入右子树。

【算法描述】
```cpp
void InsertBST(BSTree &T, ElemType e)
// 当二叉排序树T中不存在关键字等于e.key的数据元素时，则插入该元素
{
    if (!T) { // 找到插入位置，递归结束
        S = new BSTNode; // 生成新节点*S
        S->data = e; // 新节点*S的数据域置为e
        S->lchild = S->rchild = NULL; // 新节点*S作为叶子节点
        T = S; // 把新节点*S链接到已找到的插入位置
    } else if (e.key < T->data.key)
        InsertBST(T->lchild, e); // 将*S插入左子树
    else if (e.key > T->data.key)
        InsertBST(T->rchild, e); // 将*S插入右子树
}
```

### 二叉排序树的创建

二叉排序树的创建是从空的二叉排序树开始的，每输入一个节点，经过查找操作，将新节点插入当前二叉排序树的合适位置。

算法7.6 二叉排序树的创建

【算法步骤】
1. 将二叉排序树T初始化为空树。
2. 读入一个关键字为key的节点。
3. 如果读入的关键字key不是输入结束标志，则循环执行以下操作：
   - 将此节点插入二叉排序树T中；
   - 读入一个关键字为key的节点。

【算法描述】
```cpp
void CreateBST(BSTree &T)
// 依次读入关键字为key的节点，将相应节点插入二叉排序树T中
{
    T = NULL; // 将二叉排序树T初始化为空树
    cin >> e;
    while (e.key != ENDFLAG) { // ENDFLAG为自定义常量，作为输入结束标志
        InsertBST(T, e); // 将此节点插入二叉排序树T中
        cin >> e;
    }
}
```

### 二叉排序树的删除

被删除的节点可能是二叉排序树中的任何节点，删除节点后，要根据其位置不同修改其双亲节点及相关节点的指针，以保持二叉排序树的特性。

算法7.7 二叉排序树的删除

【算法步骤】
1. 首先从二叉排序树的根节点开始查找关键字为key的待删节点，如果树中不存在此节点，则不做任何操作；否则，假设被删节点为*p（指向节点的指针为p），其双亲节点为*f（指向节点的指针为f），P和P分别表示其左子树和右子树。
2. 不失一般性，可设*p是*f的左孩子（右孩子情况类似）。下面分3种情况进行讨论。

（1）若*p节点为叶子节点，即P和P均为空树。由于删去叶子节点不破坏整棵树的结构，因此只需修改其双亲节点的指针即可：
\[ f->lchild = NULL; \]

（2）若*p节点只有左子树P或者只有右子树P，此时只要令P或P直接成为其双亲节点的左子树即可：
\[ f->lchild = p->lchild; \quad (或 f->lchild = p->rchild;) \]

（3）若*p节点的左子树和右子树均不空。从图7.9（b）可知，在删去*p节点之前，中序遍历该二叉树得到的序列为\( C_1, C_2, ..., Q_0, S, P, P_8, F, ... \)，在删去*p之后，为保持其他元素之间的相对位置不变，可以有两种处理方法：

① 令*p的左子树为*f的左子树，而*p的右子树为*s的右子树，如图7.9（c）所示。
\[ f->lchild = p->lchild; \quad s->rchild = p->rchild; \]

② 令*p的直接前驱（或直接后继）替代*p，然后再从二叉排序树中删去它的直接前驱（或直接后继）。如图7.9（d）所示，当以直接前驱*s替代*p时，由于*s只有左子树S₁，因此在删去*s之后，只要令S₁为*s的双亲*q的右子树即可。
\[ p->data = s->data; \quad q->rchild = s->lchild; \]

【算法描述】
```cpp
void DeleteBST(BSTree &T, KeyType key)
// 从二叉排序树T中删除关键字等于key的节点
{
    p = T; f = NULL; // 初始化
    while (p) {
        if (p->data.key == key) break; // 找到关键字等于key的节点*p，结束循环
        f = p; // *f为*p的双亲节点
        if (p->data.key > key) p = p->lchild; // 在*p的左子树中继续查找
        else p = p->rchild; // 在*p的右子树中继续查找
    }
    if (!p) return; // 找不到被删节点则返回
    /*---考虑到三种情况实现*p所指子树内部的处理：*p左右子树均不空、无右子树、无左子树----*/
    q = p;
    if ((p->lchild) && (p->rchild)) { // 被删节点*p左右子树均不空
        s = p->lchild;
        while (s->rchild) { // 在*p的左子树中继续查找其前驱节点，即最右下节点
            q = s; s = s->rchild; // 向右到尽头
        }
        p->data = s->data; // s指向被删节点的“前驱”
        if (q != p) q->rchild = s->lchild; // 重接*q的右子树
        else q->lchild = s->lchild; // 重接*q的左子树
        delete s;
        return;
    } else if (!p->rchild) { // 被删节点*p无右子树，只需重接其左子树
        p = p->lchild;
    } else if (!p->lchild) { // 被删节点*p无左子树，只需重接其右子树
        p = p->rchild;
    }
    /*---将p所指的子树挂接到其双亲节点*f相应的位置---*/
    if (!f) T = p; // 被删节点为根节点
    else if (q == f->lchild) f->lchild = p; // 挂接到*f的左子树位置
    else f->rchild = p; // 挂接到*f的右子树位置
    delete q;
}
```

### 平衡二叉树

1. 平衡二叉树的定义

二叉排序树查找算法的性能取决于二叉树的结构，而二叉排序树的形状则取决于其数据集。如果数据有序排列，则二叉排序树是线性的，查找的时间复杂度为 \(O(n)\)；反之，如果二叉排序树的结构合理，则查找速度较快，查找的时间复杂度为 \(O(\log n)\)。事实上，树的高度越小，查找速度越快。因此，希望二叉树的高度尽可能小。本节将讨论一种特殊类型的二叉排序树，称为平衡二叉树（Balanced Binary Tree或Height-Balanced Tree），因由苏联数学家阿德尔森-维尔斯基（Adelson-Velskii）和兰迪斯（Landis）提出，所以又称AVL树。

平衡二叉树或者是空树，或者是具有如下特征的二叉排序树：
（1）左子树和右子树的深度之差的绝对值不超过1；
（2）左子树和右子树也是平衡二叉树。

若将二叉树上节点的平衡因子（Balance Factor，BF）定义为该节点左子树和右子树的深度之差，则平衡二叉树上所有节点的平衡因子只可能是-1、0和1。只要二叉树上有一个节点的平衡因子的绝对值大于1，则该二叉树就是不平衡的。图7.11（a）所示为两棵平衡二叉树，而图7.11（b）所示为两棵不平衡的二叉树，节点中的值为该节点的平衡因子。

2. 平衡二叉树的平衡调整方法

如何创建一棵平衡二叉树呢？插入节点时，首先按照二叉排序树处理，若插入节点后破坏了平衡二叉树的特性，需对平衡二叉树进行调整。调整方法是：找到离插入节点最近且平衡因子绝对值超过1的祖先节点，以该节点为根的子树称为最小不平衡子树，可将重新平衡的范围局限于这棵子树。

一般情况下，假设最小不平衡子树的根节点为A，则失去平衡后进行调整的规律可归纳为下列4种情况。

（1）LL型：由于在A左子树根节点的左子树上插入节点，A的平衡因子由1增至2，致使以A为根的子树失去平衡，因此需进行一次向右的顺时针旋转操作，如图7.13所示。

（2）RR型：由于在A的右子树根节点的右子树上插入节点，A的平衡因子由-1变为-2，致使以A为根节点的子树失去平衡，因此需进行一次向左的逆时针旋转操作，如图7.15所示。

（3）LR型：由于在A的左子树根节点的右子树上插入节点，A的平衡因子由1增至2，致使以A为根节点的子树失去平衡，因此需进行两次旋转操作。第一次对B及其右子树进行逆时针旋转，C转上去成为B的根，这时变成了LL型，所以第二次进行LL型的顺时针旋转即可恢复平衡。如果C原来有左子树，则调整C的左子树为B的右子树，如图7.17所示。

（4）RL型：由于在A的右子树根节点的左子树上插入节点，A的平衡因子由-1变为-2，致使以A为根节点的子树失去平衡，因此旋转方法和LR型的旋转方法相“对称”，也需进行两次旋转，先顺时针向右旋转，再逆时针向左旋转，如图7.19所示。

### B-树

1. B-树的定义

一棵m阶的B-树，或为空树，或为满足下列特性的m叉树：
（1）树中每个节点至多有m棵子树；
（2）若根节点不是叶子节点，则至少有两棵子树；
（3）除根之外的所有非终端节点至少有m/2棵子树；
（4）所有的叶子节点都出现在同一层次上，并且不带信息，通常称为失败节点（失败节点并不存在，指向这些节点的指针为空。引入失败节点是为了便于分析B-树的查找性能）；
（5）所有的非终端节点最多有m－1个关键字，节点的结构如图7.21所示。

\[ \begin{array}{cccccccc}
n & p_0 & k_1 & p_1 & k_2 & p_2 & \cdots & k_n & p_n \\
\end{array} \]

图7.21 B-树的节点结构

其中，\( K_i (i=1, \cdots, n) \) 为关键字，且 \( K_i < K_{i+1} (i=1, \cdots, n-1) \); \( P_i (i=0, \cdots, n) \) 为指向子树根节点的指针，且指针 \( P_i \) 所指子树中所有节点的关键字均小于 \( K_{i+1} \)，而 \( P_{i+1} \) 所指子树中所有节点的关键字均大于 \( K_i \)，而 \( n (1-1 \leq n \leq m-1) \) 为关键字的个数（或 \( n+1 \) 为子树个数）。

2. B-树的查找

由B-树的定义可知，在B-树上进行查找的过程和二叉排序树查找的过程类似。

算法7.8 B-树的查找

【算法步骤】
将给定值key与根节点的各个关键字\( K_1, K_2, \cdots, K_n \)进行比较，由于该关键字序列是有序的，因此查找时可采用顺序查找，也可采用折半查找。查找时：
1. 若key = \( K_i \) (1 ≤ i ≤ j)，则查找成功；
2. 若key < \( K_1 \)，则顺着指针\( P_0 \)所指向的子树继续向下查找；
3. 若\( K_i < key < K_{i+1} \) (1 ≤ i ≤ j-1)，则顺着指针\( P_i \)所指向的子树继续向下查找；
4. 若key > \( K_n \)，则顺着指针\( P_n \)所指向的子树继续向下查找。

如果在自上而下的查找过程中，找到了值为key的关键字，则查找成功；如果直到叶子节点也未找到值为key的关键字，则查找失败。

【算法描述】
```cpp
Result SearchBTree(BTree T, KeyType key)
// 在m阶B-树T上查找关键字key，返回结果（pt, i, tag）
// 若查找成功，则特征值tag=1，指针pt所指节点中第i个关键字等于key
// 否则特征值tag=0，等于key的关键字应插入在指针pt所指节点中第i个和第i+1个关键字之间
{
    p = T; q = NULL; found = FALSE; i = 0;
    while (p && !found) {
        i = Search(p, key); // 在p->K[1..keynum]中查找i，使得p->K[i] <= key < p->K[i+1]
        if (i > 0 && p->K[i] == key) found = TRUE; // 找到待查关键字
        else { q = p; p = p->ptr[i]; }
    }
    if (found) return (p, i, 1); // 查找成功
    else return (q, i, 0); // 查找不成功，返回key的插入位置信息
}
```

### B+树

B+树是一种B-树的变形树，更适合用于文件索引系统。严格来讲，它已不是第5章中定义的树了。