# 7.3 树表的查找

前面介绍的3种查找方法都是用线性表作为查找表的组织形式，其中折半查找效率较高。但由于折半查找要求表中记录按关键字有序排列，且不能用链表作为存储结构，因此，当表的插入或删除操作频繁时，为维护表的有序性，需要移动表中很多记录。这种由移动记录引起的额外时间开销，就会抵消折半查找的优点。所以，线性表的查找更适用于静态查找表；若要对动态查找表进行高效率的查找，可采用几种特殊的二叉树作为查找表的组织形式，在此将它们统称为树表。本节将介绍在这些树表上进行查找和修改操作的方法。

## 7.3.1 二叉排序树

二叉排序树（Binary Sort Tree）又称二叉查找树，它是一种对排序和查找都很有用的特殊二叉树。

### 1. 二叉排序树的定义

二叉排序树或者是一棵空树，或者是具有下列性质的二叉树：

1. 若它的左子树不空，则左子树上所有节点的值均小于它的根节点的值；
2. 若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值；
3. 它的左、右子树也分别为二叉排序树。

二叉排序树是递归定义的。由定义可以得出二叉排序树的一个重要性质：中序遍历一棵二叉树时可以得到一个数值递增的有序序列。

例如：

- 若中序遍历图7.5(a)，则可得到一个按数值大小排序的递增序列：3, 12, 24, 37, 45, 53, 61, 78, 90, 100
- 若中序遍历图7.5(b)，则可得到一个按字符大小排序的递增序列：CAO, CHEN, DING, DU, LI, MA, WANG, XIA, ZHAO

在下面讨论二叉排序树的操作中，使用二叉链表作为存储结构。因为二叉排序树的操作要根据节点的关键字域来进行，所以下面给出了每个节点的数据域的类型定义（包括关键字项和其他数据项）。

```markdown
### 二叉排序树的二叉链表存储表示

```c
typedef struct {
    KeyType key; // 关键字项
    InfoType otherinfo; // 其他数据项
} ElemType; // 每个节点的数据域的类型

typedef struct BSTNode {
    ElemType data; // 每个节点的数据域包括关键字项和其他数据项
    struct BSTNode *lchild, *rchild; // 左右孩子指针
} BSTNode, *BSTree;
```

### 二叉排序树的查找

因为二叉排序树可以看成一个有序表，所以在二叉排序树上进行查找和折半查找类似，也是一个逐步缩小查找范围的过程。

#### 算法7.4 二叉排序树的递归查找

**【算法步骤】**

1. 若二叉排序树为空，则查找失败，返回空指针。
2. 若二叉排序树非空，将给定值 `key` 与根节点的关键字 `T->data.key` 进行比较：
   - 若 `key` 等于 `T->data.key`，则查找成功，返回根节点地址；
   - 若 `key` 小于 `T->data.key`，则递归查找左子树；
   - 若 `key` 大于 `T->data.key`，则递归查找右子树。

模仿折半查找算法7.3，读者可以很容易写出二叉排序树查找的非递归算法。下面以递归形式给出此查找算法。

**【算法描述】**

```c
BSTree SearchBST(BSTree T, KeyType key) {
    // 在根指针 T 所指二叉排序树中递归地查找某关键字等于 key 的数据元素
    // 若查找成功，则返回指向该数据元素节点的指针，否则返回空指针
    if ((!T) || key == T->data.key) return T; // 查找结束
    else if (key < T->data.key) return SearchBST(T->lchild, key); // 在左子树中继续查找
    else return SearchBST(T->rchild, key); // 在右子树中继续查找
}
```

例如，在图7.5（a）所示的二叉排序树中查找关键字等于100的记录（树中节点内的数均为记录的关键字）。首先以 `key = 100` 和根节点的关键字进行比较，因为 `key > 45`，则查找以45为根的右子树，此时右子树不空，且 `key > 53`，则继续查找以节点100为根的右子树，由于 `key` 和53的右子树根的关键字100相等，因此查找成功，返回指向节点100的指针值。又如在图7.5（a）中查找关键字等于40的记录，和上述过程类似，在给定值 `key` 与关键字45、12及37相继比较之后，继续查找以节点37为根的右子树，此时右子树为空，则说明该树中没有待查记录，故查找不成功，返回指针值为 `NULL`。

**【算法分析】**

从上述的两个查找例子（`key = 100` 和 `key = 40`）可见，在二叉排序树上查找其关键字等于给定值的节点的过程，恰是走了一条从根节点到该节点的路径的过程，和给定值比较的关键字个数等于路径长度加1（或节点所在层次数）。因此，和折半查找类似，与给定值比较的关键字个数不超过树的深度。然而，折半查找长度为 `n` 的顺序表的决策树是唯一的，而含有 `n` 个节点的二叉排序树却是不唯一的。
```

### 二叉排序树的平均查找长度

二叉排序树的形态不唯一，即使节点的值相同，创建树的序列不同也会导致不同的树结构。例如，图7.6中的两棵二叉排序树中节点的值都相同，但创建这两棵树的序列分别是 `(45, 24, 53, 12, 37, 93)` 和 `(12, 24, 37, 45, 53, 93)`。图7.6（a）中树的深度为3，而图7.6（b）中树的深度为6。

从平均查找长度来看，假设6个记录的查找概率相等，为1/6，则图7.6（a）中树的平均查找长度为：

\[ ASL_{60} = \frac{1}{6}[1 + 2 + 2 + 3 + 3 + 3] = \frac{14}{6} \]

而图7.6（b）中树的平均查找长度为：

\[ ASL_{90} = \frac{1}{6}[1 + 2 + 3 + 4 + 5 + 6] = \frac{21}{6} \]

因此，含有n个节点的二叉排序树的平均查找长度和树的形态有关。当先后插入的关键字有序时，构成的二叉排序树变为单支树，树的深度为n，其平均查找长度为 \(\frac{n+1}{2}\)（和顺序查找相同），这是最差的情况。显然，最好的情况是，二叉排序树的形态和折半查找的决策树的形态相似，其平均查找长度和 \(\log n\) 成正比。

若考虑把n个节点按各种可能的次序插入二叉排序树中，则有 \(n!\) 棵二叉排序树（其中有的形态相同）。可以证明，综合所有可能的情况，就平均而言，二叉排序树的平均查找长度仍然和 \(\log n\) 是同数量级的。

可见，二叉排序树上的查找和折半查找相差不大。但就维护表的有序性而言，二叉排序树更加有效，因为无须移动记录，只需修改指针即可完成对节点的插入和删除操作。因此，对于需要经常进行插入、删除和查找运算的表，采用二叉排序树比较好。

### 二叉排序树的插入

二叉排序树的插入操作是以查找为基础的。要将一个关键字为 `key` 的节点插入二叉排序树中，则需要从根节点向下查找，当树中不存在关键字等于 `key` 的节点时才进行插入。新插入的节点一定是一个新添加的叶子节点，并且是查找不成功时查找路径上访问的最后一个节点的左孩子或右孩子节点。

#### 算法7.5 二叉排序树的插入

##### 【算法步骤】

1. 若二叉排序树为空，则将待插入节点作为根节点插入空树。
2. 若二叉排序树非空，则将 `key` 与根节点的关键字 `T->data.key` 进行比较：
   - 若 `key` 小于 `T->data.key`，则将节点插入左子树；
   - 若 `key` 大于 `T->data.key`，则将节点插入右子树。

```markdown
# 算法描述

## 插入二叉排序树

```cpp
void InsertBST(BSTree &T, ElemType e)
// 当二叉排序树中不存在关键字等于e.key的数据元素时，则插入该元素
if (!T)
{
    // 找到插入位置，递归结束
    S = new BSTNode;
    // 生成新节点*S
    S->data = e;
    // 新节点*S的数据域置为e
    S->lchild = S->rchild = NULL;
    // 新节点*S作为叶子节点
    T = S;
    // 把新节点*S链接到已找到的插入位置
}
else if (e.key < T->data.key)
    InsertBST(T->lchild, e);
    // 将*S插入左子树
else if (e.key > T->data.key)
    InsertBST(T->rchild, e);
    // 将*S插入右子树
```

例如，在图7.5（a）所示的二叉排序树上插入关键字为55的节点，由于插入前二叉排序树非空，因此，将55和根节点45进行比较，因55>45，则应将55插入45的右子树；又和45的右子树的根53比较，因55>53，则应将55插入53的右子树；依次类推，直至最后55<61，且61的左子树为空，将55作为61的左孩子插入树中。结果如图7.7所示。

## 算法分析

二叉排序树插入的基本过程是查找，所以时间复杂度同查找一样，是 $O(\log n)$。

## 二叉排序树的创建

二叉排序树的创建是从空的二叉排序树开始的，每输入一个节点，经过查找操作，将新节点插入当前二叉排序树的合适位置。

### 算法步骤

1. 将二叉排序树T初始化为空树。
2. 读入一个关键字为key的节点。
3. 如果读入的关键字key不是输入结束标志，则循环执行以下操作：
   - 将此节点插入二叉排序树T中；
   - 读入一个关键字为key的节点。

### 算法描述

```cpp
void CreatBST(BSTree &T)
// 依次读入关键字为key的节点，将相应节点插入二叉排序树T中
T = NULL;
// 将二叉排序树T初始化为空树
cin >> e;
while (e.key != ENDFLAG)
    // ENDFLAG为自定义常量，作为输入结束标志
    InsertBST(T, e);
    // 将此节点插入二叉排序树T中
    cin >> e;
```

# 算法分析

假设有 \( n \) 个节点，则需要 \( n \) 次插入操作，而插入一个节点的算法时间复杂度为 \( O(\log n) \)，所以创建二叉排序树算法的时间复杂度为 \( O(n \log n) \)。

例如，设关键字的输入序列为 45, 24, 53, 45, 12, 24, 90，按上述算法生成二叉排序树的过程如图 7.8 所示。

\[
\begin{array}{ccc}
\text{(a) 空树} & \text{(b) 插入45} & \text{(c) 插入24} \\
\end{array}
\]

\[
\begin{array}{ccc}
\text{(d) 插入53} & \text{(e) 插入12} & \text{(f) 插入90} \\
\end{array}
\]

图 7.8 生成二叉排序树的过程

容易看出，一个无序序列可以通过构造一棵二叉排序树而变成一个有序序列，构造树的过程即对无序序列进行排序的过程。不仅如此，从上面的插入过程还可以看到，每次插入的新节点都是二叉排序树上新的叶子节点，则在进行插入操作时，不必移动其他节点，仅需改动某个节点的指针，使其由指向空节点变为指向非空节点即可。这就相当于在一个有序序列上插入一个记录而不需要移动其他记录。

## 5. 二叉排序树的删除

被删除的节点可能是二叉排序树中的任何节点，删除节点后，要根据其位置不同修改其双亲节点及相关节点的指针，以保持二叉排序树的特性。

### 算法7 二叉排序树的删除

#### 【算法步骤】

首先从二叉排序树的根节点开始查找关键字为 `key` 的待删节点，如果树中不存在此节点，则不做任何操作；否则，假设被删节点为 `*p`（指向节点的指针为 `p`），其双亲节点为 `*f`（指向节点的指针为 `f`），`P` 和 `P` 分别表示其左子树和右子树[见图 7.9（a）]。

不失一般性，可设 `*p` 是 `*f` 的左孩子（右孩子情况类似）。下面分 3 种情况进行讨论。

（1）若 `*p` 节点为叶子节点，即 `P` 和 `P` 均为空树。由于删去叶子节点不被保留的结构，因此只需修改其双亲节点的指针即可：

\[ f->lchild = NULL; \]

（2）若 `*p` 节点只有左子树 `P` 或者只有右子树 `P`，此时只要令 `P` 或 `P` 直接成为其双亲节点的左子树即可：

\[ f->lchild = p->lchild; \quad (\text{或} \quad f->lchild = p->rchild; \]

（3）若 `*p` 节点的左子树和右子树均不空。从图 7.9（b）可知，在删去 `*p` 节点之前，中序遍历该二叉树得到的序列为 \(\cdots C, C \cdots Q, Q S, S P P, F \cdots\)，在删去 `*p` 之后，为保持其他元素之间的相对位置不变，可以有两种处理方法：

① 令 `*p` 的左子树为 `*f` 的左子树，而 `*p` 的右子树为 `*s` 的右子树，如图 7.9（c）所示。

\[ f->lchild = p->lchild; \quad s->rchild = p->rchild; \]

```markdown
### 在二叉排序树中删除节点

在二叉排序树中删除节点时，通常有两种处理方法：

1. **直接前驱（或直接后继）替代法**：
   - 令*p的直接前驱（或直接后继）替代*p，然后再从二叉排序树中删去它的直接前驱（或直接后继）。
   - 如图7.9（d）所示，当以直接前驱*s替代*p时，由于*s只有左子树$n，因此在删去*s之后，只要令$n为*s的双亲*o的右子树即可。

2. **直接前驱替代法（常用）**：
   - 以被删节点左子树中关键字最大的节点替代被删节点，然后从左子树中删除这个节点。
   - 此节点一定没有右子树（否则它就不是左子树中关键字最大的节点），这样不会增加树的高度，所以常采用这种处理方案。

### 算法描述

```c
void DeleteBST(BSTree &T, KeyType key) {
    // 从二叉排序树r中删除关键字等于key的节点
    p = r;
    f = NULL; // 初始化

    /*---下面的while循环从根开始查找关键字等于key的节点*p---*/
    while (p) {
        if (p->data.key == key) break; // 找到关键字等于key的节点*p，结束循环
        f = p; // *f为*p的双亲节点
        if (p->data.key > key) p = p->lchild; // 在*p的左子树中继续查找
        else p = p->rchild; // 在*p的右子树中继续查找
    } // while

    if (!p) return; // 找不到被删节点则返回

    /*---考虑到情况实现p所指子树内部的处理：*p左右子树均不空、无右子树、无左子树---*/
    q = p;
    if ((p->lchild) && (p->rchild)) { // 被删节点*p左右子树均不空
        // 处理逻辑
    }
}
```

### 图示

![图7.9 在二叉排序树中删除*p](image.png)

在图中，删除节点*p时，使用其直接前驱*s替代*p，然后删除*s。由于*s只有左子树$n，因此在删去*s之后，只需将$n作为*s的双亲*o的右子树即可。

### 总结

- **前一种处理方法**可能增加树的深度。
- **后一种方法**（直接前驱替代法）不会增加树的高度，因此常被采用。

\[
\text{p} \rightarrow \text{data} = \text{s} \rightarrow \text{data}; \quad \text{q} \rightarrow \text{rchild} = \text{s} \rightarrow \text{lchild};
\]

这种处理方案确保了删除操作不会导致树的高度增加，从而保持了二叉排序树的平衡性。

```markdown
### 二叉排序树删除算法

#### 代码实现

```c
s = p->lchild;
while (s->rchild) {  // 在*p的左子树中继续查找其前驱节点，即最右下节点
    q = s; s = s->rchild;  // 向右到尽头
}
p->data = s->data;  // s指向被删节点的“前驱”
if (q != p) q->rchild = s->lchild;  // 重接*q的右子树
else q->lchild = s->lchild;  // 重接*q的左子树
delete s;
return;
} else if (!p->rchild) {  // 被删节点*p无右子树，只需重接其左子树
    p = p->lchild;
} else if (!p->lchild) {  // 被删节点*p无左子树，只需重接其右子树
    p = p->rchild;
}
/*---将p所指的子树挂接到某家节点*和相应的位置---*/
if (!f) T = p;  // 被删节点为根节点
else if (q == f->lchild) f->lchild = p;  // 挂接到*f的左子树位置
else f->rchild = p;  // 挂接到*f的右子树位置
delete q;
}
```

#### 算法分析

同二叉排序树插入一样，二叉排序树删除的基本过程也是查找，所以时间复杂度仍是 \(O(\log n)\)。

根据算法7.7，图7.10给出了二叉排序树删除的3种情况。

\[
\begin{array}{ccccccc}
\text{删除} & 45 & 78 & 17 & 28 & 11 & 29 \\
\text{删除} & 45 & 78 & 17 & 28 & 11 & 29 \\
\text{删除} & 45 & 78 & 17 & 28 & 11 & 29 \\
\end{array}
\]

\[
\begin{array}{ccccccc}
\text{删除} & 78 & 13 & 31 & 35 & 38 & 39 \\
\text{删除} & 78 & 17 & 28 & 11 & 29 & 39 \\
\text{删除} & 78 & 17 & 28 & 11 & 29 & 39 \\
\end{array}
\]

\[
\begin{array}{ccccccc}
\text{缺右子树用左孩子填补} & \text{缺左子树用右孩子填补} & \text{在左子树上找中序最后一个节点填补} \\
\end{array}
\]

\[
\begin{array}{ccccccc}
\text{（a）被删节点缺右子树} & \text{（b）被删节点缺左子树} & \text{（c）被删节点左、右子树都存在} \\
\end{array}
\]
```

### 解释

1. **删除节点的情况**：
   - **情况（a）**：被删节点缺右子树，只需重接其左子树。
   - **情况（b）**：被删节点缺左子树，只需重接其右子树。
   - **情况（c）**：被删节点左、右子树都存在，需要在左子树中找到中序遍历的最后一个节点（即最右下节点）来填补被删节点的位置。

2. **时间复杂度**：
   - 删除操作的时间复杂度为 \(O(\log n)\)，因为删除操作的核心是查找，而查找的时间复杂度在平衡二叉树中为 \(O(\log n)\)。

3. **具体步骤**：
   - 首先查找被删节点的前驱节点（即左子树的最右下节点）。
   - 将前驱节点的值赋给被删节点。
   - 根据前驱节点的父节点与被删节点的关系，重接相应的子树。
   - 最后删除前驱节点。

通过上述步骤，可以保证删除操作后二叉排序树的性质不变。

