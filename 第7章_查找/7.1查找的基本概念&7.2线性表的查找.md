# 第7章
## 查找

本书前几章介绍了各种线性和非线性的数据结构，并讨论了这些数据结构的相应运算。而在实际应用中，查找运算是非常常见的。面向一些数据量很大的实时系统，如订票系统、互联网上的信息检索系统等，查找效率尤其重要。本章将针对查找运算，讨论应该采用何种数据结构，使用什么样的方法，并通过对它们的效率分析来比较各种查找算法在不同情况下的优劣。

### 7.1 查找的基本概念

为了便于后面各节对各种查找算法的比较，首先介绍查找的概念和术语。

（1）查找表  
查找表是由同一类型的数据元素（或记录）构成的集合。由于“集合”中的数据元素之间存在着完全松散的关系，因此查找表是一种非常灵活的数据结构，可以利用其他的数据结构来实现，比如本章将要介绍的线性表、树表及散列表等。

（2）关键字  
关键字是数据元素（或记录）中某个数据项的值，用它可以标识一个数据元素（或记录）。若此关键字可以唯一地标识一个记录，则称此关键字为主关键字（对不同的记录，其主关键字均不同）。反之，常用以识别若干记录的关键字为次关键字。当数据元素只有一个数据项时，其关键字即该数据元素的值。

（3）查找  
查找是指根据给定的某个值，在查找表中确定一个其关键字等于给定值的记录或数据元素。若表中存在这样的一个记录，则称查找成功，此时查找的结果可由整个记录的值，或者指示该记录在查找表中的位置；若表中不存在关键字等于给定值的记录，则称查找不成功，此时查找的结果可由一个“空”记录或“空”指针。

（4）动态查找表和静态查找表  
若在查找的同时对表格有修改操作（如插入和删除），则称相应的表为动态查找表，否则称之为静态查找表。换句话说，动态查找表的表结构本身是在查找过程中动态生成的，即在创建表时，对于给定值，若表中存在其关键字等于给定值的记录，则查找成功并返回；否则插入关键字等于给定值的记录。

（5）平均查找长度  
为确定记录在查找表中的位置，需和给定值进行比较的关键字个数的期望值，称为查找算法在查找成功时的平均查找长度 (Average Search Length, ASL)。

对于含有 $n$ 个记录的表，查找成功时的平均查找长度为：

$ ASL = \sum_{i=1}^{p} P_i C_i $

其中， $p$ 为查找表中第 $i$ 个记录的概率，且 $\sum_{i=1}^{p} P_i = 1$； $C_i$ 为找到表中其关键字与给定值相等的第 $i$ 个记录时，和给定值已进行过比较的关键字个数。显然， $C_i$ 随查找过程的不同而不同。

由于查找算法的基本运算是关键字之间的比较操作，因此可用平均查找长度来衡量查找算法的性能。

### 7.2 线性表的查找

在查找表的组织方式中，线性表是最简单的一种。本节将介绍基于线性表的顺序查找、折半查找和分块查找。

#### 7.2.1 顺序查找

顺序查找 (Sequential Search) 的查找过程为：从表的一端开始，依次将记录的关键字和给定值进行比较，若某个记录的关键字和给定值相等，则查找成功；反之，若查找整个表后，仍未找到关键字和给定值相等的记录，则查找失败。

顺序查找方法既适用于线性表的顺序存储结构，又适用于线性表的链式存储结构。下面只介绍以顺序表作为存储结构时实现的顺序查找算法。

数据元素类型定义如下：

```c
typedef struct {
    KeyType key; // 关键字域
    InfoType otherinfo; // 其他域
} ElemType;

顺序表的定义同第2章：

typedef struct {
    ElemType *R; // 存储空间基地址
    int length; // 当前长度
} SSTable;
```

在此定义下，顺序查找算法便与第2章的算法2.3一样。在此假设元素从ST.R[1]开始顺序向后存放，ST.R[0]闲置不用，查找时从表的最后开始比较，如算法7.1所示。

**算法7.1 顺序查找**

【算法描述】

```c
int Search_Seq(SSTable ST, KeyType key) {
    // 在顺序表ST中顺序查找其关键字等于key的数据元素。若找到，则函数值为该元素在表中的位置，否则为0
    for (i = ST.length; i >= 1; i--) {
        if (ST.R[i].key == key) {
            return i;
        }
    }
    return 0;
}
```

算法7.1在查找过程中每步都要检测整个表是否查找完毕，即每步都要有循环变量是否满足条件 `i ≥ 1` 的检测。改进这个程序，可以免去这个检测过程。

改进方法是查找之前先对 `ST.R[0]` 的关键字赋值 `key`，在此，`ST.R[0]` 起到了监视哨的作用，如算法7.2所示。

**算法7.2 设置监视哨的顺序查找**

【算法描述】

```c
int Search_Seq(SSTable ST, KeyType key) {
    // 在顺序表ST中顺序查找其关键字等于key的数据元素。若找到，则函数值为该元素在表中的位置，否则为0
    ST.R[0].key = key; // “监视哨”
    for (i = ST.length; ST.R[i].key != key; --i); // 从后往前找
    return i;
}
```

【算法分析】

因此，算法7.2仅进行了程序设计技巧上的改进，即通过设置监视哨，免去查找过程中每一步都要检测整个表是否查找完毕。然而实践证明，这个改进能使顺序查找在 `ST.length ≥ 1000` 时，进行一次查找所需的平均时间几乎减少一半。当然，监视哨也可设在高下标处。

算法7.2和算法7.1的时间复杂度一样，在第2章已经进行过分析，即：

$ ASL = \frac{n + 1}{2} $

算法7.2的时间复杂度为 $O(n)$。

顺序查找的优点是：算法简单，对表格构无任何要求，既适用于顺序结构，也适用于链式结构，无论记录是否按关键字有序均可应用。其缺点是：平均查找长度较大，查找效率较低，所以当 $n$ 很大时，不宜采用顺序查找。

以下是对该知识点的扩展与讲解：

**一、查找相关内容整体概述**

在计算机科学领域，当处理各种数据结构时，查找运算是极为关键的操作。就像我们在日常生活中，比如在图书馆找一本书、在手机通讯录里找一个联系人等，都涉及到查找的概念。在程序和数据处理中，针对不同的数据结构以及应用场景，需要选择合适的查找方法来提高效率。

**二、查找的基本概念详细讲解**

1. **查找表**：
它是由同一类型的数据元素（或记录）构成的集合。想象一下，它就像是一个装满了同类型物品的盒子，里面的每个物品就是一个数据元素。这些数据元素之间关系松散，很灵活，可以通过其他数据结构来实现，比如后面要讲的线性表、树表、散列表等。这就好比这个盒子可以用不同的方式去整理里面的物品，每种整理方式对应一种实现查找表的具体数据结构。

2. **关键字**：
这是数据元素（或记录）中某个数据项的值，用来标识一个数据元素（或记录）。比如在学生信息表中，学号就可以作为关键字，因为它能唯一标识一个学生的记录，这就是主关键字。但如果有个字段比如兴趣爱好，可能多个学生有相同的兴趣爱好，那这个就可能是次关键字了。当数据元素只有一个数据项时，关键字就是该数据元素的值本身。

3. **查找**：
根据给定的某个值，在查找表中确定一个其关键字等于给定值的记录或数据元素。这就好比在刚才说的学生信息表中，给定一个学号，去找到对应的学生记录。如果找到了，就是查找成功，结果可以是整个记录的值或者它在表中的位置；要是没找到，那就是查找不成功，结果可能是一个“空”记录或“空”指针。

4. **动态查找表和静态查找表**：
动态查找表在查找的同时可以对表格进行修改操作，比如插入和删除记录。就好像一个可以随时添加或删除物品的盒子。而静态查找表在查找过程中不能对表格进行修改。动态查找表的表结构是在查找过程中动态生成的，比如创建表时，给定一个值，如果表中存在其关键字等于给定值的记录，就查找成功并返回；否则就插入这个记录。

5. **平均查找长度**：
这是衡量查找算法性能的一个重要指标。它是为确定记录在查找表中的位置，需和给定值进行比较的关键字个数的期望值。简单说，就是平均下来要比较多少次关键字才能找到想要的记录。对于含有 $n$ 个记录的表，有特定的计算公式 $ ASL = \sum_{i=1}^{p} P_i C_i $，其中 $p$ 是查找表中第 $i$ 个记录的概率，且这些概率之和为 $1$，$C_i$ 是找到表中其关键字与给定值相等的第 $i$ 个记录时，和给定值已进行过比较的关键字个数。

**三、线性表的查找详细讲解**

1. **顺序查找**：
    - **查找过程**：从表的一端开始，依次将记录的关键字和给定值进行比较。比如从表的最后开始，逐个往前检查每个记录的关键字是否和给定值相等。如果某个记录的关键字和给定值相等，那就查找成功；要是把整个表都查完了还没找到相等的，那就是查找失败。
    - **适用结构**：它既适用于线性表的顺序存储结构，又适用于线性表的链式存储结构。这意味着不管是像数组那样顺序存放的数据，还是通过链表链接起来的数据，都可以用顺序查找的方法。
    - **算法实现及改进**：首先定义了数据元素类型和顺序表的结构。在原始的顺序查找算法（算法7.1）中，每步都要检测整个表是否查找完毕，通过循环变量是否满足条件 `i ≥ 1` 来判断。后来改进的算法（算法7.2）是在查找之前先对 `ST.R[0]` 的关键字赋值 `key`，让 `ST.R[0]` 起到监视哨的作用。这样就免去了每一步都要检测整个表是否查找完毕的过程。实践证明，当 `ST.length ≥ 1000` 时，这个改进能使顺序查找进行一次查找所需的平均时间几乎减少一半。而且监视哨也可设在高下标处。虽然算法7.2和算法7.1的时间复杂度一样，都是 $O(n)$，但这个改进在实际应用中还是很有意义的。
    - **优缺点**：优点是算法简单，对表格结构无任何要求，不管记录是否按关键字有序都能应用。缺点是平均查找长度较大，查找效率较低，所以当 $n$ 很大时，不宜采用顺序查找。

**以下是根据上述讲解生成的20个选择题及答案解析：**

**一、选择题**

1. 查找表是由（  ）构成的集合。
A. 不同类型的数据元素
B. 同一类型的数据元素
C. 任意类型的数据元素
D. 固定类型的数据元素

答案：B
解释：查找表是由同一类型的数据元素（或记录）构成的集合，所以选B。

2. 若关键字可以唯一地标识一个记录，则称此关键字为（  ）。
A. 次关键字
B. 辅助关键字
C. 主关键字
D. 通用关键字

答案：C
解释：若关键字可以唯一地标识一个记录，则称此关键字为主关键字，所以选C。

3. 查找不成功时，查找的结果可由（  ）表示。
A. 整个记录的值
B. 指示该记录在查找表中的位置
C. 一个“空”记录或“空”指针
D. 任意值

答案：C
解释：若表中不存在关键字等于给定值的记录，即查找不成功时，查找的结果可由一个“空”记录或“空”指针表示，所以选C。

4. 动态查找表在查找的同时可以进行（  ）操作。
A. 仅插入
B. 仅删除
C. 插入和删除
D. 不能进行任何修改

答案：C
解释：动态查找表在查找的同时对表格有修改操作，如插入和删除，所以选C。

5. 平均查找长度是衡量（  ）性能的指标。
A. 存储结构
B. 查找算法
C. 数据元素
D. 关键字

答案：B
解释：平均查找长度是用来衡量查找算法在查找成功时的性能的，所以选B。

6. 对于含有 $n$ 个记录的表，查找成功时的平均查找长度计算公式为（  ）。
A. $ ASL = \sum_{i=1}^{n} P_i C_i $
B. $ ASL = \sum_{i=1}^{p} P_i C_i $，其中 $\sum_{i=1}^{p} P_i = 1$
C. $ ASL = \frac{n + 1}{2} $
D. $ ASL = \frac{n}{2} $

答案：B
解释：对于含有 $n$ 个记录的表，查找成功时的平均查找长度为 $ ASL = \sum_{i=1}^{p} P_i C_i $，其中 $\sum_{i=1}^{p} P_i = 1$，所以选B。

7. 顺序查找既适用于线性表的顺序存储结构，又适用于（  ）。
A. 线性表的链式存储结构
B. 树表的存储结构
C. 散列表的存储结构
D. 非线性表的存储结构

答案：A
解释：顺序查找既适用于线性表的顺序存储结构，又适用于线性表的链式存储结构，所以选A。

8. 在顺序查找算法中，改进后的算法（算法7.2）通过设置（  ）免去了每步检测整个表是否查找完毕的过程。
A. 循环变量
B. 监视哨
C. 新的数据元素
D. 辅助指针

答案：B
解释：改进后的顺序查找算法（算法7.2）通过设置监视哨免去了每步检测整个表是否查找完毕的过程，所以选B。

9. 算法7.2的时间复杂度为（  ）。
A. $O(1)$
B. $O(n)$
C. $O(n^2)$
D. $O(\log n)$

答案：B
解释：算法7.2的时间复杂度为 $O(n)$，和算法7.1一样，所以选B。

10. 顺序查找的优点是（  ）。
A. 平均查找长度小
B. 查找效率高
C. 算法简单，对表格结构无任何要求
D. 只适用于有序记录

答案：C
解释：顺序查找的优点是算法简单，对表格结构无任何要求，所以选C。

11. 当 $n$ 很大时，（  ）查找不宜采用顺序查找。
A. 任何
B. 静态
C. 动态
D. 不确定

答案：A
解释：因为顺序查找平均查找长度较大，查找效率较低，所以当 $n$ 很大时，任何查找都不宜采用顺序查找，所以选A。

12. 关键字是数据元素（或记录）中某个（  ）的值，用它可以标识一个数据元素（或记录）。
A. 数据项
B. 存储单元
C. 算法
D. 结构

答案：A
解释：关键字是数据元素（或记录）中某个数据项的值，用它可以标识一个数据元素（或记录），所以选A。

13. 若数据元素只有一个数据项时，其关键字即该数据元素的（  ）。
A. 存储地址
B. 算法
C. 值
D. 结构

答案：C
解释：当数据元素只有一个数据项时，其关键字即该数据元素的值，所以选C。

14. 在查找表中，数据元素之间存在着（  ）关系。
A. 完全紧密
B. 完全松散
C. 部分紧密部分松散
D. 固定

答案：B
解释：查找表中数据元素之间存在着完全松散的关系，所以选B。

15. 静态查找表在查找过程中（  ）对表格进行修改。
A. 可以
B. 不可以
C. 有时可以
D. 不确定

答案：B
解释：静态查找表在查找过程中不能对表格进行修改，所以选B。

16. 以下哪种不是实现查找表的常见数据结构（  ）。
A. 线性表
B. 树表
C. 散列表
D. 数组表

答案：D
解释：实现查找表常见的数据结构有线性表、树表、散列表等，数组表不是专门用来表述实现查找表的常见数据结构，所以选D。

17. 在顺序查找算法7.1中，每步都要检测整个表是否查找完毕，是通过检测（  ）是否满足条件 `i ≥ 1` 来实现的。
A. 循环变量
B. 监视哨
C. 数据元素个数
D. 关键字个数

答案：A
解释：在顺序查找算法7.1中，每步都要检测整个表是否查找完毕，是通过检测循环变量是否满足条件 `i ≥ 1` 来实现的，所以选A。

18. 对于含有 $n$ 个记录的表，若查找成功时的平均查找长度为 $ ASL = \frac{n + 1}{2} $，则该查找算法可能是（  ）。
A. 顺序查找
B. 折半查找
C. 分块查找
D. 不确定

答案：A
解释：顺序查找的平均查找长度为 $ ASL = \frac{n + 1}{2} $，所以选A。

19. 查找是指根据给定的某个值，在查找表中确定一个其关键字等于给定值的（  ）。
A. 记录或数据元素
B. 记录
C. 数据元素
D. 存储单元

答案：A
解释：查找是指根据给定的某个值，在查找表中确定一个其关键字等于给定值的记录或数据元素，所以选A。

20. 以下关于动态查找表的说法错误的是（  ）。
A. 表结构本身是在查找过程中动态生成的
B. 在创建表时，对于给定值，若表中存在其关键字等于给定值的记录，则查找成功并返回
C. 在查找的同时对表格有修改操作
D. 只能进行插入操作，不能进行删除操作

答案：D
解释：动态查找表在查找的同时对表格有修改操作，包括插入和删除操作，所以D说法错误，选D。

### 扩展与讲解

#### 查找的基本概念

1. **查找表**：查找表是由同一类型的数据元素（或记录）构成的集合。查找表中的数据元素之间没有固定的关系，因此非常灵活，可以利用其他数据结构来实现，如线性表、树表和散列表等。

2. **关键字**：关键字是数据元素中的某个数据项的值，用于标识一个数据元素。如果一个关键字可以唯一标识一个记录，则称为主关键字；否则称为次关键字。

3. **查找**：查找是指根据给定的某个值，在查找表中确定一个其关键字等于给定值的记录或数据元素。查找成功时，返回记录的值或其在表中的位置；查找失败时，返回一个“空”记录或“空”指针。

4. **动态查找表和静态查找表**：动态查找表允许在查找过程中进行修改操作（如插入和删除），而静态查找表则不允许。动态查找表的结构在查找过程中动态生成，静态查找表的结构在查找过程中保持不变。

5. **平均查找长度（ASL）**：平均查找长度是指在查找成功时，确定记录在查找表中的位置所需比较的关键字个数的期望值。它是衡量查找算法性能的重要指标。

   对于含有 $n$ 个记录的表，查找成功时的平均查找长度为：

   $ ASL = \sum_{i=1}^{p} P_i C_i $

   其中， $p$ 为查找表中第 $i$ 个记录的概率，且 $\sum_{i=1}^{p} P_i = 1$； $C_i$ 为找到表中其关键字与给定值相等的第 $i$ 个记录时，和给定值已进行过比较的关键字个数。显然， $C_i$ 随查找过程的不同而不同。

#### 线性表的查找

1. **顺序查找**：顺序查找是从表的一端开始，依次将记录的关键字和给定值进行比较，直到找到匹配的记录或遍历完整个表。顺序查找适用于顺序存储结构和链式存储结构。

2. **折半查找**：折半查找（二分查找）要求查找表是有序的，通过不断缩小查找范围来提高查找效率。每次比较后，查找范围缩小一半，直到找到匹配的记录或确定不存在匹配的记录。

3. **分块查找**：分块查找将查找表分成若干块，每块内的记录可以是无序的，但块与块之间是有序的。先通过块的关键字确定记录所在的块，再在块内进行顺序查找。

### 选择题

1. **查找表是由什么构成的集合？**
   - A. 不同类型的数据元素
   - B. 同一类型的数据元素
   - C. 任意类型的数据元素
   - D. 有序的数据元素
   - **答案**：B
   - **解释**：查找表是由同一类型的数据元素构成的集合。

2. **关键字的作用是什么？**
   - A. 标识多个数据元素
   - B. 标识一个数据元素
   - C. 标识数据元素的顺序
   - D. 标识数据元素的大小
   - **答案**：B
   - **解释**：关键字用于标识一个数据元素。

3. **查找成功时，查找的结果可能是什么？**
   - A. 记录的值
   - B. 记录的位置
   - C. 记录的值或位置
   - D. 记录的值和位置
   - **答案**：C
   - **解释**：查找成功时，结果可以是记录的值或其在表中的位置。

4. **动态查找表和静态查找表的主要区别是什么？**
   - A. 数据元素类型不同
   - B. 查找算法不同
   - C. 是否允许修改操作
   - D. 数据元素数量不同
   - **答案**：C
   - **解释**：动态查找表允许在查找过程中进行修改操作，而静态查找表不允许。

5. **平均查找长度（ASL）用于衡量什么？**
   - A. 查找算法的复杂度
   - B. 查找算法的效率
   - C. 查找算法的稳定性
   - D. 查找算法的可靠性
   - **答案**：B
   - **解释**：平均查找长度用于衡量查找算法的效率。

6. **顺序查找适用于什么存储结构？**
   - A. 顺序存储结构
   - B. 链式存储结构
   - C. 顺序存储结构和链式存储结构
   - D. 散列存储结构
   - **答案**：C
   - **解释**：顺序查找既适用于顺序存储结构，也适用于链式存储结构。

7. **折半查找要求查找表是什么样的？**
   - A. 无序
   - B. 有序
   - C. 部分有序
   - D. 随机排列
   - **答案**：B
   - **解释**：折半查找要求查找表是有序的。

8. **分块查找中，块内的记录可以是什么样的？**
   - A. 有序
   - B. 无序
   - C. 部分有序
   - D. 随机排列
   - **答案**：B
   - **解释**：分块查找中，块内的记录可以是无序的。

9. **顺序查找的时间复杂度是多少？**
   - A. $O(1)$
   - B. $O(\log n)$
   - C. $O(n)$
   - D. $O(n^2)$
   - **答案**：C
   - **解释**：顺序查找的时间复杂度为$O(n)$。

10. **折半查找的时间复杂度是多少？**
    - A. $O(1)$
    - B. $O(\log n)$
    - C. $O(n)$
    - D. $O(n^2)$
    - **答案**：B
    - **解释**：折半查找的时间复杂度为$O(\log n)$。

11. **分块查找的时间复杂度是多少？**
    - A. $O(1)$
    - B. $O(\log n)$
    - C. $O(n)$
    - D. $O(n^2)$
    - **答案**：C
    - **解释**：分块查找的时间复杂度为$O(n)$。

12. **顺序查找的优点是什么？**
    - A. 算法复杂
    - B. 对表格结构无要求
    - C. 查找效率高
    - D. 适用于小数据量
    - **答案**：B
    - **解释**：顺序查找的优点是算法简单，对表格结构无要求。

13. **顺序查找的缺点是什么？**
    - A. 算法复杂
    - B. 对表格结构有要求
    - C. 查找效率低
    - D. 适用于大数据量
    - **答案**：C
    - **解释**：顺序查找的缺点是查找效率较低。

14. **折半查找适用于什么情况？**
    - A. 数据量小
    - B. 数据量大
    - C. 数据无序
    - D. 数据随机排列
    - **答案**：B
    - **解释**：折半查找适用于数据量大的情况。

15. **分块查找适用于什么情况？**
    - A. 数据量小
    - B. 数据量大
    - C. 数据无序
    - D. 数据随机排列
    - **答案**：B
    - **解释**：分块查找适用于数据量大的情况。

16. **顺序查找的平均查找长度是多少？**
    - A. $\frac{n + 1}{2}$
    - B. $\frac{n}{2}$
    - C. $\log n$
    - D. $n$
    - **答案**：A
    - **解释**：顺序查找的平均查找长度为$\frac{n + 1}{2}$。

17. **折半查找的平均查找长度是多少？**
    - A. $\frac{n + 1}{2}$
    - B. $\frac{n}{2}$
    - C. $\log n$
    - D. $n$
    - **答案**：C
    - **解释**：折半查找的平均查找长度为$\log n$。

18. **分块查找的平均查找长度是多少？**
    - A. $\frac{n + 1}{2}$
    - B. $\frac{n}{2}$
    - C. $\log n$
    - D. $n$
    - **答案**：D
    - **解释**：分块查找的平均查找长度为$n$。

19. **监视哨的作用是什么？**
    - A. 提高查找效率
    - B. 减少查找时间
    - C. 避免查找过程中的检测
    - D. 增加查找的准确性
    - **答案**：C
    - **解释**：监视哨的作用是避免查找过程中每一步都要检测整个表是否查找完毕。

20. **顺序查找的改进方法是什么？**
    - A. 设置监视哨
    - B. 增加查找次数
    - C. 减少查找次数
    - D. 改变查找顺序
    - **答案**：A
    - **解释**：顺序查找的改进方法是设置监视哨。

#### 7.2.2 折半查找

折半查找（Binary Search）也称二分查找，它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。在下面及后续的讨论中，均假设有序表是有序递增的。

折半查找的查找过程为：从表的中间记录开始，如果给定值和中间记录的关键字相等，则查找成功；如果给定值大于或者小于中间记录的关键字，则在表中大于或小于中间记录的那一半中查找，这样重复操作，直到查找成功，或者在某一步中查找区间为空，则代表查找失败。

折半查找每一次查找都使查找范围缩小一半，与顺序查找相比，很显然会提高查找效率。为了标记查找过程中每一次的查找区间，下面分别用 `low` 和 `high` 来表示当前查找区间的下界和上界，`mid` 为区间的中间位置。

**算法7.3 折半查找**

【算法步骤】

① 置查找区间初值，`low` 为 1，`high` 为表长。

② 当 `low < high` 时，循环执行以下操作：

- `mid` 取 `low` 和 `high` 的中间值；
- 将给定值 `key` 与中间位置记录的关键字进行比较，若相等则查找成功，返回中间位置 `mid`；
- 若不相等则利用中间位置记录将表对分成前、后两个子表。如果 `key` 比中间位置记录的关键字小，则 `high` 取为 `mid - 1`，否则 `low` 取为 `mid + 1`。

③ 循环结束，说明查找区间为空，则查找失败，返回 0。

【算法描述】

```c
int SearchBin(SSTable ST, KeyType key) {
    // 在有序表ST中折半查找其关键字等于key的数据元素。若找到，则函数值为该元素在表中的位置，否则为0
    int low = 1, high = ST.length; // 置查找区间初值
    while (low <= high) {
        int mid = (low + high) / 2;
        if (key == ST.R[mid].key) {
            return mid; // 找到待查元素
        } else if (key < ST.R[mid].key) {
            high = mid - 1; // 继续在前一子表进行查找
        } else {
            low = mid + 1; // 继续在后一子表进行查找
        }
    } // while
    return 0; // 表中不存在待查元素
}
```

本算法很容易理解，唯一需要注意的是，循环执行的条件是 `low <= high`，而不是 `low < high`，因为 `low = high` 时，查找区间还有最后一个节点，还要进一步比较。

算法7.3很容易学习成递归程序，递归函数的参数除了 `ST` 和 `key` 之外，还需要加上 `low` 和 `high`，请读者自行实现折半查找的递归算法。

**【例7.1】** 已知如下包含11个数据元素的有序表（关键字即数据元素的值）：

$ (5, 16, 20, 27, 30, 36, 44, 55, 60, 67, 71) $

请给出查找关键字为 27 和 65 的数据元素的折半查找过程。

假设指针 `low` 和 `high` 分别指示待查元素所在范围的下界和上界，指针 `mid` 指示区间的中间位置，即 `mid = \lfloor (low + high) / 2 \rfloor`。在此例中，`low` 和 `high` 的初值分别为 1 和 11，即 `[1, 11]` 为待查范围，`mid` 初值为 6。

查找关键字 `key = 27` 的折半查找过程如图7.1（a）所示。

首先令给定值 `key = 27` 与中间位置的数据元素的关键字 `ST.R[mid].key` 相比较，因为 `36 > 27`，说明待查元素若存在，必在区间 `[low, mid - 1]` 内，则令指针 `high` 指向第 `mid - 1` 个元素，`high = 5`，重新求得 `mid = \lfloor (1 + 5) / 2 \rfloor = 3`。

然后仍令 `key` 和 `ST.R[mid].key` 相比较，因为 `20 < 27`，说明待查元素若存在，必在区间 `[mid + 1, high]` 内，则令指针 `low` 指向第 `mid + 1` 个元素，`low = 4`，求得 `mid` 的新值为 4，比较 `key` 和 `ST.R[mid].key`，因为相等，则查找成功，返回所查元素在表中的序号，即指针 `mid` 的值 4。

查找关键字 `key = 65` 的折半查找过程如图7.1（b）所示。

查找过程同上，只是在图7.1（b）中的最后一趟查找时，因为 `low > high`，查找区间不存在，则说明表中没有关键字等于 65 的元素，查找失败，返回 0。

【算法分析】

折半查找过程可用二叉树来描述。树中每一节点对应表中一个记录，但节点值不是记录的关键字，而是记录在表中的位置序号。把当前查找区间的中间位置作为根，把左子表和右子表分别作为根的左子树和右子树，由此得到的二叉树称为折半查找的决策树。

例7.1中的有序表对应的决策树如图7.2所示。从决策树上可见，成功的折半查找恰好是走了一条从决策树的根到被查节点的路径，经历比较的关键字个数即为该节点在树中的层次。例如，查找27的过程经过一条从根到节点4的路径，需要比较3次，比较次数即节点4所在的层次。图7.2中比较1次的只有一个根节点，比较2次的有两个节点，比较3次和4次的各有4个节点。假设每个记录的查找概率相同，根据此决策树可知，对长度为11的有序表进行折半查找的平均查找长度为：

$ ASL = \frac{1 \times 1 + 2 \times 2 + 4 \times 3 + 4 \times 4}{11} = \frac{33}{11} = 3 $

折半查找的优点是：查找效率高，平均查找长度较小。其缺点是：要求表中元素按关键字有序排列，且只能用于顺序存储结构。

由此可见，折半查找法在查找成功时进行比较的关键字个数最多不超过树的深度。而决策树的形态只与表记录个数 $ n $ 相关，与关键字的取值无关，具有 $ n^2 $ 节点的决策树的深度为 $ \lfloor \log n + 1 \rfloor $。所以，对于长度为 $ n $ 的有序表，折半查找法在查找成功时和给定值进行比较的关键字个数至多为 $ \lfloor \log n \rfloor + 1 $。

如果在图7.2所示的决策树中所有节点的空指针域上加一个指向一个方形节点的指针，如图7.3所示，并且称这些方形节点为决策树的外部节点（与之相对，称哪些圆形节点为内部节点），那么折半查找时查找失败的过程就是走了一条从根节点到外部节点的路径，和给定值进行比较的关键字个数等于该路径上内部节点个数。例如，查找6S的过程即走了一条从根到节点9～10的路径。因此，折半查找在查找不成功时和给定值进行比较的关键字个数最多也不超过 $ \log n + 1 $。

借助于决策树，很容易求得折半查找的平均查找长度。为讨论方便起见，假定有序表的长度 $ n = 2^k - 1 $，则决策树是深度为 $ n - \log(n + 1) $ 的满二叉树。树中层次为1的节点有1个，层次为2的节点有2个，依次类推，层次为 $ k $ 的节点有 $ 2^{k-1} $。假设表中每个记录的查找概率相等 $ p_i = \frac{1}{n} $，则查找成功时折半查找的平均查找长度为：

$
\begin{split}
\mathit{ASL} &= \sum_{i=1}^{n} p_i C_i \\
&= \frac{1}{n} \sum_{j=1}^{n} r_j 2^{j-1} \\
&= \frac{n+1}{n} \log_2(n+1) - 1
\end{split}
$

当 $ n $ 较大时，可有下列近似结果：

$
\mathit{ASL} = \log_2(n+1) - 1
$

因此，折半查找的时间复杂度为 $ O(\log_2 n) $。可见，折半查找的效率比顺序查找的高，但折半查找只适用于有序表，且限于顺序存储结构。

折半查找的优点是：比较次数少，查找效率高。其缺点是；对表结构要求高，只能用于顺序存储的有序表。采用折半查找前元素需要排序，而排序本身是一种费时的运算。同时为了保持顺序表的有序性，对有序表进行插入和删除时，平均比较和移动表中一半元素，这也是一种费时的运算。因此，折半查找不适用于数据元素经常变动的线性表。

以下是对该知识点的扩展与讲解：

**一、折半查找整体概述**

折半查找，也叫二分查找，是一种在特定条件下效率颇高的查找方法。它不像顺序查找那样逐个去比对元素，而是通过不断将查找范围缩小一半来快速定位目标元素。不过，它对数据的存储结构和元素的排列顺序有较为严格的要求哦。

**二、折半查找的条件及查找过程详细讲解**

1. **适用条件**：
折半查找要求线性表必须采用顺序存储结构，就好比数据要像数组那样一个挨着一个整齐地存放。而且表中元素按关键字必须有序排列，这里假设是有序递增的哦。要是数据不满足这两个条件，可就没法用折半查找啦。

2. **查找过程**：
它是从表的中间记录开始进行查找的哦。假如给定值和中间记录的关键字相等，那可就查找成功啦，直接返回中间位置就行。但要是给定值大于或者小于中间记录的关键字呢，那就根据情况在表中大于或小于中间记录的那一半中继续查找，然后不断重复这个操作，直到查找成功，或者在某一步中查找区间为空了，那就代表查找失败咯。

为了能清楚地标记查找过程中每一次的查找区间，我们用 `low` 和 `high` 来分别表示当前查找区间的下界和上界，`mid` 呢就是区间的中间位置啦。

**三、折半查找算法详细讲解**

1. **算法步骤**：
    - 首先要置查找区间初值呀，让 `low` 为1，`high` 为表长。这就相当于先划定了一个初始的查找范围哦。
    - 然后呢，当 `low <= high` 时，就进入循环啦。在循环里呢：
        - 先算出 `mid`，它是 `low` 和 `high` 的中间值哦。
        - 接着把给定值 `key` 与中间位置记录的关键字进行比较，如果相等，那太棒啦，就查找成功了，直接返回中间位置 `mid`。
        - 要是不相等呢，就利用中间位置记录把表对分成前、后两个子表。要是 `key` 比中间位置记录的关键字小，那就让 `high` 取为 `mid - 1`，意思就是接下来在前面那一半子里表继续找；要是 `key` 比中间位置记录的关键字大，那就让 `low` 取为 `mid + 1`，也就是到后面那一半子表去找啦。
    - 最后呢，当循环结束了，那就说明查找区间为空咯，这时候就查找失败了，返回0就行啦。

2. **算法示例分析**：
比如有个包含11个数据元素的有序表：$(5, 16, 20, 27, 30, 36, 44, 55, 60, 67, 71)$。我们来看查找关键字为27和65的过程哦。

查找关键字 `key = 27` 时：
    - 一开始，`low` 和 `high` 的初值分别为1和11，那 `mid` 初值就是 $\lfloor (1 + 11) / 2 \rfloor = 6$ 啦。
    - 先令给定值 `key = 27` 与中间位置的数据元素的关键字 `ST.R[mid].key` 相比较，发现 `36 > 27`，这就说明待查元素若存在，肯定在区间 `[low, mid - 1]` 内呀，所以就让指针 `high` 指向第 `mid - 1` 个元素，也就是 `high = 5`，然后重新求得 `mid = \lfloor (1 + 5) / 2 \rfloor = 3$。
    - 接着再比较，因为 `20 < 27`，说明待查元素若存在，必在区间 `[mid + 1, high]` 内，那就让指针 `low` 指向第 `mid + 1` 个元素，也就是 `low = 4`，再求得 `mid` 的新值为4，这时候比较 `key` 和 `ST.R[mid].key`，发现相等啦，那就查找成功了，返回所查元素在表中的序号，也就是指针 `mid` 的值4哦。

查找关键字 `key = 65` 时：
    - 同样的步骤哦，只是在最后一趟查找时，因为 `low > high`，这就说明查找区间不存在啦，也就意味着表中没有关键字等于65的元素，所以查找失败，返回0咯。

**四、折半查找的算法分析**

1. **决策树相关**：
折半查找过程可以用二叉树来描述呢，这个二叉树就叫折半查找的决策树哦。树中每一节点对应表中一个记录，不过节点值不是记录的关键字，而是记录在表中的位置序号。把当前查找区间的中间位置作为根，把左子表和右子表分别作为根的左子树和右子树，就得到了这个决策树啦。

比如刚才那个11个元素的有序表对应的决策树，从决策树上能看出来，成功的折半查找恰好是走了一条从决策树的根到被查节点的路径，经历比较的关键字个数就是该节点在树中的层次哦。像查找27的过程经过一条从根到节点4的路径，就需要比较3次，因为节点4在第3层呀。而且通过这个决策树，我们还能算出对长度为11的有序表进行折半查找的平均查找长度呢，就像前面算出来的 $ ASL = \frac{1 \times 1 + 2 \times 2 + 4 \times 3 + 4 \times 4}{11} = \frac{33}{11} = 3 $ 这样。

2. **时间复杂度及相关分析**：
折半查找的优点很明显呀，就是查找效率高，平均查找长度较小。它的时间复杂度是 $ O(\log_2 n) $，这可比顺序查找的效率高多啦。不过它也有缺点哦，要求表中元素按关键字有序排列，而且只能用于顺序存储结构。在采用折半查找前，元素得先排序，可排序本身就是个费时的运算呢。并且为了保持顺序表的有序性，对有序表进行插入和删除时，平均比较和移动表中一半元素，这也是个费时的运算呀。所以呢，折半查找不太适用于数据元素经常变动的线性表哦。

**以下是根据上述讲解生成的20个选择题及答案解析：**

**一、选择题**

1. 折半查找要求线性表必须采用（  ）存储结构。
A. 链式
B. 顺序
C. 散列
D. 树形

答案：B
解释：折半查找要求线性表必须采用顺序存储结构，所以选B。

2. 折半查找中，表中元素按关键字必须（  ）排列。
A. 无序
B. 有序递增
C. 有序递减
D. 随机

答案：B
解释：折半查找要求表中元素按关键字有序排列，在下面及后续的讨论中，均假设有序表是有序递增的，所以选B。

3. 在折半查找算法中，用来表示当前查找区间下界的变量是（  ）。
A. mid
B. high
C. low
D. key

答案：C
解释：在折半查找算法中，用 `low` 表示当前查找区间的下界，所以选C。

4. 折半查找时，若给定值大于中间记录的关键字，则接下来应在表中（  ）的那一半中查找。
A. 小于中间记录
B. 大于中间记录
C. 任意
D. 前半部分

答案：B
解释：折半查找时，若给定值大于中间记录的关键字，则接下来应在表中大于中间记录的那一半中查找，所以选B。

5. 折半查找算法中，循环执行的条件是（  ）。
A. low < high
B. low <= high
C. high < low
D. high <= low

答案：B
解释：折半查找算法中，循环执行的条件是 `low <= high`，因为 `low = high` 时，查找区间还有最后一个节点，还要进一步比较，所以选B。

6. 对于长度为11的有序表进行折半查找，假设每个记录的查找概率相同，其平均查找长度为（  ）。
A. 2
B. 3
C. 4
D. 5

答案：B
解释：已知对长度为11的有序表进行折半查找，根据计算 $ ASL = \frac{1 \times 1 + 2 \times 2 + 4 \times 3 + 4 \times 4}{11} = \frac{33}{11} = 3 $，所以选B。

7. 折半查找的优点是（  ）。
A. 对表结构无要求
B. 查找效率高，平均查找长度较小
C. 适用于各种数据结构
D. 不需要排序
答案：B
解释：折半查找的优点是查找效率高，平均查找长度较小，所以选B。

8. 折半查找的缺点是（  ）。
A. 查找效率低
B. 对表结构要求高，只能用于顺序存储的有序表
C. 算法复杂
D. 不能用于查找
答案：B
解释：折半查找的缺点是对表结构要求高，只能用于顺序存储的有序表，所以选B。

9. 折半查找过程可用（  ）来描述。
A. 线性表
B. 二叉树
C. 散列表
D. 数组

答案：B
解释：折半查找过程可用二叉树来描述，这个二叉树称为折半查找的决策树，所以选B。

10. 在折半查找的决策树中，节点值是（  ）。
A. 记录的关键字
B. 记录在表中的位置序号
C. 任意值
D. 查找区间的边界值
答案：B
解释：在折半查找的决策树中，节点值不是记录的关键字，而是记录在表中的位置序号，所以选B。
11. 查找关键字为27的过程经过一条从根到节点4的路径，在折半查找的决策树中，此路径上经历比较的关键字个数为（  ）。
A. 2
B. 3
C. 4
D. 5
答案：B
解释：查找关键字为27的过程经过一条从根到节点4的路径，在折半查找的决策树中，经历比较的关键字个数即为该节点在树中的层次，节点4在第3层，所以经历比较的关键字个数为3，选B。
12. 假设有序表长度 $ n = 2^k - 1 $，则决策树是深度为（  ）的满二叉树。
A. $ n - \log(n + 1) $
B. $ \log(n + 1) - 1 $
C. $ \log_2(n + 1) - 1 $
D. $ n + \log(n + 1) $
答案：A
解释：假设有序表长度 $ n = 2^k - 1 $，则决策树是深度为 $ n - \log(n + 1) $ 的满二叉树，所以选A。
13. 当 $ n $ 较大时，折半查找在查找成功时的平均查找长度近似结果为（  ）。
A. $ \log_2(n + 1) - 1 $
B. $ \log_2(n) - 1 $
C. $ \log_2(n + 1) + 1 $
D. $ \log_2(n) + 1 $
答案：A
解释：当 $ n $ 较大时，折半查找在查找成功时的平均查找长度近似结果为 $ \log_2(n + 1) - 1 $，所以选A。
14. 折半查找的时间复杂度为（  ）。
A. $ O(1) $
B. $ O(\log_2 n) $
C. $ O(n) $
D. $ O(n^2) $
答案：B
解释：折半查找的时间复杂度为 $ O(\log_2 n) $，所以选B。
15. 在折半查找过程中，若查找区间为空，则（  ）。
A. 查找成功
B. 查找失败
C. 继续查找
D. 重新设置查找区间
答案：B
解释：在折半查找过程中，若查找区间为空，则说明查找失败，所以选B。
16. 折半查找在查找不成功时和给定值进行比较的关键字个数最多不超过（  ）。
A. $ \log n + 1 $
B. $ \log_2 n + 1 $
C. $ \log n - 1 $
D. $ \log_2 n - 1 $
答案：B
解释：折半查找在查找不成功时和给定值进行比较的关键字个数最多不超过 $ \log_2 n + 1 $，所以选B。
17. 对于长度为 $ n $ 的有序表，折半查找法在查找成功时和给定值进行比较的关键字个数至多为（  ）。
A. $ \lfloor \log n \rfloor + 1 $
B. $ \lfloor \log_2 n \rfloor + 1 $
C. $ \lfloor \log n \rfloor - 1 $
D. $ \lfloor \log_2 n \rfloor - 1 $
答案：B
解释：对于长度为 $ n $ 的有序表，折半查找法在查找成功时和给定值进行 比较的关键字个数至多为 $ \lfloor \log_2 n \rfloor + 1 $，所以选B。
18. 在折半查找的决策树中，称圆形节点为（  ）。
A. 外部节点
B. 内部节点
C. 中间节点
D. 根节点
答案：B
解释：在折半查找的决策树中，称圆形节点为内部节点，与之相对，方形节点为外部节点，所以选B。
19. 若要实现折半查找的递归算法，除了 `ST` 和 `key` 之外，还需要加上（  ）作为参数。
A. low和high
B. mid
C. 任意值
D. 不需要加其他参数
答案：A
解释：实现折半查找的递归算法，除了 `ST` 和 `key` 之外，还需要加上 `low` 和 `high` 作为参数，所以选A。
20. 折半查找不适用于（  ）的线性表。
A. 数据元素经常变动
B. 数据元素不经常变动
C. 有序
D. 无序
答案：A
解释：折半查找不适用于数据元素经常变动的线性表，因为为了保持顺序表的有序性，对有序表进行插入和删除时，平均比较和移动表中一半元素，这是一种费时的运算，所以选A。

### 折半查找（Binary Search）

折半查找，也称为二分查找，是一种高效的查找算法。它适用于有序的顺序存储结构，并且要求表中的元素按关键字有序排列。通常情况下，假设有序表是递增有序的。

#### 折半查找的基本过程

1. **初始化查找区间**：设定查找区间的下界 `low` 为 1，上界 `high` 为表的长度。
2. **循环查找**：当 `low` 小于或等于 `high` 时，执行以下操作：
   - 计算中间位置 `mid`，即 `mid = \lfloor (low + high) / 2 \rfloor`。
   - 比较给定值 `key` 与中间位置记录的关键字 `ST.R[mid].key`：
     - 如果 `key` 等于 `ST.R[mid].key`，则查找成功，返回 `mid`。
     - 如果 `key` 小于 `ST.R[mid].key`，则将查找区间缩小到前半部分，即 `high = mid - 1`。
     - 如果 `key` 大于 `ST.R[mid].key`，则将查找区间缩小到后半部分，即 `low = mid + 1`。
3. **查找失败**：如果循环结束时 `low` 大于 `high`，则查找区间为空，查找失败，返回 0。

#### 算法描述

```c
int SearchBin(SSTable ST, KeyType key) {
    int low = 1, high = ST.length; // 置查找区间初值
    while (low <= high) {
        int mid = (low + high) / 2;
        if (key == ST.R[mid].key) {
            return mid; // 找到待查元素
        } else if (key < ST.R[mid].key) {
            high = mid - 1; // 继续在前一子表进行查找
        } else {
            low = mid + 1; // 继续在后一子表进行查找
        }
    } // while
    return 0; // 表中不存在待查元素
}
```

#### 折半查找的决策树

折半查找的过程可以用二叉树来描述，称为决策树。树中的每个节点对应表中的一个记录，节点值是记录在表中的位置序号。根节点是当前查找区间的中间位置，左子树和右子树分别对应左半部分和右半部分的子表。

#### 平均查找长度（ASL）

假设有序表的长度为 $ n = 2^k - 1 $，则决策树是深度为 $ k $ 的满二叉树。树中层次为 $ j $ 的节点有 $ 2^{j-1} $ 个。假设每个记录的查找概率相等，则查找成功时的平均查找长度为：

$
\begin{split}
\mathit{ASL} &= \sum_{i=1}^{n} p_i C_i \\
&= \frac{1}{n} \sum_{j=1}^{n} r_j 2^{j-1} \\
&= \frac{n+1}{n} \log_2(n+1) - 1
\end{split}
$

当 $ n $ 较大时，近似结果为：

$
\mathit{ASL} = \log_2(n+1) - 1
$

因此，折半查找的时间复杂度为 $ O(\log_2 n) $。

### 选择题

1. **折半查找适用于哪种数据结构？**
   - A. 链表
   - B. 有序数组
   - C. 无序数组
   - D. 哈希表

   **答案：B**
   **解释：** 折半查找要求数据结构是有序的顺序存储结构，即有序数组。

2. **折半查找的时间复杂度是多少？**
   - A. $ O(1) $
   - B. $ O(\log n) $
   - C. $ O(n) $
   - D. $ O(n^2) $

   **答案：B**
   **解释：** 折半查找的时间复杂度为 $ O(\log n) $。

3. **在折半查找中，查找区间为空的条件是什么？**
   - A. `low < high`
   - B. `low > high`
   - C. `low == high`
   - D. `low >= high`

   **答案：B**
   **解释：** 当 `low` 大于 `high` 时，查找区间为空。

4. **折半查找的平均查找长度（ASL）近似为多少？**
   - A. $ \log_2 n $
   - B. $ \log_2(n+1) - 1 $
   - C. $ n $
   - D. $ n \log_2 n $

   **答案：B**
   **解释：** 折半查找的平均查找长度近似为 $ \log_2(n+1) - 1 $。

5. **在折半查找中，如果 `key` 小于中间位置记录的关键字，下一步应该如何操作？**
   - A. `high = mid + 1`
   - B. `low = mid + 1`
   - C. `high = mid - 1`
   - D. `low = mid - 1`

   **答案：C**
   **解释：** 如果 `key` 小于中间位置记录的关键字，则将查找区间缩小到前半部分，即 `high = mid - 1`。

6. **折半查找的决策树中，查找成功时的比较次数最多为多少？**
   - A. $ \log n $
   - B. $ \log n + 1 $
   - C. $ n $
   - D. $ n^2 $

   **答案：B**
   **解释：** 查找成功时的比较次数最多为 $ \log n + 1 $。

7. **折半查找的决策树中，查找失败时的比较次数最多为多少？**
   - A. $ \log n $
   - B. $ \log n + 1 $
   - C. $ n $
   - D. $ n^2 $

   **答案：B**
   **解释：** 查找失败时的比较次数最多为 $ \log n + 1 $。

8. **折半查找的决策树中，层次为 $ j $ 的节点有多少个？**
   - A. $ j $
   - B. $ 2^j $
   - C. $ 2^{j-1} $
   - D. $ j^2 $

   **答案：C**
   **解释：** 层次为 $ j $ 的节点有 $ 2^{j-1} $ 个。

9. **折半查找的决策树中，树的深度为多少？**
   - A. $ \log n $
   - B. $ \log n + 1 $
   - C. $ n $
   - D. $ n^2 $

   **答案：B**
   **解释：** 决策树的深度为 $ \log n + 1 $。

10. **折半查找的决策树中，查找成功时的平均查找长度为多少？**
    - A. $ \log n $
    - B. $ \log n + 1 $
    - C. $ \frac{n+1}{n} \log_2(n+1) - 1 $
    - D. $ n $

    **答案：C**
    **解释：** 查找成功时的平均查找长度为 $ \frac{n+1}{n} \log_2(n+1) - 1 $。

11. **折半查找的决策树中，查找失败时的平均查找长度为多少？**
    - A. $ \log n $
    - B. $ \log n + 1 $
    - C. $ \frac{n+1}{n} \log_2(n+1) - 1 $
    - D. $ n $

    **答案：B**
    **解释：** 查找失败时的平均查找长度为 $ \log n + 1 $。

12. **折半查找的决策树中，查找成功时的比较次数最少为多少？**
    - A. 1
    - B. 2
    - C. $ \log n $
    - D. $ n $

    **答案：A**
    **解释：** 查找成功时的比较次数最少为 1 次，即直接找到目标元素。

13. **折半查找的决策树中，查找失败时的比较次数最少为多少？**
    - A. 1
    - B. 2
    - C. $ \log n $
    - D. $ n $

    **答案：A**
    **解释：** 查找失败时的比较次数最少为 1 次，即直接确定目标元素不在查找区间内。

14. **折半查找的决策树中，查找成功时的比较次数最多为多少？**
    - A. $ \log n $
    - B. $ \log n + 1 $
    - C. $ n $
    - D. $ n^2 $

    **答案：B**
    **解释：** 查找成功时的比较次数最多为 $ \log n + 1 $。

15. **折半查找的决策树中，查找失败时的比较次数最多为多少？**
    - A. $ \log n $
    - B. $ \log n + 1 $
    - C. $ n $
    - D. $ n^2 $

    **答案：B**
    **解释：** 查找失败时的比较次数最多为 $ \log n + 1 $。

16. **折半查找的决策树中，查找成功时的平均查找长度为多少？**
    - A. $ \log n $
    - B. $ \log n + 1 $
    - C. $ \frac{n+1}{n} \log_2(n+1) - 1 $
    - D. $ n $

    **答案：C**
    **解释：** 查找成功时的平均查找长度为 $ \frac{n+1}{n} \log_2(n+1) - 1 $。

17. **折半查找的决策树中，查找失败时的平均查找长度为多少？**
    - A. $ \log n $
    - B. $ \log n + 1 $
    - C. $ \frac{n+1}{n} \log_2(n+1) - 1 $
    - D. $ n $

    **答案：B**
    **解释：** 查找失败时的平均查找长度为 $ \log n + 1 $。

18. **折半查找的决策树中，查找成功时的比较次数最少为多少？**
    - A. 1
    - B. 2
    - C. $ \log n $
    - D. $ n $

    **答案：A**
    **解释：** 查找成功时的比较次数最少为 1 次，即直接找到目标元素。

19. **折半查找的决策树中，查找失败时的比较次数最少为多少？**
    - A. 1
    - B. 2
    - C. $ \log n $
    - D. $ n $

    **答案：A**
    **解释：** 查找失败时的比较次数最少为 1 次，即直接确定目标元素不在查找区间内。

20. **折半查找的决策树中，查找成功时的比较次数最多为多少？**
    - A. $ \log n $
    - B. $ \log n + 1 $
    - C. $ n $
    - D. $ n^2 $

    **答案：B**
    **解释：** 查找成功时的比较次数最多为 $ \log n + 1 $。

1. **前提条件**
   - 已知有序表的长度$n = 2^{h}-1$，其中$h$是决策树的深度。
   - 决策树是一棵满二叉树，层次为$j$的节点有$2^{j - 1}$个。
   - 假设表中每个记录的查找概率相等，即$p_{i}=\frac{1}{n}$。

2. **平均查找长度（ASL）的定义**
   - 平均查找长度$ASL=\sum_{i = 1}^{n}p_{i}C_{i}$，其中$p_{i}$是查找第$i$个记录的概率，$C_{i}$是找到第$i$个记录时比较的关键字个数。

3. **推导过程**
   - 因为$p_{i}=\frac{1}{n}$，所以$ASL=\frac{1}{n}\sum_{i = 1}^{n}C_{i}$。
   - 在折半查找的决策树中，层次为$j$的节点有$2^{j-1}$个，且每个节点在该层次上进行了$j$次比较。
   - 我们对所有层次的节点进行求和。决策树的深度为$h=\log_{2}(n + 1)$。
   - 那么$ASL=\frac{1}{n}\sum_{j = 1}^{h}j\cdot2^{j - 1}$（这一步是根据决策树中每层节点数和比较次数得出的）。

   - 接下来求$\sum_{j = 1}^{h}j\cdot2^{j - 1}$的值：
     - 设$S=\sum_{j = 1}^{h}j\cdot2^{j - 1}=1\times2^{0}+2\times2^{1}+3\times2^{2}+\cdots+h\times2^{h - 1}$。
     - 两边同乘以$2$得：$2S = 1\times2^{1}+2\times2^{2}+3\times2^{3}+\cdots+h\times2^{h}$。
     - 用$2S - S$得：
       - $2S-S=-1\times2^{0}+(2 - 1)\times2^{1}+(3 - 2)\times2^{2}+\cdots+(h-(h - 1))\times2^{h - 1}+h\times2^{h}$。
       - 即$S=h\times2^{h}-(2^{0}+2^{1}+2^{2}+\cdots+2^{h - 1})$。
       - 根据等比数列求和公式$\sum_{k = 0}^{m - 1}a\times r^{k}=a\frac{1 - r^{m}}{1 - r}$，这里$a = 1$，$r = 2$，$m=h$，则$2^{0}+2^{1}+2^{2}+\cdots+2^{h - 1}=2^{h}-1$。
       - 所以$S=h\times2^{h}-(2^{h}-1)=(h - 1)2^{h}+1$。

   - 因为$h=\log_{2}(n + 1)$，所以$S=(h - 1)2^{h}+1=( \log_{2}(n + 1)-1)(n + 1)+1$。
   - 则$ASL=\frac{1}{n}\sum_{j = 1}^{h}j\cdot2^{j - 1}=\frac{1}{n}S=\frac{1}{n}[( \log_{2}(n + 1)-1)(n + 1)+1]$。
   - 进一步化简：
     - $ASL=\frac{1}{n}[( \log_{2}(n + 1)-1)(n + 1)+1]$
     - $=\frac{1}{n}[(n + 1)\log_{2}(n + 1)-(n + 1)+1]$
     - $=\frac{n + 1}{n}\log_{2}(n + 1)-1$

所以，当$n = 2^{h}-1$时，折半查找的平均查找长度$ASL=\frac{n + 1}{n}\log_{2}(n + 1)-1$。

1. **回顾平均查找长度公式**
   - 已知平均查找长度$ASL = \sum_{i = 1}^{n}p_{i}C_{i}$，在折半查找且每个记录查找概率相等$p_{i}=\frac{1}{n}$的情况下，$ASL=\frac{1}{n}\sum_{i = 1}^{n}C_{i}$。
   - 对于长度为$n = 2^{h}-1$的有序表，其对应的决策树是深度为$h=\log_{2}(n + 1)$的满二叉树，层次为$j$的节点有$2^{j - 1}$个，且每个节点在该层次上进行了$j$次比较，所以$ASL=\frac{1}{n}\sum_{j = 1}^{h}j\cdot2^{j - 1}$。

2. **利用级数积分方法推导**
   - 设$S=\sum_{j = 1}^{h}j\cdot2^{j - 1}$，考虑函数$f(x)=\sum_{j = 1}^{\infty}j\cdot x^{j - 1}$，$|x|<1$。
   - 对$f(x)$积分：
     - 先对$f(x)$求原函数$F(x)$，$\int f(x)dx=\sum_{j = 1}^{\infty}\int j\cdot x^{j - 1}dx=\sum_{j = 1}^{\infty}x^{j}$。
     - 根据等比级数求和公式$\sum_{j = 1}^{\infty}x^{j}=\frac{x}{1 - x}$，$|x|<1$。 从这里开始错了，$|x| = 2$
   - 对$\frac{x}{1 - x}$求导得到$f(x)$：
     - $f(x)=\left(\frac{x}{1 - x}\right)^\prime=\frac{1}{(1 - x)^{2}}$。
   - 现在我们回到$S$，令$x = 2$（这里要注意收敛性问题，虽然原级数$f(x)$在$|x|<1$收敛，但我们可以通过分析方法得到结果）：
     - 当$x = 2$时，$\sum_{j = 1}^{h}j\cdot2^{j - 1}$是$f(2)$的部分和。
     - 我们有$S=\sum_{j = 1}^{h}j\cdot2^{j - 1}\approx\int_{0}^{h}j\cdot2^{j - 1}dj$（这里用积分近似求和）。
   - 计算$\int_{0}^{h}j\cdot2^{j - 1}dj$：
     - 令$u = j$，$dv=2^{j - 1}dj$，则$du = dj$，$v=\frac{2^{j}}{\ln 2}$。
     - 根据分部积分法$\int u dv=uv-\int v du$，可得：
       - $\int_{0}^{h}j\cdot2^{j - 1}dj=\left[\frac{j\cdot2^{j}}{\ln 2}\right]_{0}^{h}-\int_{0}^{h}\frac{2^{j}}{\ln 2}dj$。
       - $\left[\frac{j\cdot2^{j}}{\ln 2}\right]_{0}^{h}=\frac{h\cdot2^{h}}{\ln 2}$。
       - $\int_{0}^{h}\frac{2^{j}}{\ln 2}dj=\left[\frac{2^{j}}{(\ln 2)^{2}}\right]_{0}^{h}=\frac{2^{h}- 1}{(\ln 2)^{2}}$。
     - 所以$\int_{0}^{h}j\cdot2^{j - 1}dj=\frac{h\cdot2^{h}}{\ln 2}-\frac{2^{h}- 1}{(\ln 2)^{2}}$。

3. **计算平均查找长度**
   - 因为$n = 2^{h}-1$，$h=\log_{2}(n + 1)$。
   - $ASL=\frac{1}{n}\sum_{j = 1}^{h}j\cdot2^{j - 1}=\frac{1}{n}\left(\frac{h\cdot2^{h}}{\ln 2}-\frac{2^{h}- 1}{(\ln 2)^{2}}\right)$。
   - 将$h=\log_{2}(n + 1)$代入：
     - $ASL=\frac{1}{n}\left[\frac{\log_{2}(n + 1)\cdot(n + 1)}{\ln 2}-\frac{n + 1 - 1}{(\ln 2)^{2}}\right]$。
     - 化简可得$ASL=\frac{n + 1}{n}\log_{2}(n + 1)-1$。

通过级数积分方法，我们得到了折半查找在特定条件下平均查找长度的表达式。

### 7.2.3 分块查找

分块查找（Blocking Search）又称索引顺序查找，这是一种性能介于顺序查找和折半查找之间的查找方法。在此查找方法中，除表本身以外，尚需建立一个“索引表”。例如，图7-4所示为一个表及其索引表，表中含有18个记录，可分成3个子表($R_{1}$,$R_{2}$,…,$R_{6}$)、($R_{7}$,$R_{8}$,…,$R_{12}$)、($R_{13}$, $R_{14}$,…,$R_{18}$)，对每个子表（或称块）建立一个索引项，其中包括两项内容；关键字项（其值为该子表内的最大关键字）和指针项（指示该子表的第一个记录在表中的位置）。索引表按关键字有序，则表有序或者分块有序。所谓“分块有序”指的是第二个子表中所有记录的关键字均大于第一个子表中的最大关键字，第三个子表中的所有关键字均大于第二个子表中的最大关键字，依次类推。

因此，分块查找过程需分两步进行。先确定待查记录所在的块（子表），然后在块中顺序查找。假设给定值 $ key = 38 $，则先将 $ key $ 依次和索引表中各分块的最大关键字进行比较，因为 22 < $ key $ < 48，则关键字为 38 的记录若存在，必定在第二个子表中。由于同一索引项中的指针指示第二个子表中的第一个记录是表中第7个记录，则自第7个记录起进行顺序查找，直到 $ ST.elem[10] = key $ 为止。假如此子表中没有关键字等于 $ key $ 的记录（例如，$ key = 29 $ 时自第7个记录起至第12个记录的关键字和 $ key $ 都不等），则查找不成功。

由于由索引项组成的索引表按关键字有序，则确定块的查找可以用顺序查找，亦可用折半查找，而块中记录是任意排列的，则在块中只能用顺序查找。

由此，分块查找的算法为顺序查找和折半查找两种算法的简单合成。

分块查找的平均查找长度为：

$
ASL_{u} = L_{s} + L_{v}
$

其中，$ L_{s} $ 为查找索引表确定所在块的平均查找长度，$ L_{v} $ 为在块中查找元素的平均查找长度。

一般情况下，为进行分块查找，可以将长度为 $ n $ 的表均匀地分成 $ b $ 块，每块含有 $ s $ 个记录，即 $ b = \lceil n/s \rceil $；又假定表中每个记录的查找概率相等，则每块查找的概率为 $ 1/b $，块中每个记录的查找概率为 $ 1/s $。

若用顺序查找确定所在块，则分块查找的平均查找长度为：

$
ASL_{u} = L_{s} + L_{v} = \frac{1}{b} \sum_{j=1}^{b} j + \frac{1}{s} \sum_{i=1}^{s} i = \frac{b+1}{2} + \frac{s+1}{2}
$

$
= \frac{1}{2} \left( \frac{n}{s} + s \right) + 1
$

可见，此时的平均查找长度不仅和表长 $ n $ 有关，而且和每一块中的记录个数 $ s $ 有关系。在给定的前提下，$ s $ 是可以选择的。容易证明，当 $ s $ 取最小值 $ \sqrt{n} + 1 $ 时，$ ASL_{u} $ 取得最小值。结果表明，分块查找比顺序查找有了很大改进，但远不及折半查找。

若用折半查找确定所在块，则分块查找的平均查找长度为：

$
ASL'_{u} \approx \log_{2} \left( \frac{n}{s} + 1 \right) + \frac{s}{2}
$

分块查找的优点是：在表中插入和删除数据元素时，只要找到该元素对应的块，就可以在该块内进行插入和删除运算。由于块内是无序的，故插入和删除比较容易，无须进行大量移动。如果线性表既经常动态变化，又需对其进行快速查找，则可采用分块查找。其缺点是：要增加一个索引表的存储空间并对初始索引表进行排序运算。

### 扩展讲解

分块查找是一种在顺序查找和折半查找之间的查找方法，它通过建立索引表来提高查找效率。索引表中的每个索引项包含关键字项和指针项，关键字项是该子表内的最大关键字，指针项指示该子表的第一个记录在表中的位置。分块查找的过程分为两步：首先在索引表中确定待查记录所在的块，然后在该块中进行顺序查找。

分块查找的平均查找长度（ASL）由两部分组成：查找索引表确定所在块的平均查找长度（Ls）和在块中查找元素的平均查找长度（Lv）。分块查找的平均查找长度可以用以下公式表示：

\[ ASL_{u} = L_{s} + L_{v} \]

其中，Ls 可以通过顺序查找或折半查找来确定，而Lv则是在块中进行顺序查找的平均查找长度。

为了进行分块查找，表被均匀分成b块，每块含有s个记录，即 \( b = \lceil n/s \rceil \)。如果使用顺序查找确定所在块，分块查找的平均查找长度为：

\[ ASL_{u} = \frac{1}{b} \sum_{j=1}^{b} j + \frac{1}{s} \sum_{i=1}^{s} i = \frac{b+1}{2} + \frac{s+1}{2} = \frac{1}{2} \left( \frac{n}{s} + s \right) + 1 \]

这个公式表明，平均查找长度不仅和表长n有关，而且和每一块中的记录个数s有关系。当s取最小值 \( \sqrt{n} + 1 \) 时，ASLu取得最小值。

如果使用折半查找确定所在块，分块查找的平均查找长度为：

\[ ASL'_{u} \approx \log_{2} \left( \frac{n}{s} + 1 \right) + \frac{s}{2} \]

分块查找的优点是插入和删除操作相对容易，因为块内是无序的，不需要大量移动。缺点是需要额外的索引表存储空间，并且需要对初始索引表进行排序。

### 选择题及答案解析

1. **分块查找也被称为什么？**
   - A. 顺序查找
   - B. 索引顺序查找
   - C. 折半查找
   - D. 线性查找
   **答案：B**  
   **解析：** 分块查找又称为索引顺序查找，因为它通过索引表来提高查找效率。

2. **分块查找中，索引表的索引项包含哪两项内容？**
   - A. 关键字项和指针项
   - B. 表长和块长
   - C. 块数和记录数
   - D. 顺序号和块号
   **答案：A**  
   **解析：** 索引项包含关键字项（子表内最大关键字）和指针项（指示子表的第一个记录位置）。

3. **分块有序是指什么？**
   - A. 每个子表中的记录是有序的
   - B. 子表之间是有序的
   - C. 整个表是有序的
   - D. 索引表是有序的
   **答案：B**  
   **解析：** 分块有序指的是子表之间有序，即每个子表中的记录关键字都大于前一个子表中的最大关键字。

4. **在分块查找中，如果给定值key=38，应该在哪个子表中查找？**
   - A. 第一个子表
   - B. 第二个子表
   - C. 第三个子表
   - D. 不能确定
   **答案：B**  
   **解析：** 根据索引表中的最大关键字，key=38应该在第二个子表中查找。

5. **分块查找的平均查找长度ASLu由哪两部分组成？**
   - A. Ls和Lv
   - B. n和s
   - C. b和s
   - D. n和b
   **答案：A**  
   **解析：** ASLu由查找索引表确定所在块的平均查找长度Ls和在块中查找元素的平均查找长度Lv组成。

6. **如果使用顺序查找确定所在块，分块查找的平均查找长度公式是什么？**
   - A. \( ASL_{u} = \frac{b+1}{2} + \frac{s+1}{2} \)
   - B. \( ASL_{u} = \frac{1}{2} \left( \frac{n}{s} + s \right) + 1 \)
   - C. \( ASL_{u} = \log_{2} \left( \frac{n}{s} + 1 \right) + \frac{s}{2} \)
   - D. \( ASL_{u} = \frac{n}{s} + s \)
   **答案：B**  
   **解析：** 使用顺序查找确定所在块时，ASLu的公式为 \( \frac{1}{2} \left( \frac{n}{s} + s \right) + 1 \)。

7. **当s取最小值时，ASLu取得什么值？**
   - A. 最大值
   - B. 最小值
   - C. 固定值
   - D. 不确定
   **答案：B**  
   **解析：** 当s取最小值 \( \sqrt{n} + 1 \) 时，ASLu取得最小值。

8. **如果使用折半查找确定所在块，分块查找的平均查找长度公式是什么？**
   - A. \( ASL_{u} = \frac{b+1}{2} + \frac{s+1}{2} \)
   - B. \( ASL_{u} = \frac{1}{2} \left( \frac{n}{s} + s \right) + 1 \)
   - C. \( ASL'_{u} \approx \log_{2} \left( \frac{n}{s} + 1 \right) + \frac{s}{2} \)
   - D. \( ASL_{u} = \frac{n}{s} + s \)
   **答案：C**  
   **解析：** 使用折半查找确定所在块时，ASLu的公式为 \( \log_{2} \left( \frac{n}{s} + 1 \right) + \frac{s}{2} \)。

9. **分块查找的优点是什么？**
   - A. 查找速度快
   - B. 插入和删除操作容易
   - C. 需要的存储空间小
   - D. 计算简单
   **答案：B**  
   **解析：** 分块查找的优点是插入和删除操作相对容易，因为块内是无序的，不需要大量移动。

10. **分块查找的缺点是什么？**
    - A. 插入和删除操作困难
    - B. 需要额外的索引表存储空间
    - C. 查找速度慢
    - D. 计算复杂
    **答案：B**  
    **解析：** 分块查找的缺点是需要额外的索引表存储空间，并且需要对初始索引表进行排序运算。

11. **分块查找适用于哪种情况？**
    - A. 表中数据不经常变化
    - B. 表中数据经常变化且需要快速查找
    - C. 表中数据不需要查找
    - D. 表中数据经常变化但不需要查找
    **答案：B**  
    **解析：** 分块查找适用于表中数据经常变化且需要快速查找的情况。

12. **在分块查找中，如果表长为n，分成b块，每块含有s个记录，那么b的计算公式是什么？**
    - A. \( b = n/s \)
    - B. \( b = \lceil n/s \rceil \)
    - C. \( b = \lfloor n/s \rfloor \)
    - D. \( b = n \times s \)
    **答案：B**  
    **解析：** b的计算公式为 \( b = \lceil n/s \rceil \)，表示将表均匀分成b块。

13. **分块查找中，每块查找的概率是多少？**
    - A. 1/n
    - B. 1/b
    - C. 1/s
    - D. 1/(n+1)
    **答案：B**  
    **解析：** 每块查找的概率为1/b，因为假设表中每个记录的查找概率相等。

14. **分块查找中，块中每个记录的查找概率是多少？**
    - A. 1/n
    - B. 1/b
    - C. 1/s
    - D. 1/(n+1)
    **答案：C**  
    **解析：** 块中每个记录的查找概率为1/s，因为每块中有s个记录。

15. **分块查找的平均查找长度ASLu与表长n和每一块中的记录个数s的关系是什么？**
    - A. 与n和s都无关
    - B. 只与n有关
    - C. 只与s有关
    - D. 与n和s都有关
    **答案：D**  
    **解析：** ASLu与表长n和每一块中的记录个数s都有关系。

16. **在分块查找中，如果使用顺序查找确定所在块，ASLu的最小值是在什么情况下取得的？**
    - A. 当s取最大值时
    - B. 当s取最小值 \( \sqrt{n} + 1 \) 时
    - C. 当s取任意值时
    - D. 当s取表长n时
    **答案：B**  
    **解析：** ASLu的最小值是在s取最小值 \( \sqrt{n} + 1 \) 时取得的。

17. **分块查找中，索引表是按照什么顺序排列的？**
    - A. 无序
    - B. 随机顺序
    - C. 关键字有序
    - D. 块号顺序
    **答案：C**  
    **解析：** 索引表是按照关键字有序排列的。

18. **分块查找中，块内记录的排列顺序是什么？**
    - A. 有序
    - B. 无序
    - C. 随机顺序
    - D. 块号顺序
    **答案：B**  
    **解析：** 块内记录是无序的。

### 7.2.3 分块查找的扩展讲解

分块查找（Blocking Search）是一种结合了顺序查找和折半查找优点的查找方法。它的核心思想是将一个大的数据表分成若干个小的子表（或称块），并为每个子表建立一个索引项。索引项包含两个关键信息：子表中的最大关键字和该子表在数据表中的起始位置。通过这种方式，分块查找可以快速定位到可能包含目标记录的子表，然后在子表内进行顺序查找。

#### 分块查找的步骤：
1. **确定块（子表）**：首先，将目标关键字与索引表中的各块最大关键字进行比较，确定目标关键字可能所在的块。这一步可以使用顺序查找或折半查找。
2. **块内查找**：在确定块后，在该块内进行顺序查找，直到找到目标关键字或确定目标关键字不存在。

#### 分块查找的平均查找长度：
分块查找的平均查找长度（ASL）由两部分组成：查找索引表确定所在块的平均查找长度（$L_s$）和在块中查找元素的平均查找长度（$L_v$）。具体公式如下：

- **顺序查找确定块**：
  \[
  ASL_u = L_s + L_v = \frac{1}{b} \sum_{j=1}^{b} j + \frac{1}{s} \sum_{i=1}^{s} i = \frac{b+1}{2} + \frac{s+1}{2} = \frac{1}{2} \left( \frac{n}{s} + s \right) + 1
  \]
  其中，$b$ 是块的数量，$s$ 是每块的记录数，$n$ 是总记录数。

- **折半查找确定块**：
  \[
  ASL'_u \approx \log_{2} \left( \frac{n}{s} + 1 \right) + \frac{s}{2}
  \]

#### 分块查找的优缺点：
- **优点**：
  - 插入和删除操作相对容易，只需在对应的块内进行，无需大量移动数据。
  - 适用于动态变化频繁且需要快速查找的场景。

- **缺点**：
  - 需要额外的存储空间来存储索引表。
  - 初始时需要对索引表进行排序运算。

### 选择题

1. **分块查找的基本思想是什么？**
   A. 将数据表分成若干个子表，并为每个子表建立索引项
   B. 对整个数据表进行折半查找
   C. 对整个数据表进行顺序查找
   D. 对数据表进行哈希查找

   **答案**：A
   **解释**：分块查找的基本思想是将数据表分成若干个子表，并为每个子表建立索引项，以便快速定位目标记录所在的块。

2. **在分块查找中，索引表的作用是什么？**
   A. 存储数据表的所有记录
   B. 存储每个子表的最大关键字和起始位置
   C. 存储数据表的排序信息
   D. 存储数据表的哈希值

   **答案**：B
   **解释**：索引表的作用是存储每个子表的最大关键字和该子表在数据表中的起始位置，以便快速定位目标记录所在的块。

3. **分块查找中，确定块的查找可以使用哪种方法？**
   A. 只能使用顺序查找
   B. 只能使用折半查找
   C. 可以使用顺序查找或折半查找
   D. 只能使用哈希查找

   **答案**：C
   **解释**：确定块的查找可以使用顺序查找或折半查找，具体取决于索引表的组织方式。

4. **在分块查找中，块内查找通常使用哪种方法？**
   A. 顺序查找
   B. 折半查找
   C. 哈希查找
   D. 二叉查找

   **答案**：A
   **解释**：由于块内记录是无序的，因此在块内查找通常使用顺序查找。

5. **分块查找的平均查找长度（ASL）由哪两部分组成？**
   A. 查找索引表的平均查找长度和块内查找的平均查找长度
   B. 查找数据表的平均查找长度和块内查找的平均查找长度
   C. 查找索引表的平均查找长度和查找数据表的平均查找长度
   D. 查找块的平均查找长度和查找数据表的平均查找长度

   **答案**：A
   **解释**：分块查找的平均查找长度由查找索引表确定所在块的平均查找长度和在块中查找元素的平均查找长度两部分组成。

6. **假设一个数据表有100个记录，分成10个块，每块10个记录，使用顺序查找确定块，分块查找的平均查找长度是多少？**
   A. 10
   B. 11
   C. 12
   D. 13

   **答案**：B
   **解释**：根据公式 $ASL_u = \frac{1}{2} \left( \frac{n}{s} + s \right) + 1$，代入 $n=100$，$s=10$，得到 $ASL_u = \frac{1}{2} \left( \frac{100}{10} + 10 \right) + 1 = \frac{1}{2} \times 20 + 1 = 11$。

7. **在分块查找中，如果使用折半查找确定块，分块查找的平均查找长度公式是什么？**
   A. $ASL'_u \approx \log_{2} \left( \frac{n}{s} + 1 \right) + \frac{s}{2}$
   B. $ASL'_u \approx \log_{2} \left( \frac{n}{s} \right) + \frac{s}{2}$
   C. $ASL'_u \approx \log_{2} \left( \frac{n}{s} + 1 \right) + s$
   D. $ASL'_u \approx \log_{2} \left( \frac{n}{s} \right) + s$

   **答案**：A
   **解释**：使用折半查找确定块时，分块查找的平均查找长度公式为 $ASL'_u \approx \log_{2} \left( \frac{n}{s} + 1 \right) + \frac{s}{2}$。

8. **分块查找的优点不包括以下哪一项？**
   A. 插入和删除操作相对容易
   B. 适用于动态变化频繁且需要快速查找的场景
   C. 需要额外的存储空间来存储索引表
   D. 查找速度比折半查找快

   **答案**：D
   **解释**：分块查找的查找速度比折半查找慢，但比顺序查找快。

9. **在分块查找中，块内记录的排列方式是什么？**
   A. 有序排列
   B. 无序排列
   C. 按关键字大小排列
   D. 按插入顺序排列

   **答案**：B
   **解释**：在分块查找中，块内记录是无序排列的。

10. **分块查找的缺点是什么？**
    A. 插入和删除操作复杂
    B. 查找速度慢
    C. 需要额外的存储空间来存储索引表
    D. 不适用于动态变化频繁的场景

    **答案**：C
    **解释**：分块查找的缺点是需要额外的存储空间来存储索引表，并且初始时需要对索引表进行排序运算。

11. **假设一个数据表有1000个记录，分成100个块，每块10个记录，使用顺序查找确定块，分块查找的平均查找长度是多少？**
    A. 10
    B. 11
    C. 12
    D. 13

    **答案**：C
    **解释**：根据公式 $ASL_u = \frac{1}{2} \left( \frac{n}{s} + s \right) + 1$，代入 $n=1000$，$s=10$，得到 $ASL_u = \frac{1}{2} \left( \frac{1000}{10} + 10 \right) + 1 = \frac{1}{2} \times 110 + 1 = 56$。

12. **在分块查找中，如果使用折半查找确定块，分块查找的平均查找长度公式是什么？**
    A. $ASL'_u \approx \log_{2} \left( \frac{n}{s} + 1 \right) + \frac{s}{2}$
    B. $ASL'_u \approx \log_{2} \left( \frac{n}{s} \right) + \frac{s}{2}$
    C. $ASL'_u \approx \log_{2} \left( \frac{n}{s} + 1 \right) + s$
    D. $ASL'_u \approx \log_{2} \left( \frac{n}{s} \right) + s$

    **答案**：A
    **解释**：使用折半查找确定块时，分块查找的平均查找长度公式为 $ASL'_u \approx \log_{2} \left( \frac{n}{s} + 1 \right) + \frac{s}{2}$。

13. **分块查找的优点不包括以下哪一项？**
    A. 插入和删除操作相对容易
    B. 适用于动态变化频繁且需要快速查找的场景
    C. 需要额外的存储空间来存储索引表
    D. 查找速度比折半查找快

    **答案**：D
    **解释**：分块查找的查找速度比折半查找慢，但比顺序查找快。

14. **在分块查找中，块内记录的排列方式是什么？**
    A. 有序排列
    B. 无序排列
    C. 按关键字大小排列
    D. 按插入顺序排列

    **答案**：B
    **解释**：在分块查找中，块内记录是无序排列的。

15. **分块查找的缺点是什么？**
    A. 插入和删除操作复杂
    B. 查找速度慢
    C. 需要额外的存储空间来存储索引表
    D. 不适用于动态变化频繁的场景

    **答案**：C
    **解释**：分块查找的缺点是需要额外的存储空间来存储索引表，并且初始时需要对索引表进行排序运算。

16. **假设一个数据表有1000个记录，分成100个块，每块10个记录，使用顺序查找确定块，分块查找的平均查找长度是多少？**
    A. 10
    B. 11
    C. 12
    D. 13

    **答案**：C
    **解释**：根据公式 $ASL_u = \frac{1}{2} \left( \frac{n}{s} + s \right) + 1$，代入 $n=1000$，$s=10$，得到 $ASL_u = \frac{1}{2} \left( \frac{1000}{10} + 10 \right) + 1 = \frac{1}{2} \times 110 + 1 = 56$。

17. **在分块查找中，如果使用折半查找确定块，分块查找的平均查找长度公式是什么？**
    A. $ASL'_u \approx \log_{2} \left( \frac{n}{s} + 1 \right) + \frac{s}{2}$
    B. $ASL'_u \approx \log_{2} \left( \frac{n}{s} \right) + \frac{s}{2}$
    C. $ASL'_u \approx \log_{2} \left( \frac{n}{s} + 1 \right) + s$
    D. $ASL'_u \approx \log_{2} \left( \frac{n}{s} \right) + s$

    **答案**：A
    **解释**：使用折半查找确定块时，分块查找的平均查找长度公式为 $ASL'_u \approx \log_{2} \left( \frac{n}{s} + 1 \right) + \frac{s}{2}$。

18. **分块查找的优点不包括以下哪一项？**
    A. 插入和删除操作相对容易
    B. 适用于动态变化频繁且需要快速查找的场景
    C. 需要额外的存储空间来存储索引表
    D. 查找速度比折半查找快

    **答案**：D
    **解释**：分块查找的查找速度比折半查找慢，但比顺序查找快。

19. **在分块查找中，块内记录的排列方式是什么？**
    A. 有序排列
    B. 无序排列
    C. 按关键字大小排列
    D. 按插入顺序排列

    **答案**：B
    **解释**：在分块查找中，块内记录是无序排列的。

20. **分块查找的缺点是什么？**
    A. 插入和删除操作复杂
    B. 查找速度慢
    C. 需要额外的存储空间来存储索引表
    D. 不适用于动态变化频繁的场景

    **答案**：C
    **解释**：分块查找的缺点是需要额外的存储空间来存储索引表，并且初始时需要对索引表进行排序运算。

    
